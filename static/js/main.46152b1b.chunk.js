(this["webpackJsonpraytracing-in-one-weekend"]=this["webpackJsonpraytracing-in-one-weekend"]||[]).push([[0],{23:function(e,n){},26:function(e,n,a){e.exports=a(49)},31:function(e,n,a){},32:function(e,n,a){},49:function(e,n,a){"use strict";a.r(n);var t,i=a(9),o=a.n(i),r=a(19),s=a.n(r),l=(a(31),a(1)),d=a(3),u=a(5),f=a(4),c=a(6),h=a(13),A=(a(32),a(7)),m=a.n(A),p=a(8),x=a(2),F=a(12),_=a(10),P=a.n(_),v=a(0),T=a(20),g=2*Math.PI,y=(Math.PI,Math.PI,Math.PI,new v.Eb),N=new v.Eb(1,1,1),L=(new v.Eb(0,1,0),v.L),E=a(34);function S(e){var n=E.parse(window.location.search);return void 0!==n[e]&&n[e]}function I(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=E.parse(window.location.search),i=Object.assign({},t,Object(x.a)({},e,n)),o=E.stringify(i);if(a)window.location.href="".concat(window.location.pathname,"?").concat(o);else{var r="".concat(window.location.protocol,"//").concat(window.location.host).concat(window.location.pathname,"?").concat(o);window.history.pushState({path:r},"",r)}}var b=["high","normal"],w="normal";function X(){return w}var O=Object(T.getGPUTier)();var R=S("graphics");w=b.includes(R)&&"string"===typeof R?R:function(){switch(O.tier){case"GPU_DESKTOP_TIER_3":case"GPU_DESKTOP_TIER_2":case"GPU_MOBILE_TIER_3":return"high";case"GPU_DESKTOP_TIER_1":default:return"normal"}}();var U=(t={},Object(x.a)(t,"high",{antialias:!1,pixelRatio:L.clamp(window.devicePixelRatio,1,2),maxFrameBufferSize:new v.Db(1920,1080)}),Object(x.a)(t,"normal",{antialias:!1,pixelRatio:1,maxFrameBufferSize:new v.Db(1280,720)}),t),Q={isDevelopment:!1,baseUrl:"/raytracing-in-one-weekend",stats:!0,devCamera:!1,helpers:!1,datGui:!0,skipTransitions:!1,guiPrecision:.001,viewportPreviewScale:.25};Q.renderBufferFullscreen="true"===S("hd")||!1,Q.postProcessing=!0;var Y=Q,C=U[X()],M=C.maxFrameBufferSize,D=C.pixelRatio,j=Math.sqrt(M.x*M.y),k=j*j,G=new v.Db;function H(){return{width:G.x*D,height:G.y*D}}function z(e,n,a){var t=function(e,n){var a=e,t=n;if(e*n>k){var i=t/a,o=(a=j)*(t=Math.floor(j*i)),r=Math.sqrt(k/o);a=Math.floor(a*r),t=Math.floor(t*r)}return{width:a,height:t}}(n,a),i=t.width,o=t.height;Y.renderBufferFullscreen&&(i=n,o=a,console.log(i,o)),G.x=i,G.y=o,e.setSize(G.x,G.y),e.domElement.style.width="".concat(n,"px"),e.domElement.style.height="".concat(a,"px")}a(11);function B(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1024,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},t={minFilter:v.E,magFilter:v.V,format:v.kb,type:v.Cb,stencilBuffer:!1};return new v.Ib(e,n,Object.assign({},t,a))}var W=a(15);function V(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:N;e.position.set(a.x*n,a.y*n,a.z*n),e.lookAt(y)}function q(e){return new v.bb(65,e,.1,1e3)}function K(e){return new W.a(e,en.domElement)}var J=a(14),Z=function(){function e(){Object(l.a)(this,e)}return Object(d.a)(e,[{key:"add",value:function(e,n,a){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"open",value:function(){return this}},{key:"close",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"addFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"removeFolder",value:function(e){return this}},{key:"remove",value:function(){return this}},{key:"step",value:function(){return this}}]),e}(),$=function(){function e(){Object(l.a)(this,e)}return Object(d.a)(e,[{key:"add",value:function(e,n,a){return this}},{key:"addFolder",value:function(e){return new Z}},{key:"removeFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"close",value:function(){return this}},{key:"step",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"setValue",value:function(){return this}},{key:"remove",value:function(){return this}},{key:"open",value:function(){return this}}],[{key:"toggleHide",value:function(){return this}}]),e}(),ee=$;Y.datGui&&((ee=a(11).GUI).prototype.removeFolder=function(e){var n=this.__folders[e];n&&(n.close(),this.__ul.removeChild(n.domElement.parentNode),delete this.__folders[e],this.onResize())});var ne=new ee;function ae(e,n){var a=document.createElement("canvas");return a.width=e,a.height=n,{ctx:a.getContext("2d"),canvas:a}}J.a.device.isDesktop||ee.toggleHide();var te=B(128,128,{depthBuffer:!1,format:v.jb});function ie(e,n){!1===n?(e.wasFrustumCulled=e.frustumCulled,e.wasVisible=e.visible,e.visible=!0,e.frustumCulled=!1):(e.visible=e.wasVisible,e.frustumCulled=e.wasFrustumCulled),e.children.forEach((function(e){return ie(e,n)}))}function oe(e,n){var a=n.aspect;n.aspect=1,n.updateProjectionMatrix(),ie(e,!1),en.setRenderTarget(te),en.render(e,n),en.setRenderTarget(null),n.aspect=a,n.updateProjectionMatrix(),ie(e,!0)}var re=function e(n){Object(l.a)(this,e),Object.assign(this,n)},se=function(e){function n(){return Object(l.a)(this,n),Object(u.a)(this,Object(f.a)(n).apply(this,arguments))}return Object(c.a)(n,e),n}(P.a);se.json="json",se.image="image",se.threeFBX="fbx",se.threeGLTF="gltf",se.threeTexture="texture";var le=se,de=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(){var e=new Image;e.onload=function(){a.asset.data=e,a.emit("loaded",a.asset)},e.onerror=function(){a.emit("error","Failed to load ".concat(a.asset.src))},e.src=a.asset.src},a.asset=e,a}return Object(c.a)(n,e),n}(le),ue=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(){var e=new XMLHttpRequest;e.onreadystatechange=function(){4===e.readyState&&(4===e.readyState&&200===e.status?(a.asset.data=JSON.parse(e.responseText),a.emit("loaded",a.asset)):a.emit("error","Failed to load ".concat(a.asset.src)))},e.open("GET",a.asset.src,!0),e.send()},a.asset=e,a}return Object(c.a)(n,e),n}(le),fe=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(){(new v.xb).load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(c.a)(n,e),n}(le),ce=a(25),he=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(){(new ce.a).load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(c.a)(n,e),n}(le),Ae=a(21),me=new(a(22).a);me.setDecoderPath("".concat(Y.baseUrl,"/assets/lib/draco/gltf/")),me.preload();var pe,xe=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(){var e=new Ae.a;e.setDRACOLoader(me);e.load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(c.a)(n,e),n}(le),Fe=(pe={},Object(x.a)(pe,le.image,de),Object(x.a)(pe,le.json,ue),Object(x.a)(pe,le.threeTexture,fe),Object(x.a)(pe,le.threeFBX,he),Object(x.a)(pe,le.threeGLTF,xe),pe),_e=function(e){function n(){var e,a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object(l.a)(this,n),(e=Object(u.a)(this,Object(f.a)(n).call(this))).load=function(n){e.loaders=[],n.forEach((function(n){void 0!==Fe[n.type]&&e.loaders.push(new Fe[n.type](n))})),e.loaded=0,e.queue=0,e.currentParallel=0,e.total=e.loaders.length,0===e.total?e.emit("loaded",n):e.loadNextInQueue()},e.loadNextInQueue=function(){if(e.queue<e.total&&e.currentParallel<e.parallelLoads){var n=e.loaders[e.queue];e.queue+=1,e.currentParallel+=1,n.once("loaded",e.onLoaded),n.once("error",e.onError),n.load(),e.loadNextInQueue()}},e.onLoaded=function(){if(e.loaded+=1,e.emit("progress",e.loaded/e.total),e.loaded===e.total){var n=[];e.loaders.forEach((function(e){n.push(e.asset)})),e.emit("loaded",n)}else e.currentParallel-=1,e.loadNextInQueue()},e.onError=function(n){e.emit("error",n)},e.id=a.id||"",e.minParallel=a.minParallel||5,e.maxParallel=a.maxParallel||10,e.parallelLoads=J.a.device.isDesktop?e.maxParallel:e.minParallel,e}return Object(c.a)(n,e),n}(P.a),Pe=new(function(e){function n(){var e,a;Object(l.a)(this,n);for(var t=arguments.length,i=new Array(t),o=0;o<t;o++)i[o]=arguments[o];return(a=Object(u.a)(this,(e=Object(f.a)(n)).call.apply(e,[this].concat(i)))).load=function(e,n){var t=new _e({id:e});n.forEach((function(e){void 0===e.args&&(e.args={})})),t.on("progress",(function(e){a.emit("progress",e)})),t.once("loaded",(function(e){a.emit("loaded",e)})),t.once("error",(function(e){a.emit("error",e)})),t.load(n)},a}return Object(c.a)(n,e),n}(P.a)),ve=a(24),Te=new(function(){function e(){Object(l.a)(this,e),this.assets={}}return Object(d.a)(e,[{key:"add",value:function(e,n){var a;this.assets[e]=this.assets[e]||[],(a=this.assets[e]).push.apply(a,Object(ve.a)(n))}},{key:"get",value:function(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=this.find(this.assets[e],n);return!!(t&&t instanceof re)&&(a?t:t.data)}},{key:"find",value:function(e,n){return e.find((function(e){return e.id===n}))||!1}}]),e}());var ge=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(u.a)(this,Object(f.a)(n).call(this))).preloadGpuCullScene=function(e){},a.toggleHelpers=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];a.helpers.visible=e},a.toogleCameras=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];a.camera=e?a.cameras.dev:a.cameras.main,a.control=e?a.controls.dev:a.controls.main},a.resize=function(e,n){a.cameras.dev.aspect=e/n,a.cameras.dev.updateProjectionMatrix(),a.cameras.main.aspect=e/n,a.cameras.main.updateProjectionMatrix()},a.update=function(e){},a.dispose=function(){!function e(n,a){if(null!==n&&void 0!==n){if(a&&a.remove(n),n.dispose&&n.dispose(),n.geometry&&n.geometry.dispose(),n.material&&n.material.dispose(),n.children)for(var t=0,i=n.children.length;t<i;)e(n.children[0],n),t++;"Scene"===n.type&&n.dispose(),n=null}}(a.scene,null),a.gui&&ne.removeFolder(a.gui.name)},a.id=e.id||L.generateUUID(),a.clearColor=e.clearColor||0,a.lights=e.lights||[],a.assets=e.assets||[],a.scene=new v.nb,a.cameras={dev:q(G.x/G.y),main:q(G.x/G.y)},a.camera=Y.devCamera?a.cameras.dev:a.cameras.main,V(a.cameras.dev,5),V(a.cameras.main,5),a.controls={},e.controls&&(a.controls.dev=K(a.cameras.dev),a.controls.main=K(a.cameras.main)),a.control=Y.devCamera?a.controls.dev:a.controls.main,e.gui?(a.gui=ne.addFolder("".concat(a.id," scene")),e.guiOpen&&a.gui.open()):a.gui=new $,a.lights.forEach((function(e){a.scene.add(e.light),e.gui(a.gui)})),a}return Object(c.a)(n,e),Object(d.a)(n,[{key:"loadAssets",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.assets.length>0?(Pe.once("loaded",(function(a){a.length>0&&Te.add(n.id,a),e()})),Pe.once("error",(function(e){a(e)})),Pe.load(n.id,n.assets)):e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneHelpers",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.helpers=new v.u,n.helpers.add(new v.t(10,10),new v.c),n.helpers.visible=Y.helpers,n.scene.add(n.helpers),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneObjects",value:function(){var e=Object(p.a)(m.a.mark((function e(){return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setup",value:function(){var e=Object(p.a)(m.a.mark((function e(){return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.loadAssets();case 2:return e.next=4,this.createSceneHelpers();case 4:return e.next=6,this.createSceneObjects();case 6:this.preloadGpuCullScene(!0),oe(this.scene,this.camera),this.preloadGpuCullScene(!1);case 9:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(p.a)(m.a.mark((function e(){return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(p.a)(m.a.mark((function e(){return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(P.a),ye=a(46)(Promise,h.a),Ne=function(e){function n(e,a,t){var i;Object(l.a)(this,n),(i=Object(u.a)(this,Object(f.a)(n).call(this))).resize=function(e,n){i.mesh.material.uniforms.resolution.value.x=e,i.mesh.material.uniforms.resolution.value.y=n},i.render=function(e,n,a,t,o){e.update(o),n.update(o),en.setClearColor(e.clearColor),en.setRenderTarget(a),en.render(e.scene,e.camera),en.setClearColor(n.clearColor),en.setRenderTarget(t),en.render(n.scene,n.camera),i.mesh.material.uniforms.texture0.value=a.texture,i.mesh.material.uniforms.texture1.value=t.texture,en.setRenderTarget(null)},i.gui=e.addFolder("transition pass"),i.gui.close(),i.scene=new v.nb,i.camera=t,i.active=!1;var o=H(),r=o.width,s=o.height,d=new v.ob({uniforms:{texture0:{value:null},texture1:{value:null},transition:{value:0},resolution:{value:new v.Db(r,s)}},vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform sampler2D texture0;\n  uniform sampler2D texture1;\n  uniform float transition;\n  uniform vec2 resolution;\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(texture0, uv);\n    vec4 texel1 = texture2D(texture1, uv);\n    gl_FragColor = mix(texel0, texel1, transition);\n  }\n"});return i.mesh=new v.P(a,d),i.mesh.matrixAutoUpdate=!1,i.mesh.updateMatrix(),i.scene.add(i.mesh),i.gui.add(i.mesh.material.uniforms.transition,"value",0,1).onChange((function(e){i.active=0!==e&&1!==e})).name("transition").listen(),i}return Object(c.a)(n,e),Object(d.a)(n,[{key:"transition",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!Y.skipTransitions){e.next=4;break}this.mesh.material.uniforms.transition.value=1,e.next=9;break;case 4:return this.mesh.material.uniforms.transition.value=0,this.active=!0,h.a.killTweensOf(this.mesh.material.uniforms.transition),e.next=9,ye.to(this.mesh.material.uniforms.transition,1,{value:1}).then((function(){n.active=!1,n.emit("complete")}));case 9:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()}]),n}(P.a),Le={fxaaEnabled:{value:1},fxaaResolution:{value:new v.Db(1/1024,1/512)}};var Ee="\n  uniform vec2 resolution;\n  uniform float time;\n  uniform sampler2D tDiffuse;\n  // FXAA pass\n  ".concat("\n  precision highp float;\n  uniform bool fxaaEnabled;\n  uniform vec2 fxaaResolution;\n  varying vec2 vUv;\n","\n  ").concat("\n  // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n  //----------------------------------------------------------------------------------\n  // File:        es3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n  // SDK Version: v3.00\n  // Email:       gameworks@nvidia.com\n  // Site:        http://developer.nvidia.com/\n  //\n  // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions\n  // are met:\n  //  * Redistributions of source code must retain the above copyright\n  //    notice, this list of conditions and the following disclaimer.\n  //  * Redistributions in binary form must reproduce the above copyright\n  //    notice, this list of conditions and the following disclaimer in the\n  //    documentation and/or other materials provided with the distribution.\n  //  * Neither the name of NVIDIA CORPORATION nor the names of its\n  //    contributors may be used to endorse or promote products derived\n  //    from this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n  // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n  // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  //----------------------------------------------------------------------------------\n\n  #define FXAA_PC 1\n  #define FXAA_GLSL_100 1\n  #define FXAA_QUALITY_PRESET 12\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n      //\n      // The console algorithm for PC is included\n      // for developers targeting really low spec machines.\n      // Likely better to just run FXAA_PC, and use a really low preset.\n      //\n      #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n      #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n      #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n      #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n      #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n      #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n      //\n      // For those using non-linear color,\n      // and either not able to get luma in alpha, or not wanting to,\n      // this enables FXAA to run using green as a proxy for luma.\n      // So with this enabled, no need to pack luma in alpha.\n      //\n      // This will turn off AA on anything which lacks some amount of green.\n      // Pure red and blue or combination of only R and B, will get no AA.\n      //\n      // Might want to lower the settings for both,\n      //    fxaaConsoleEdgeThresholdMin\n      //    fxaaQualityEdgeThresholdMin\n      // In order to insure AA does not get turned off on colors\n      // which contain a minor amount of green.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n      //\n      // Controls algorithm's early exit path.\n      // On PS3 turning this ON adds 2 cycles to the shader.\n      // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n      // Turning this off on console will result in a more blurry image.\n      // So this defaults to on.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n      //\n      // Only valid for PC OpenGL currently.\n      // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n      //\n      // 1 = Use discard on pixels which don't need AA.\n      //     For APIs which enable concurrent TEX+ROP from same surface.\n      // 0 = Return unchanged color on pixels which don't need AA.\n      //\n      #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n      //\n      // Used for GLSL 120 only.\n      //\n      // 1 = GL API supports fast pixel offsets\n      // 0 = do not use fast pixel offsets\n      //\n      #ifdef GL_EXT_gpu_shader4\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifndef FXAA_FAST_PIXEL_OFFSET\n          #define FXAA_FAST_PIXEL_OFFSET 0\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n      //\n      // 1 = API supports gather4 on alpha channel.\n      // 0 = API does not support gather4 on alpha channel.\n      //\n      #if (FXAA_HLSL_5 == 1)\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifndef FXAA_GATHER4_ALPHA\n          #define FXAA_GATHER4_ALPHA 0\n      #endif\n  #endif\n\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITY_PRESET\n      //\n      // Choose the quality preset.\n      // This needs to be compiled into the shader as it effects code.\n      // Best option to include multiple presets is to\n      // in each shader define the preset, then include this file.\n      //\n      // OPTIONS\n      // -----------------------------------------------------------------------\n      // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n      // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n      // 39       - no dither, very expensive\n      //\n      // NOTES\n      // -----------------------------------------------------------------------\n      // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n      // 13 = about same speed as FXAA 3.9 and better than 12\n      // 23 = closest to FXAA 3.9 visually and performance wise\n      //  _ = the lowest digit is directly related to performance\n      // _  = the highest digit is directly related to style\n      //\n      #define FXAA_QUALITY_PRESET 12\n  #endif\n\n\n  /*============================================================================\n\n                              FXAA QUALITY - PRESETS\n\n  ============================================================================*/\n\n  /*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 10)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 3.0\n      #define FXAA_QUALITY_P2 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 11)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 3.0\n      #define FXAA_QUALITY_P3 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 12)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 4.0\n      #define FXAA_QUALITY_P4 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 13)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 4.0\n      #define FXAA_QUALITY_P5 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 14)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 4.0\n      #define FXAA_QUALITY_P6 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 15)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 12.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 20)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 2.0\n      #define FXAA_QUALITY_P2 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 21)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 22)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 23)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 24)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 3.0\n      #define FXAA_QUALITY_P6 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 25)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 26)\n      #define FXAA_QUALITY_PS 9\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 4.0\n      #define FXAA_QUALITY_P8 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 27)\n      #define FXAA_QUALITY_PS 10\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 4.0\n      #define FXAA_QUALITY_P9 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 28)\n      #define FXAA_QUALITY_PS 11\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 4.0\n      #define FXAA_QUALITY_P10 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 29)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 39)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.0\n      #define FXAA_QUALITY_P2 1.0\n      #define FXAA_QUALITY_P3 1.0\n      #define FXAA_QUALITY_P4 1.0\n      #define FXAA_QUALITY_P5 1.5\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n\n\n  /*============================================================================\n\n                                  API PORTING\n\n  ============================================================================*/\n  #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n      #define FxaaBool bool\n      #define FxaaDiscard discard\n      #define FxaaFloat float\n      #define FxaaFloat2 vec2\n      #define FxaaFloat3 vec3\n      #define FxaaFloat4 vec4\n      #define FxaaHalf float\n      #define FxaaHalf2 vec2\n      #define FxaaHalf3 vec3\n      #define FxaaHalf4 vec4\n      #define FxaaInt2 ivec2\n      #define FxaaSat(x) clamp(x, 0.0, 1.0)\n      #define FxaaTex sampler2D\n  #else\n      #define FxaaBool bool\n      #define FxaaDiscard clip(-1)\n      #define FxaaFloat float\n      #define FxaaFloat2 float2\n      #define FxaaFloat3 float3\n      #define FxaaFloat4 float4\n      #define FxaaHalf half\n      #define FxaaHalf2 half2\n      #define FxaaHalf3 half3\n      #define FxaaHalf4 half4\n      #define FxaaSat(x) saturate(x)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_120 == 1)\n      // Requires,\n      //  #version 120\n      // And at least,\n      //  #extension GL_EXT_gpu_shader4 : enable\n      //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n      #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n      #if (FXAA_FAST_PIXEL_OFFSET == 1)\n          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n      #else\n          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n      #endif\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_130 == 1)\n      // Requires #version 130 or better\n      #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_3 == 1)\n      #define FxaaInt2 float2\n      #define FxaaTex sampler2D\n      #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n      #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_4 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_5 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n      #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n      #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n      #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n      #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n  #endif\n\n\n  /*============================================================================\n                      GREEN AS LUMA OPTION SUPPORT FUNCTION\n  ============================================================================*/\n  #if (FXAA_GREEN_AS_LUMA == 0)\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n  #else\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n  #endif\n\n\n\n\n  /*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n  ============================================================================*/\n  #if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n      //\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy} = center of pixel\n      FxaaFloat2 pos,\n      //\n      // Used only for FXAA Console, and not used on the 360 version.\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy_} = upper left of pixel\n      // {_zw} = lower right of pixel\n      FxaaFloat4 fxaaConsolePosPos,\n      //\n      // Input color texture.\n      // {rgb_} = color in linear or perceptual color space\n      // if (FXAA_GREEN_AS_LUMA == 0)\n      //     {__a} = luma in perceptual color space (not linear)\n      FxaaTex tex,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 2nd sampler.\n      // This sampler needs to have an exponent bias of -1.\n      FxaaTex fxaaConsole360TexExpBiasNegOne,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 3nd sampler.\n      // This sampler needs to have an exponent bias of -2.\n      FxaaTex fxaaConsole360TexExpBiasNegTwo,\n      //\n      // Only used on FXAA Quality.\n      // This must be from a constant/uniform.\n      // {x_} = 1.0/screenWidthInPixels\n      // {_y} = 1.0/screenHeightInPixels\n      FxaaFloat2 fxaaQualityRcpFrame,\n      //\n      // Only used on FXAA Console.\n      // This must be from a constant/uniform.\n      // This effects sub-pixel AA quality and inversely sharpness.\n      //   Where N ranges between,\n      //     N = 0.50 (default)\n      //     N = 0.33 (sharper)\n      // {x__} = -N/screenWidthInPixels\n      // {_y_} = -N/screenHeightInPixels\n      // {_z_} =  N/screenWidthInPixels\n      // {__w} =  N/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt,\n      //\n      // Only used on FXAA Console.\n      // Not used on 360, but used on PS3 and PC.\n      // This must be from a constant/uniform.\n      // {x__} = -2.0/screenWidthInPixels\n      // {_y_} = -2.0/screenHeightInPixels\n      // {_z_} =  2.0/screenWidthInPixels\n      // {__w} =  2.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n      //\n      // Only used on FXAA Console.\n      // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n      // This must be from a constant/uniform.\n      // {x__} =  8.0/screenWidthInPixels\n      // {_y_} =  8.0/screenHeightInPixels\n      // {_z_} = -4.0/screenWidthInPixels\n      // {__w} = -4.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_SUBPIX define.\n      // It is here now to allow easier tuning.\n      // Choose the amount of sub-pixel aliasing removal.\n      // This can effect sharpness.\n      //   1.00 - upper limit (softer)\n      //   0.75 - default amount of filtering\n      //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n      //   0.25 - almost off\n      //   0.00 - completely off\n      FxaaFloat fxaaQualitySubpix,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // The minimum amount of local contrast required to apply algorithm.\n      //   0.333 - too little (faster)\n      //   0.250 - low quality\n      //   0.166 - default\n      //   0.125 - high quality\n      //   0.063 - overkill (slower)\n      FxaaFloat fxaaQualityEdgeThreshold,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n      //   0.0625 - high quality (faster)\n      //   0.0312 - visible limit (slower)\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaQualityEdgeThresholdMin,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only three safe values here: 2 and 4 and 8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // For all other platforms can be a non-power of two.\n      //   8.0 is sharper (default!!!)\n      //   4.0 is softer\n      //   2.0 is really soft (good only for vector graphics inputs)\n      FxaaFloat fxaaConsoleEdgeSharpness,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only two safe values here: 1/4 and 1/8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // The console setting has a different mapping than the quality setting.\n      // Other platforms can use other values.\n      //   0.125 leaves less aliasing, but is softer (default!!!)\n      //   0.25 leaves more aliasing, and is sharper\n      FxaaFloat fxaaConsoleEdgeThreshold,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      // The console setting has a different mapping than the quality setting.\n      // This only applies when FXAA_EARLY_EXIT is 1.\n      // This does not apply to PS3,\n      // PS3 was simplified to avoid more shader instructions.\n      //   0.06 - faster but more aliasing in darks\n      //   0.05 - default\n      //   0.04 - slower and less aliasing in darks\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaConsoleEdgeThresholdMin,\n      //\n      // Extra constants for 360 FXAA Console only.\n      // Use zeros or anything else for other platforms.\n      // These must be in physical constant registers and NOT immediates.\n      // Immediates will result in compiler un-optimizing.\n      // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n      FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posM;\n      posM.x = pos.x;\n      posM.y = pos.y;\n      #if (FXAA_GATHER4_ALPHA == 1)\n          #if (FXAA_DISCARD == 0)\n              FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n              #if (FXAA_GREEN_AS_LUMA == 0)\n                  #define lumaM rgbyM.w\n              #else\n                  #define lumaM rgbyM.y\n              #endif\n          #endif\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n          #else\n              FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n          #endif\n          #if (FXAA_DISCARD == 1)\n              #define lumaM luma4A.w\n          #endif\n          #define lumaE luma4A.z\n          #define lumaS luma4A.x\n          #define lumaSE luma4A.y\n          #define lumaNW luma4B.w\n          #define lumaN luma4B.z\n          #define lumaW luma4B.x\n      #else\n          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              #define lumaM rgbyM.w\n          #else\n              #define lumaM rgbyM.y\n          #endif\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n          #endif\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat maxSM = max(lumaS, lumaM);\n      FxaaFloat minSM = min(lumaS, lumaM);\n      FxaaFloat maxESM = max(lumaE, maxSM);\n      FxaaFloat minESM = min(lumaE, minSM);\n      FxaaFloat maxWN = max(lumaN, lumaW);\n      FxaaFloat minWN = min(lumaN, lumaW);\n      FxaaFloat rangeMax = max(maxWN, maxESM);\n      FxaaFloat rangeMin = min(minWN, minESM);\n      FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n      FxaaFloat range = rangeMax - rangeMin;\n      FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n      FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n      if(earlyExit)\n          #if (FXAA_DISCARD == 1)\n              FxaaDiscard;\n          #else\n              return rgbyM;\n          #endif\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_GATHER4_ALPHA == 0)\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n          #endif\n      #else\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNS = lumaN + lumaS;\n      FxaaFloat lumaWE = lumaW + lumaE;\n      FxaaFloat subpixRcpRange = 1.0/range;\n      FxaaFloat subpixNSWE = lumaNS + lumaWE;\n      FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n      FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNESE = lumaNE + lumaSE;\n      FxaaFloat lumaNWNE = lumaNW + lumaNE;\n      FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n      FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNWSW = lumaNW + lumaSW;\n      FxaaFloat lumaSWSE = lumaSW + lumaSE;\n      FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n      FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n      FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n      FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n      FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n      FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n      FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n      FxaaBool horzSpan = edgeHorz >= edgeVert;\n      FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n      if(!horzSpan) lumaN = lumaW;\n      if(!horzSpan) lumaS = lumaE;\n      if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n      FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat gradientN = lumaN - lumaM;\n      FxaaFloat gradientS = lumaS - lumaM;\n      FxaaFloat lumaNN = lumaN + lumaM;\n      FxaaFloat lumaSS = lumaS + lumaM;\n      FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n      FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n      if(pairN) lengthSign = -lengthSign;\n      FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posB;\n      posB.x = posM.x;\n      posB.y = posM.y;\n      FxaaFloat2 offNP;\n      offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n      offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n      if(!horzSpan) posB.x += lengthSign * 0.5;\n      if( horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posN;\n      posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n      posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat2 posP;\n      posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n      posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n      FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n      FxaaFloat subpixE = subpixC * subpixC;\n      FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n      if(!pairN) lumaNN = lumaSS;\n      FxaaFloat gradientScaled = gradient * 1.0/4.0;\n      FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n      FxaaFloat subpixF = subpixD * subpixE;\n      FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n      lumaEndN -= lumaNN * 0.5;\n      lumaEndP -= lumaNN * 0.5;\n      FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n      FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n      FxaaBool doneNP = (!doneN) || (!doneP);\n      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n  /*--------------------------------------------------------------------------*/\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 3)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 4)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 5)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 6)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n  /*--------------------------------------------------------------------------*/\n                          #if (FXAA_QUALITY_PS > 7)\n                          if(doneNP) {\n                              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                              doneN = abs(lumaEndN) >= gradientScaled;\n                              doneP = abs(lumaEndP) >= gradientScaled;\n                              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                              doneNP = (!doneN) || (!doneP);\n                              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_QUALITY_PS > 8)\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 9)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 10)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 11)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 12)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n      #endif\n  /*--------------------------------------------------------------------------*/\n                          }\n                          #endif\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat dstN = posM.x - posN.x;\n      FxaaFloat dstP = posP.x - posM.x;\n      if(!horzSpan) dstN = posM.y - posN.y;\n      if(!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n      FxaaFloat spanLength = (dstP + dstN);\n      FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n      FxaaFloat spanLengthRcp = 1.0/spanLength;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool directionN = dstN < dstP;\n      FxaaFloat dst = min(dstN, dstP);\n      FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n      FxaaFloat subpixG = subpixF * subpixF;\n      FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n      FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n      FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n      if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n      if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n      #if (FXAA_DISCARD == 1)\n          return FxaaTexTop(tex, posM);\n      #else\n          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n      #endif\n  }\n  /*==========================================================================*/\n  #endif\n","\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 outgoingColor = texture2D(tDiffuse, uv);\n    // FXAA pass\n    ").concat("\n  // FXAA pass start\n  if (fxaaEnabled) {\n    outgoingColor = FxaaPixelShader(\n      uv,\n      vec4(0.0),\n      tDiffuse,\n      tDiffuse,\n      tDiffuse,\n      fxaaResolution,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n    );\n    // TODO avoid querying texture twice for same texel\n    outgoingColor.a = texture2D(tDiffuse, uv).a;\n  }\n  // FXAA pass end\n","\n    gl_FragColor.rgb = outgoingColor.rgb;\n    gl_FragColor.a = outgoingColor.a;\n  }\n"),Se=function(){function e(n,a,t){Object(l.a)(this,e),this.gui=n.addFolder("final pass"),this.gui.close(),this.scene=new v.nb,this.camera=t;var i=H(),o=i.width,r=i.height,s=new v.ob({uniforms:v.Bb.merge([{time:{value:0},tDiffuse:{value:null},resolution:{value:new v.Db(o,r)}},Le]),vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:Ee});!function(e,n){var a=e.addFolder("fxaa pass");a.close(),a.add(n.uniforms.fxaaEnabled,"value",0,1,1).name("enabled")}(this.gui,s),this.mesh=new v.P(a,s),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh)}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.mesh.material.uniforms.fxaaResolution.value.x=1/e,this.mesh.material.uniforms.fxaaResolution.value.y=1/n}},{key:"render",value:function(e,n,a){this.mesh.material.uniforms.tDiffuse.value=n.texture,this.mesh.material.uniforms.time.value+=a,en.render(this.scene,this.camera)}},{key:"screenshotRender",value:function(e,n,a,t,i){this.mesh.material.uniforms.tDiffuse.value=a.texture,this.mesh.material.uniforms.time.value+=i,en.setRenderTarget(t),en.render(this.scene,this.camera)}}]),e}(),Ie=function(e){function n(e,a){var t;return Object(l.a)(this,n),(t=Object(u.a)(this,Object(f.a)(n).call(this,{id:e,clearColor:a}))).camera.position.set(0,0,10),t.camera.lookAt(y),t}return Object(c.a)(n,e),n}(ge),be=function(){function e(n,a,t){Object(l.a)(this,e),this.scene=new v.nb,this.camera=t;var i=H(),o=i.width,r=i.height,s=new v.ob({uniforms:{tDiffuse:{value:null},resolution:{value:new v.Db(o,r)}},vertexShader:"\n        void main() {\n          gl_Position = vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n        void main() {\n          vec2 uv = gl_FragCoord.xy / resolution;\n          gl_FragColor = texture2D(tDiffuse, uv);\n        }\n      "});this.mesh=new v.P(a,s),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh)}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n}},{key:"render",value:function(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];a?en.render(this.scene,this.camera):(en.setRenderTarget(e),this.mesh.material.uniforms.tDiffuse.value=n.texture,en.render(this.scene,this.camera),en.setRenderTarget(null))}}]),e}(),we=function(){function e(n,a,t){var i=this;Object(l.a)(this,e),this.reset=function(){i.passes=0},this.gui=n.addFolder("denoise pass"),this.gui.open(),this.scene=new v.nb,this.camera=t;var o=H(),r=o.width,s=o.height,d=new v.ob({uniforms:{tDiffusePrev:{value:null},tDiffuse:{value:null},frameCount:{value:0},resolution:{value:new v.Db(r,s)}},vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform sampler2D tDiffuse;\n  uniform sampler2D tDiffusePrev;\n  uniform float frameCount;\n  uniform vec2 resolution;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(tDiffusePrev, uv);\n    vec4 texel1 = texture2D(tDiffuse, uv);\n    gl_FragColor = mix(texel0, texel1, clamp(1.0 / frameCount, 0.0, 1.0));\n  }\n"});this.mesh=new v.P(a,d),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh),this.active=!1,this.passes=0,this.maxPasses=2e3,this.gui.add(this,"passes").listen(),this.gui.add(this,"maxPasses",0,2e4),this.gui.add(this,"active").onChange(this.reset).listen()}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.reset()}},{key:"render",value:function(e,n,a,t){this.mesh.material.uniforms.frameCount.value=this.passes,en.setRenderTarget(n),en.render(e.scene,e.camera),en.setRenderTarget(t),this.mesh.material.uniforms.tDiffuse.value=n.texture,this.mesh.material.uniforms.tDiffusePrev.value=a.texture,en.render(this.scene,this.camera),en.setRenderTarget(null),this.passes++}},{key:"pauseRendering",value:function(){return this.active&&this.passes>=this.maxPasses}}]),e}(),Xe=a(23),Oe=a.n(Xe),Re="\n  struct Ray {\n    vec3 origin;\n    vec3 direction;\n  };\n\n  Ray getRay(float u, float v, Camera camera) {\n    return Ray(camera.origin, camera.lowerLeftCorner + u * camera.horizontal + v * camera.vertical - camera.origin);\n  }\n\n  vec3 pointAtParameter(float t, Ray ray) {\n    return ray.origin + t * ray.direction;\n  }\n",Ue="\n  struct Camera {\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    float aspect;\n    vec3 origin;\n  };\n\n  Camera createCamera(vec3 origin, vec3 lookat, vec3 up, float aspect) {\n    float theta = fov * (PI / 180.0);\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    vec3 w = normalize(origin - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n\n    vec3 lowerLeftCorner = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = 2.0 * halfWidth * u;\n    vec3 vertical = 2.0 * halfHeight * v;\n\n    return Camera(\n      lowerLeftCorner,\n      horizontal,\n      vertical,\n      aspect,\n      origin\n    );\n  }\n",Qe="\n  struct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n  };\n",Ye="\n  bool sphereHit(Ray ray, const in float tMin, const in float tMax, const in Sphere sphere, inout HitRecord hitRecord) {\n\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction); // origin\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discriminant = b * b - a * c;\n\n    if (discriminant < 0.0) return false;\n\n    float s = sqrt(discriminant);\n\n    float temp = (-b - s) / a;\n    if (temp < tMax && temp > tMin) {\n      hitRecord.t = temp;\n      hitRecord.position = ray.origin + temp * ray.direction;\n      hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n      hitRecord.material = sphere.material;\n      return true;\n    }\n    temp = (-b + s) / a;\n    if (temp < tMax && temp > tMin) {\n      hitRecord.t = temp;\n      hitRecord.position = ray.origin + temp * ray.direction;\n      hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n      hitRecord.material = sphere.material;\n      return true;\n    }\n    return false;\n  }\n\n  bool hit(Ray ray, float tMin, float tMax, Sphere list[".concat(5,"], inout HitRecord hitRecord) {\n    bool hitAnything = false;\n    float closestSoFar = tMax;\n    // If record doesn't hit, we use the previous\n    HitRecord tempRecord = hitRecord;\n    for(int i = 0; i < ").concat(5,"; i++) {\n      if (sphereHit(ray, tMin, closestSoFar, list[i], tempRecord)) {\n        hitAnything = true;\n        closestSoFar = tempRecord.t;\n        hitRecord = tempRecord;\n      }\n    }\n    return hitAnything;\n  }\n\n\n"),Ce="\n\n  vec3 ref(vec3 direction, vec3 normal) {\n    return direction - 2.0 * dot(direction, normal) * normal;\n  }\n\n  bool refract(const in vec3 direction, const in vec3 normal, const in float niOverNt, out vec3 refracted) {\n    float dt = dot(direction, normal);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if (discriminant > 0.0) {\n      refracted = niOverNt * (direction - normal * dt) - normal * sqrt(discriminant);\n      return true;\n    }\n    return false;\n  }\n\n  float schlick(float cosine, float reflectionIndex) {\n    float r0 = (1.0 - reflectionIndex) / (1.0 + reflectionIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n  }\n\n  bool scatter(inout Ray ray, const in HitRecord hitRecord, out vec3 attenuation, out Ray scatteredRay) {\n    if(hitRecord.material.type == METAL) {\n      attenuation = hitRecord.material.albedo;\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float fuzz = clamp(hitRecord.material.value, 0.0, 1.0);\n      scatteredRay = Ray(hitRecord.position, normalize(reflected + fuzz * randomInSphere(hitRecord.normal.xz)));\n      return (dot(scatteredRay.direction, hitRecord.normal) > 0.0);\n    } else if(hitRecord.material.type == DIELECTRIC) {\n\n      vec3 outwardNormal = vec3(0);\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float niOverNt = 0.0;\n\n      float reflectionIndex = hitRecord.material.value;\n\n      attenuation = vec3(1.0);\n      vec3 refracted = vec3(0);\n      float reflectProbability = 0.0;\n      float cosine = 0.0;\n\n      if (dot(ray.direction, hitRecord.normal) > 0.0) {\n        outwardNormal = -hitRecord.normal;\n        niOverNt = reflectionIndex;\n        cosine = reflectionIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      } else {\n        outwardNormal = hitRecord.normal;\n        niOverNt = 1.0 / reflectionIndex;\n        cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      }\n\n      if(refract(ray.direction, outwardNormal, niOverNt, refracted)) {\n        scatteredRay = Ray(hitRecord.position, refracted);\n        reflectProbability = schlick(cosine, hitRecord.material.value);\n      } else {\n        scatteredRay = Ray(hitRecord.position, reflected);\n        reflectProbability = 1.0;\n      }\n\n      if (rand(vUv + seed.xy + hitRecord.position.xz) < reflectProbability) {\n        scatteredRay = Ray(hitRecord.position, reflected);\n      } else {\n        scatteredRay = Ray(hitRecord.position, refracted);\n      }\n\n      return true;\n    } else {\n      // lambert\n      attenuation = hitRecord.material.albedo;\n      vec3 target = hitRecord.position + hitRecord.normal + randomInSphere(hitRecord.normal.xz);\n      scatteredRay = Ray(hitRecord.position, normalize(target - hitRecord.position));\n      return true;\n    }\n  }\n",Me=function(e){return"\n    vec3 raytraceWorld(in Ray ray, Sphere world[".concat(5,"]) {\n    HitRecord hitRecord;\n    vec3 color = vec3(1);\n\n    for(int i = 0; i < ").concat(e,"; i++) {\n      Ray scatteredRay;\n      if (hit(ray, 0.001, MAX_FLOAT, world, hitRecord)) {\n          vec3 attenuation;\n          if(scatter(ray, hitRecord, attenuation, scatteredRay)) {\n            color *= attenuation;\n            ray = scatteredRay;\n          } else {\n            return vec3(0);\n          }\n      } else {\n        // Sky color\n        float t = 0.5 * ray.direction.y + 1.0;\n        color *= mix(vec3(1), vec3(0.5, 0.7, 1.0), t);\n        return color;\n      }\n    }\n\n    return vec3(0);\n  }\n  ")},De={resolution:{value:new v.Db},fov:{value:20},seed:{value:new v.Fb(Math.random(),Math.random(),Math.random(),Math.random())},time:{value:0},cameraAspect:{value:1},cameraPosition:{value:new v.Eb},cameraTarget:{value:new v.Eb},sphere0Position:{value:new v.Eb(0,0,-1)},sphere1Position:{value:new v.Eb(1,0,-1)},sphere2Position:{value:new v.Eb(-1,0,-1)},refractionIndex:{value:1.5}},je=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50;return"\n    uniform vec2 resolution;\n    uniform float time;\n    uniform vec4 seed;\n    uniform float fov;\n    uniform vec3 cameraTarget;\n    uniform float cameraAspect;\n    uniform float refractionIndex;\n    uniform vec3 sphere0Position;\n    uniform vec3 sphere1Position;\n    uniform vec3 sphere2Position;\n    varying vec2 vUv;\n\n    #define MAX_FLOAT 1e5\n    #define PI 3.141592653589793\n    #define TWO_PI 6.283185307179586\n    #define LAMBERT 0\n    #define METAL 1\n    #define DIELECTRIC 2\n\n    float rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec3 randomInSphere(vec2 seed2){\n      vec2 uv = vec2(rand(vUv + seed.xy + seed2), rand(vUv + seed.xz + seed2));\n      float theta = 2.0 * PI * uv.x;\n      float phi = acos(2.0 * uv.y - 1.0);\n      float radius = 1.0;\n      float x = (radius * sin(phi) * cos(theta));\n      float y = (radius * sin(phi) * sin(theta));\n      float z = (radius * cos(phi));\n      return vec3(x, y, z);\n    }\n\n    struct Material {\n      int type;\n      vec3 albedo;\n      float value;\n    };\n\n    struct HitRecord {\n      float t;\n      vec3 position;\n      vec3 normal;\n      Material material;\n    };\n\n    ".concat(Ue,"\n    ").concat(Re,"\n    ").concat(Qe,"\n    ").concat(Ce,"\n    ").concat(Ye,"\n    ").concat(Me(e),"\n\n    vec3 calculateNormals(float t, vec3 center, Ray ray) {\n      vec3 normal = pointAtParameter(t, ray) - center;\n      normal /= length(normal); // make normal unit length\n      return normal;\n    }\n\n    void main(){\n\n      // Fix aspect\n      vec2 uv = vUv;\n      uv.y -= 0.5;\n      uv.y *= 2.0 * resolution.y / resolution.x;\n      uv.y += 0.5;\n\n      Sphere world[").concat(5,"];\n      world[0] = Sphere(vec3(0.0, 0.0, 0.0), 0.5, Material(LAMBERT, vec3(0.1, 0.2, 0.5), 0.0));\n      world[1] = Sphere(vec3(0.0, -100.5, 0.0), 100.0, Material(LAMBERT, vec3(0.5), 0.0));\n      world[2] = Sphere(vec3(1.0, 0.0, 0.0), 0.5, Material(METAL, vec3(0.8, 0.6, 0.2), 0.0));\n      world[3] = Sphere(vec3(-1.0, 0.0, 0.0), 0.5, Material(DIELECTRIC, vec3(0), 1.5));\n      world[4] = Sphere(vec3(-1.0, 0.0, 0.0), -0.45, Material(DIELECTRIC, vec3(0), 1.5));\n\n      // Anti aliasing\n      // const int ns = 20;\n      // vec3 col = vec3(0);\n      // float scale = 0.00001;\n      // for(int i = 0; i < ns; i++) {\n      //   float u = ((random.x * 2.0 - 1.0) * scale) + uv.x;\n      //   float v = ((random.y * 2.0 - 1.0) * scale) + uv.y;\n\n      //   Ray ray = getRay(u, v, lowerLeftCorner, horizontal, vertical);\n      //   Camera camera = Camera(\n      //     lowerLeftCorner,\n      //     horizontal,\n      //     vertical,\n      //     ray\n      //   );\n\n      //   col += raytrace(ray, world);\n      // }\n\n      // col /= float(ns);\n      // vec3 outgoingColor = col;\n\n      Camera camera = createCamera(cameraPosition,\n                                  cameraTarget,\n                                  vec3(0.0, 1.0, 0.0),\n                                  2.0);\n\n      Ray ray = getRay(uv.x, uv.y, camera);\n\n      vec3 outgoingColor = raytraceWorld(ray, world);\n\n      gl_FragColor = vec4(outgoingColor, 1.0);\n      gl_FragColor = LinearTosRGB(gl_FragColor);\n    }\n  ")},ke=function(){function e(n){var a=this;Object(l.a)(this,e),this.createMaterial=function(){return new v.ob({uniforms:De,vertexShader:"\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:je(a.maxBounces)})},this.rebuild=function(){a.mesh.material=a.createMaterial(),a.onChange()},this.onChange=function(){Ke.denoisePass.reset()},this.onChange=function(){Ke.denoisePass.reset()},this.gui=n.addFolder("raytracer"),this.gui.open(),this.maxBounces=50,this.mesh=new v.P(new v.cb(2,2),this.createMaterial()),this.gui.add(this.mesh.material.uniforms.fov,"value",1,100).name("fov").onChange(this.onChange),this.gui.add(this,"maxBounces",1,200,1).onChange(this.rebuild)}return Object(d.a)(e,[{key:"addControl",value:function(e){var n=this.gui.addFolder("sphere".concat(e));n.open();n.add(this.mesh.material.uniforms["sphere".concat(e,"Position")].value,"x",-5,5).onChange(this.onChange),n.add(this.mesh.material.uniforms["sphere".concat(e,"Position")].value,"y",-5,5).onChange(this.onChange),n.add(this.mesh.material.uniforms["sphere".concat(e,"Position")].value,"z",-5,5).onChange(this.onChange),n.add(this.mesh.material.uniforms.refractionIndex,"value",0,5).onChange(this.onChange)}},{key:"resize",value:function(e,n,a){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.mesh.material.uniforms.cameraAspect.value=a.aspect}},{key:"update",value:function(e,n,a){this.mesh.material.uniforms.seed.value.set(Math.random(),Math.random(),Math.random(),Math.random()),this.mesh.material.uniforms.time.value+=e,this.mesh.material.uniforms.cameraPosition.value.copy(n.position),this.mesh.material.uniforms.cameraTarget.value.copy(a.target)}}]),e}(),Ge=function(e){function n(){var e;return Object(l.a)(this,n),(e=Object(u.a)(this,Object(f.a)(n).call(this,{id:"main",assets:Oe.a,gui:!0,guiOpen:!0,controls:!0}))).resize=function(n,a){e.cameras.dev.aspect=n/a,e.cameras.dev.updateProjectionMatrix(),e.cameras.main.aspect=n/a,e.cameras.main.updateProjectionMatrix(),e.raytracer.resize(n,a,e.camera)},e.update=function(n){e.controls.main.update(),e.raytracer.update(n,e.camera,e.control)},e.cameras.main.position.set(5,5,5),e.cameras.main.lookAt(y),e}return Object(c.a)(n,e),Object(d.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.raytracer=new ke(n.gui),n.scene.add(n.raytracer.mesh),n.control.addEventListener("change",(function(){Ke.denoisePass.reset()})),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(ge),He=function(){function e(n){var a=this;Object(l.a)(this,e),this.gui=n;var t=function(){var e=new v.g,n=new v.f(new Float32Array([-1,-1,0,-1,4,0,4,-1,0]),3);return e.setAttribute("position",n),e.setIndex([0,2,1]),e}();this.camera=new v.ab(-1,1,1,-1,0,1);var i=H(),o=i.width,r=i.height,s={stencilBuffer:!1,format:v.jb};this.renderTargetTransitionA=B(o,r,s),this.renderTargetTransitionB=B(o,r,s),this.renderTargetDenoise=B(o,r,s),this.renderTargetDenoisePrev=B(o,r,s),this.renderTargetDenoiseCombined=B(o,r,s),this.transitionPass=new Ne(this.gui,t,this.camera),this.finalPass=new Se(this.gui,t,this.camera),this.denoisePass=new we(this.gui,t,this.camera),this.copyPass=new be(this.gui,t,this.camera),this.transitionPass.on("complete",(function(){"main"===a.sceneB.id&&(a.denoisePass.active=!0)}));var d=new Ie("post scene a",0),u=new Ie("post scene b",0);d.setup(),u.setup(),this.setScenes(d,u),this.resize()}return Object(d.a)(e,[{key:"setScenes",value:function(e,n){this.sceneA=e,this.sceneB=n}},{key:"resize",value:function(){var e=H(),n=e.width,a=e.height;this.renderTargetTransitionA.setSize(n,a),this.renderTargetTransitionB.setSize(n,a),this.renderTargetDenoise.setSize(n,a),this.renderTargetDenoisePrev.setSize(n,a),this.renderTargetDenoiseCombined.setSize(n,a),this.transitionPass.resize(n,a),this.denoisePass.resize(n,a),this.copyPass.resize(n,a),this.finalPass.resize(n,a)}},{key:"render",value:function(e){this.denoisePass.pauseRendering()||(this.currentScene=0===this.transitionPass.mesh.material.uniforms.transition.value?this.sceneA:this.sceneB,this.lastPass=this.currentScene,this.currentScene.update(e),this.transitionPass.active?(this.transitionPass.render(this.sceneA,this.sceneB,this.renderTargetTransitionA,this.renderTargetTransitionB,e),this.lastPass=this.transitionPass):(en.setClearColor(this.currentScene.clearColor),this.currentScene.update(e)),this.denoisePass.active?(this.denoisePass.render(this.lastPass,this.renderTargetDenoise,this.renderTargetDenoisePrev,this.renderTargetDenoiseCombined,this.transitionPass.active),this.copyPass.render(this.renderTargetDenoisePrev,this.renderTargetDenoiseCombined)):(en.setRenderTarget(this.renderTargetDenoiseCombined),en.render(this.lastPass.scene,this.lastPass.camera),en.setRenderTarget(null)),this.finalPass.render(this.lastPass,this.renderTargetDenoiseCombined,e))}}]),e}(),ze=U[X()],Be=ze.pixelRatio,We=ze.antialias,Ve=new v.Jb({antialias:We,powerPreference:"high-performance",stencil:!1,preserveDrawingBuffer:!0});Ve.setClearColor(0),Ve.outputEncoding=v.Kb,Ve.debug.checkShaderErrors=Y.isDevelopment;var qe=ne.addFolder("rendering");qe.open(),Ve.setPixelRatio(Be),Ve.setScissorTest(!0),z(Ve,window.innerWidth,window.innerHeight);var Ke=new He(qe),Je=Ve.getContext(),Ze=Je.getExtension("WEBGL_debug_renderer_info"),$e=Je.getParameter(Ze.UNMASKED_RENDERER_WEBGL);Y.isDevelopment&&console.log("Graphics: ".concat(X(),"\nGPU: ").concat($e,"\nTier: ").concat(O.tier));var en=Ve;var nn=new(Y.isDevelopment?function(){var e=document.createElement("div");e.style.cssText="width:80px;opacity:0.9;cursor:pointer;z-index:100000;top:48px;position:absolute;";var n=document.createElement("div");n.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:rgb(0, 0, 0);",e.appendChild(n);var a=document.createElement("div");a.style.cssText="color:rgb(255, 255, 255);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",a.innerHTML="WebGLRenderer",n.appendChild(a);for(var t=[],i=0;i<9;i++)t[i]=document.createElement("div"),t[i].style.cssText="color:rgb(255, 255, 255);background-color:rgb(0, 0, 0);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",n.appendChild(t[i]),t[i].innerHTML="-";var o=Date.now();return{domElement:e,update:function(e){console.assert(e instanceof v.Jb),Date.now()-o<1e3/30||(o=Date.now(),t[0].textContent="=== Memory ===",t[1].textContent="Programs: "+e.info.programs.length,t[2].textContent="Geometries: "+e.info.memory.geometries,t[3].textContent="Textures: "+e.info.memory.textures,t[4].textContent="=== Render ===",t[5].textContent="Calls: "+e.info.render.calls,t[6].textContent="Triangles: "+e.info.render.triangles,t[7].textContent="Lines: "+e.info.render.lines,t[8].textContent="Points: "+e.info.render.points)}}}:function(){return{domElement:document.createElement("div"),update:function(e){}}});(Y.stats&&(nn.domElement.style.position="absolute",nn.domElement.style.left="0px",nn.domElement.style.top="48px"),Y.stats)&&(a(47)().domElement.style.cssText="position:fixed;left:0;top:0;z-index:10000");var an=function(e){function n(){var e;return Object(l.a)(this,n),(e=Object(u.a)(this,Object(f.a)(n).call(this,{id:"preloader"}))).preloadGpuCullScene=function(n){e.spinner.material.uniforms.opacity.value=n?1:0},e.animateInit=function(){h.a.killTweensOf(e.spinner.material.uniforms.opacity),e.spinner.material.uniforms.opacity.value=0},e.update=function(n){e.spinner.rotation.z-=2*n},e.camera.position.set(0,0,10),e.camera.lookAt(y),e}return Object(c.a)(n,e),Object(d.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.spinner=new v.P(new v.mb(.9,1,32,1,0,.75*g),new v.ob({transparent:!0,uniforms:{opacity:{value:0}},vertexShader:"\n              varying vec2 vUv;\n              void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n              }\n            ",fragmentShader:"\n              uniform float opacity;\n              varying vec2 vUv;\n              void main() {\n                gl_FragColor = vec4(vUv, 1.0, vUv.y * opacity);\n              }\n          "})),n.spinner.name="spinner",n.scene.add(n.spinner),n.animateInit(),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){Y.skipTransitions?e():h.a.to(n.spinner.material.uniforms.opacity,1,{value:1,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){Y.skipTransitions?e():h.a.to(n.spinner.material.uniforms.opacity,1,{value:0,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(ge),tn=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(l.a)(this,e),this.ready=n.ready||!1}return Object(d.a)(e,[{key:"equals",value:function(e){return this.ready===e.ready}},{key:"clone",value:function(){return new e({ready:this.ready})}}]),e}(),on=a(16),rn=function(){function e(n,a,t){var i=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;Object(l.a)(this,e),this.save=function(){i.canvas.toBlob((function(e){Object(on.saveAs)(e,"screenshot.png")}),"image/png")},this.capture=function(e,n){i.ctx.clearRect(0,0,i.canvas.width,i.canvas.height);var a=n.aspect;n.aspect=i.width/i.height,n.updateProjectionMatrix();var t=Ke.finalPass.mesh.material.uniforms.resolution.value.x,o=Ke.finalPass.mesh.material.uniforms.resolution.value.y,r=G.x,s=G.y;en.setViewport(0,0,r,s),en.setScissor(0,0,r,s),e.resize(i.width,i.height),Ke.finalPass.resize(i.width,i.height),en.setRenderTarget(i.renderTargetA),en.render(e.scene,n),en.setRenderTarget(null),Ke.finalPass.screenshotRender(e.scene,n,i.renderTargetA,i.renderTargetB,0),en.readRenderTargetPixels(i.renderTargetB,0,0,i.renderTargetB.width,i.renderTargetB.height,i.pixelBuffer),i.imageData.data.set(i.pixelBuffer),i.ctxFlipped.putImageData(i.imageData,0,0),i.ctx.save(),i.ctx.scale(1,-1),i.ctx.drawImage(i.canvasFlipped,0,-i.canvas.height,i.canvas.width,i.canvas.height),i.ctx.restore(),n.aspect=a,n.updateProjectionMatrix(),Ke.finalPass.resize(t,o),e.resize(t,o),i.save()},this.gui=n.addFolder("screenshot"),this.gui.open(),this.width=a*o,this.height=t*o,this.renderTargetA=new v.Ib(this.width,this.height,{minFilter:v.E,magFilter:v.E,format:v.jb,stencilBuffer:!1}),this.renderTargetB=new v.Ib(this.width,this.height,{minFilter:v.E,magFilter:v.E,format:v.jb,stencilBuffer:!1});var r=ae(this.width,this.height),s=r.canvas,d=r.ctx,u=ae(this.width,this.height),f=u.canvas,c=u.ctx;this.canvas=s,this.canvasFlipped=f,this.ctx=d,this.ctxFlipped=c,this.pixelBuffer=new Uint8Array(this.renderTargetA.width*this.renderTargetA.height*4),this.imageData=this.ctxFlipped.createImageData(this.canvas.width,this.canvas.height)}return Object(d.a)(e,[{key:"capture2",value:function(e,n){en.domElement.toBlob((function(e){Object(on.saveAs)(e,"screenshot.png")}),"image/png")}}]),e}(),sn=function(e){function n(e){var a,t;Object(l.a)(this,n),(t=Object(u.a)(this,Object(f.a)(n).call(this))).captureScreenshot=function(){t.screenshot.capture2(t.currentScene,t.currentScene.camera)},t.setState=function(e){e.equals(t.state)||(t.prevState=t.state.clone(),t.state=e,t.onStateChanged(t.state))},t.onStateChanged=function(e){t.state.ready&&t.state.ready!==t.prevState.ready&&t.setScene(t.sceneId)},t.resize=function(e,n){z(en,e,n),t.currentScene.resize(G.x,G.y),Ke.resize(),t.viewport.debug.set(0,0,G.x*Y.viewportPreviewScale,G.y*Y.viewportPreviewScale),t.viewport.main.set(0,0,G.x,G.y)},t.renderScene=function(e,n,a,i){en.setViewport(n.x,n.y,n.z,n.w),en.setScissor(n.x,n.y,n.z,n.w),i?Ke.render(a):(t.currentScene.update(t.delta),en.setClearColor(t.currentScene.clearColor),en.render(t.currentScene.scene,e))},t.render=function(e){t.isRendering!==e&&(t.isRendering=e,e?t.update():cancelAnimationFrame(t.rafId))},t.update=function(){t.rafId=requestAnimationFrame(t.update),t.delta=t.clock.getDelta(),Y.devCamera?(t.renderScene(t.currentScene.cameras.dev,t.viewport.main,t.delta,!1),t.renderScene(t.currentScene.cameras.main,t.viewport.debug,t.delta,Y.postProcessing)):t.renderScene(t.currentScene.cameras.main,t.viewport.main,t.delta,Y.postProcessing),Y.stats&&nn.update(en)},e.appendChild(en.domElement),t.clock=new v.i(!0),t.rafId=0,t.delta=0,t.isRendering=!1,t.state=new tn({ready:!1}),t.scenes=(a={},Object(x.a)(a,"preloader",an),Object(x.a)(a,"main",Ge),a);var i=["main"];t.sceneId="main",i.includes(S("sceneId"))&&(t.sceneId=S("sceneId")),t.viewport={debug:new v.Fb(0,0,G.x*Y.viewportPreviewScale,G.y*Y.viewportPreviewScale),main:new v.Fb(0,0,G.x,G.y)},t.screenshot=new rn(ne,720,1280,2),t.screenshot.gui.add(Object(F.a)(t),"captureScreenshot").name("capture");var o=ne.addFolder("settings");return o.open(),o.add(Y,"postProcessing").onChange((function(e){I("postProcessing",e)})),o.add(Y,"renderBufferFullscreen").name("max resolution").onChange((function(e){I("hd",e),t.resize(window.innerWidth,window.innerHeight)})),t}return Object(c.a)(n,e),Object(d.a)(n,[{key:"setup",value:function(){var e=Object(p.a)(m.a.mark((function e(){var n=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.setScene("preloader").then(e).catch(a)}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setScene",value:function(){var e=Object(p.a)(m.a.mark((function e(n){var a=this;return m.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){if(!a.currentScene||n!==a.currentScene.id){var i=new a.scenes[n];i.setup().then((function(){var n=a.currentScene,o=function(){a.currentScene=i,a.currentScene.resize(G.x,G.y),a.currentScene.animateIn().then(e,t),Ke.setScenes(Ke.sceneB,i),Ke.transitionPass.transition().then((function(){n&&n.dispose()}))};n?n.animateOut().then(o).catch(t):o()})).catch(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}()}]),n}(P.a),ln=function(e){function n(){var e,a;Object(l.a)(this,n);for(var t=arguments.length,i=new Array(t),o=0;o<t;o++)i[o]=arguments[o];return(a=Object(u.a)(this,(e=Object(f.a)(n)).call.apply(e,[this].concat(i)))).state={ready:!1,windowSize:{width:window.innerWidth,height:window.innerHeight}},a.onReady=function(){a.setState({ready:!0})},a.onResize=function(){a.setState({windowSize:{width:window.innerWidth,height:window.innerHeight}})},a}return Object(c.a)(n,e),Object(d.a)(n,[{key:"componentDidMount",value:function(){var e=this;null!==this.container&&(this.webglApp=new sn(this.container),this.webglApp.setup().then((function(){e.webglApp.setState(new tn(e.state)),e.webglApp.render(!0),h.a.delayedCall(1,e.onReady)})).catch((function(e){console.log(e)})),window.addEventListener("resize",this.onResize))}},{key:"componentDidUpdate",value:function(e,n){null!==this.container&&(this.webglApp.setState(new tn(this.state)),this.state.windowSize.width===n.windowSize.width&&this.state.windowSize.height===n.windowSize.height||this.webglApp.resize(this.state.windowSize.width,this.state.windowSize.height))}},{key:"componentWillUnmount",value:function(){null!==this.container&&(this.webglApp.render(!1),window.removeEventListener("resize",this.onResize))}},{key:"render",value:function(){var e=this;return o.a.createElement("div",{className:"App",ref:function(n){e.container=n}},o.a.createElement("div",{className:"About"},o.a.createElement("p",null,"A simple"," ",o.a.createElement("a",{href:"https://github.com/ameliemaia/raytracing-in-one-weekend",target:"_blank",rel:"noopener noreferrer"},"Raytracer")," ","based on ",o.a.createElement("br",null),o.a.createElement("a",{href:"https://raytracing.github.io/",target:"_blank",rel:"noopener noreferrer"},"Ray Tracing in One Weekend")," ",o.a.createElement("br",null),"by"," ",o.a.createElement("a",{href:"https://twitter.com/Peter_shirley",target:"_blank",rel:"noopener noreferrer"},"Peter Shirley"))))}}]),n}(o.a.PureComponent),dn=document.getElementById("root");dn&&s.a.render(o.a.createElement(ln,null),dn)}},[[26,1,2]]]);
//# sourceMappingURL=main.46152b1b.chunk.js.map
{"version":3,"sources":["webgl-app/utils/math.js","webgl-app/utils/query-params.js","webgl-app/rendering/graphics.js","webgl-app/settings.js","webgl-app/rendering/resize.js","webgl-app/rendering/render-target.js","webgl-app/rendering/post-processing/passes/transition-pass/shader.glsl.js","webgl-app/cameras/cameras.js","webgl-app/utils/gui.js","webgl-app/utils/canvas.js","webgl-app/rendering/preload-gpu.js","webgl-app/loading/asset.js","webgl-app/loading/loaders/loader.js","webgl-app/loading/loaders/image-loader.js","webgl-app/loading/loaders/json-loader.js","webgl-app/loading/loaders/three-texture-loader.js","webgl-app/loading/loaders/three-fbx-loader.js","webgl-app/loading/loaders/three-gltf-loader.js","webgl-app/loading/loaders/group-loader.js","webgl-app/loading/asset-loader.js","webgl-app/loading/asset-manager.js","webgl-app/scenes/base/base-scene.js","webgl-app/utils/dispose-objects.js","webgl-app/rendering/post-processing/passes/transition-pass/transition-pass.js","webgl-app/rendering/post-processing/passes/fxaa.glsl.js","webgl-app/rendering/post-processing/passes/final-pass/shader.glsl.js","webgl-app/rendering/post-processing/passes/final-pass/final-pass.js","webgl-app/scenes/empty/empty-scene.js","webgl-app/rendering/post-processing/passes/copy-pass/copy-pass.js","webgl-app/rendering/post-processing/passes/denoise-pass/denoise-pass.js","webgl-app/rendering/post-processing/passes/denoise-pass/shader.glsl.js","webgl-app/scenes/main/objects/raytracer/camera.glsl.js","webgl-app/scenes/main/objects/raytracer/sphere.glsl.js","webgl-app/scenes/main/objects/raytracer/hitables.glsl.js","webgl-app/scenes/main/objects/raytracer/constants.js","webgl-app/scenes/main/objects/raytracer/material.glsl.js","webgl-app/scenes/main/objects/raytracer/world.glsl.js","webgl-app/scenes/main/objects/raytracer/raytracer.glsl.js","webgl-app/scenes/main/objects/raytracer/raytracer.js","webgl-app/scenes/main/main-scene.js","webgl-app/rendering/post-processing/post-processing.js","webgl-app/utils/geometry.js","webgl-app/rendering/renderer.js","webgl-app/utils/render-stats.js","webgl-app/utils/stats.js","webgl-app/scenes/preloader/preloader-scene.js","webgl-app/app-state.js","webgl-app/utils/screenshot.js","webgl-app/webgl-app.js","App.js","index.js"],"names":["TWO_PI","Math","PI","VECTOR_ZERO","Vector3","VECTOR_ONE","Math3","queryString","require","getQueryFromParams","prop","params","parse","window","location","search","undefined","setQuery","query","val","reload","queries","newQueries","Object","assign","stringified","stringify","href","pathname","url","protocol","host","history","pushState","path","GRAPHICS_MODES","GRAPHICS_MODE","getGraphicsMode","gpuTier","getGPUTier","graphicsMode","includes","tier","profiler","antialias","pixelRatio","math","clamp","devicePixelRatio","maxFrameBufferSize","Vector2","settings","process","renderBufferFullscreen","postProcessing","graphics","baseSize","sqrt","x","y","maxSize","rendererSize","getRenderBufferSize","width","height","setRendererSize","renderer","windowWidth","windowHeight","ratio","newSize","floor","scalar","resize","setSize","domElement","style","createRenderTarget","options","defaults","minFilter","LinearFilter","magFilter","NearestFilter","format","RGBFormat","type","UnsignedByteType","stencilBuffer","WebGLRenderTarget","resetCamera","camera","zoom","angle","position","set","z","lookAt","createPerspectiveCamera","aspect","PerspectiveCamera","createOrbitControls","OrbitControls","Folder","object","key","list","this","value","id","GUIWrapper","Cls","datGui","GUI","prototype","removeFolder","name","folder","__folders","close","__ul","removeChild","parentNode","onResize","gui","createCanvas","canvas","document","createElement","ctx","getContext","detect","device","isDesktop","renderTarget","depthBuffer","RGBAFormat","setAllCulled","obj","overrideCulled","wasFrustumCulled","frustumCulled","wasVisible","visible","children","forEach","child","preloadGpu","scene","cameraAspect","updateProjectionMatrix","setRenderTarget","render","Asset","config","Loader","EventEmitter","json","image","threeFBX","threeGLTF","threeTexture","ImageLoader","asset","load","Image","onload","data","emit","onerror","src","JsonLoader","req","XMLHttpRequest","onreadystatechange","readyState","status","JSON","responseText","open","send","ThreeTextureLoader","TextureLoader","texture","ThreeFBXLoader","FBXLoader","dracoLoader","DRACOLoader","setDecoderPath","baseUrl","preload","ThreeGLTFLoader","loader","GLTFLoader","setDRACOLoader","gltf","LOADERS","GroupLoader","manifest","loaders","push","loaded","queue","currentParallel","total","length","loadNextInQueue","parallelLoads","once","onLoaded","onError","assets","error","minParallel","maxParallel","args","on","response","group","groupId","all","find","BaseScene","preloadGpuCullScene","culled","toggleHelpers","helpers","toogleCameras","devCamera","cameras","dev","main","control","controls","update","delta","dispose","disposeObjects","parent","remove","geometry","material","i","l","generateUUID","clearColor","lights","Scene","addFolder","guiOpen","light","add","Promise","resolve","reject","assetLoader","assetManager","Group","GridHelper","AxesHelper","loadAssets","createSceneHelpers","createSceneObjects","animate","TweenLite","TransitionPass","mesh","uniforms","resolution","sceneA","sceneB","renderTargetA","renderTargetB","setClearColor","texture0","texture1","active","ShaderMaterial","transition","vertexShader","fragmentShader","Mesh","matrixAutoUpdate","updateMatrix","onChange","listen","skipTransitions","killTweensOf","to","then","fxaaEnabled","fxaaResolution","FinalPass","UniformsUtils","merge","time","tDiffuse","fxaaUniforms","guiPass","fxaaGuiControls","EmptyScene","CopyPass","renderTargetCopy","toScreen","DenoisePass","reset","passes","tDiffusePrev","frameCount","maxPasses","renderTargetCurrent","renderTargetPrev","renderTargetCombined","maxBounces","fov","seed","Vector4","random","cameraAperture","cameraPosition","cameraTarget","sphere0Position","sphere1Position","sphere2Position","refractionIndex","sphere","hitables","world","Raytracer","createMaterial","rebuild","denoisePass","PlaneBufferGeometry","index","guiFolder","copy","target","MainScene","raytracer","addEventListener","PostProcessing","BufferGeometry","attribute","BufferAttribute","Float32Array","setAttribute","setIndex","bigTriangle","OrthographicCamera","renderTargetTransitionA","renderTargetTransitionB","renderTargetDenoise","renderTargetDenoisePrev","renderTargetDenoiseCombined","transitionPass","finalPass","copyPass","setup","setScenes","pauseRendering","currentScene","lastPass","WebGLRenderer","powerPreference","stencil","preserveDrawingBuffer","outputEncoding","sRGBEncoding","debug","checkShaderErrors","isDevelopment","guiRendering","setPixelRatio","setScissorTest","innerWidth","innerHeight","gl","gpuInfo","getExtension","gpu","getParameter","UNMASKED_RENDERER_WEBGL","console","log","rendererStats","container","cssText","msDiv","appendChild","msText","innerHTML","msTexts","lastTime","Date","now","webglRenderer","assert","textContent","info","programs","memory","geometries","textures","calls","triangles","lines","points","stats","left","top","PreloaderScene","spinner","opacity","animateInit","rotation","RingBufferGeometry","transparent","onComplete","AppState","props","ready","state","Screenshot","save","toBlob","blob","saveAs","capture","clearRect","finalPassWidth","finalPassHeight","setViewport","setScissor","screenshotRender","readRenderTargetPixels","pixelBuffer","imageData","ctxFlipped","putImageData","scale","drawImage","canvasFlipped","restore","Uint8Array","createImageData","WebGLApp","captureScreenshot","screenshot","capture2","setState","equals","prevState","clone","onStateChanged","setScene","sceneId","viewport","viewportPreviewScale","renderScene","usePostProcessing","w","isRendering","cancelAnimationFrame","rafId","requestAnimationFrame","clock","getDelta","Clock","scenes","sceneIds","guiSettings","catch","previousScene","nextScene","animateIn","animateOut","App","windowSize","onReady","webglApp","delayedCall","prevProps","removeEventListener","className","ref","node","rel","React","PureComponent","root","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.ed91e193.chunk.js","sourcesContent":["import { Math as Math3, Vector3 } from 'three';\n\n// Math constants that are regularly used\nexport const TWO_PI = Math.PI * 2;\nexport const PI = Math.PI;\nexport const HALF_PI = Math.PI / 2;\nexport const QUARTER_PI = Math.PI / 4;\nexport const VECTOR_ZERO = new Vector3();\nexport const VECTOR_ONE = new Vector3(1, 1, 1);\nexport const VECTOR_UP = new Vector3(0, 1, 0);\n\nexport default Math3;\n","const queryString = require('query-string');\n\n/**\n * Get a query parameter\n *\n * @export\n * @param {String} prop\n * @returns\n */\nexport function getQueryFromParams(prop: string): mixed {\n  const params = queryString.parse(window.location.search);\n  return params[prop] !== undefined ? params[prop] : false;\n}\n\n/**\n * Set a query parmeter\n *\n * @export\n * @param {String} query\n * @param {String} val\n * @param {boolean} [reload=false]\n * @returns\n */\nexport function setQuery(query: string, val: string, reload: boolean = false) {\n  const queries = queryString.parse(window.location.search);\n  const newQueries = Object.assign({}, queries, {\n    [query]: val\n  });\n  const stringified = queryString.stringify(newQueries);\n\n  if (reload) {\n    window.location.href = `${window.location.pathname}?${stringified}`;\n    return;\n  }\n  const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?${stringified}`;\n  window.history.pushState({ path: url }, '', url);\n}\n","import { getGPUTier } from 'detect-gpu';\nimport { Vector2 } from 'three';\nimport math from '../utils/math';\nimport { getQueryFromParams } from '../utils/query-params';\n\n// Graphics mode constants\nexport const GRAPHICS_HIGH = 'high';\nexport const GRAPHICS_NORMAL = 'normal';\nexport const GRAPHICS_MODES = [GRAPHICS_HIGH, GRAPHICS_NORMAL];\n\nlet GRAPHICS_MODE = GRAPHICS_NORMAL;\n\n/**\n * Get the current graphics mode\n *\n * @export\n * @returns\n */\nexport function getGraphicsMode(): string {\n  return GRAPHICS_MODE;\n}\n\nconst gpuTier = getGPUTier();\n\nexport function profiler(): string {\n  switch (gpuTier.tier) {\n    case 'GPU_DESKTOP_TIER_3':\n    case 'GPU_DESKTOP_TIER_2':\n    case 'GPU_MOBILE_TIER_3':\n      return GRAPHICS_HIGH;\n    case 'GPU_DESKTOP_TIER_1':\n    default:\n      return GRAPHICS_NORMAL;\n  }\n}\n\n// If the graphics query parameter is set, use it over the current gpu tier\nconst graphicsMode = getQueryFromParams('graphics');\nif (GRAPHICS_MODES.includes(graphicsMode) && typeof graphicsMode === 'string') {\n  GRAPHICS_MODE = graphicsMode;\n} else {\n  GRAPHICS_MODE = profiler();\n}\n\nexport function getTier(): string {\n  return gpuTier.tier;\n}\n\n// Graphics settings for the renderer\nexport default {\n  [GRAPHICS_HIGH]: {\n    antialias: false, // Enable antialias if you're not using post processing\n    pixelRatio: math.clamp(window.devicePixelRatio, 1, 2),\n    maxFrameBufferSize: new Vector2(1920, 1080)\n  },\n  [GRAPHICS_NORMAL]: {\n    antialias: false,\n    pixelRatio: 1,\n    maxFrameBufferSize: new Vector2(1280, 720)\n  }\n};\n","import { getQueryFromParams } from './utils/query-params';\n\nconst settings = {};\n\n// Enviroment setting\nsettings.isDevelopment = process.env.NODE_ENV !== 'production';\n\n// Base url\nsettings.baseUrl = process.env.PUBLIC_URL || '';\n\n// Show fps stats\nsettings.stats = true; //getQueryFromParams('stats') === null;\n\n// Enable dev camera rendering\nsettings.devCamera = false; //getQueryFromParams('devCamera') === 'true';\n\n// Enable helpers\nsettings.helpers = false; //getQueryFromParams('helpers') === 'true';\n\n// Enable dat gui\nsettings.datGui = true; //getQueryFromParams('gui') === null;\n\n// Skips all transitions\nsettings.skipTransitions = false; //getQueryFromParams('skipTransitions') === null;\n\n// GUI Number precision\nsettings.guiPrecision = 0.001;\n\n// Viewport preview scale (when using devCamera)\nsettings.viewportPreviewScale = 0.25;\n\n// Unlock full render size (should be false for prod)\nsettings.renderBufferFullscreen = getQueryFromParams('hd') === 'true' || false;\n\nsettings.postProcessing = true;\n\nexport default settings;\n","import { Vector2, WebGLRenderer } from 'three';\nimport graphics, { getGraphicsMode } from './graphics';\nimport settings from '../settings';\n\nconst { maxFrameBufferSize, pixelRatio } = graphics[getGraphicsMode()];\n\nconst baseSize = Math.sqrt(maxFrameBufferSize.x * maxFrameBufferSize.y);\nconst maxSize = baseSize * baseSize;\n\nexport const rendererSize = new Vector2();\n\nexport function getRenderBufferSize(): { width: number, height: number } {\n  return {\n    width: rendererSize.x * pixelRatio,\n    height: rendererSize.y * pixelRatio\n  };\n}\n\nfunction resize(windowWidth: number, windowHeight: number): { width: number, height: number } {\n  let width = windowWidth;\n  let height = windowHeight;\n  if (windowWidth * windowHeight > maxSize) {\n    const ratio = height / width;\n    width = baseSize;\n    height = Math.floor(baseSize * ratio);\n    let newSize = width * height;\n    const scalar = Math.sqrt(maxSize / newSize);\n    width = Math.floor(width * scalar);\n    height = Math.floor(height * scalar);\n  }\n  return {\n    width,\n    height\n  };\n}\n\nconst screenshot = false;\nconst isPortrait = false;\n\nexport function setRendererSize(renderer: WebGLRenderer, windowWidth: number, windowHeight: number) {\n  let { width, height } = resize(windowWidth, windowHeight);\n  if (settings.renderBufferFullscreen) {\n    width = windowWidth;\n    height = windowHeight;\n  }\n\n  if (screenshot) {\n    width = maxFrameBufferSize.x;\n    height = maxFrameBufferSize.y;\n  }\n\n  rendererSize.x = isPortrait ? height : width;\n  rendererSize.y = isPortrait ? width : height;\n  renderer.setSize(rendererSize.x, rendererSize.y);\n\n  if (!screenshot) {\n    renderer.domElement.style.width = `${windowWidth}px`;\n    renderer.domElement.style.height = `${windowHeight}px`;\n  }\n}\n","import { WebGLRenderTarget, LinearFilter, NearestFilter, RGBFormat, UnsignedByteType } from 'three';\n\nexport function createRenderTarget(width: number = 1024, height: number = 1024, options: Object = {}) {\n  const defaults = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBFormat,\n    type: UnsignedByteType,\n    stencilBuffer: false\n  };\n  return new WebGLRenderTarget(width, height, Object.assign({}, defaults, options));\n}\n","export const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform sampler2D texture0;\n  uniform sampler2D texture1;\n  uniform float transition;\n  uniform vec2 resolution;\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(texture0, uv);\n    vec4 texel1 = texture2D(texture1, uv);\n    gl_FragColor = mix(texel0, texel1, transition);\n  }\n`;\n","import { PerspectiveCamera, Vector3 } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport renderer from '../rendering/renderer';\nimport { VECTOR_ZERO, VECTOR_ONE } from '../utils/math';\n\n// Perspective camera defaults\nexport const FOV = 65;\nconst near = 0.1;\nconst far = 1000;\n\n/**\n * Reset the camera position\n *\n * @export\n * @param {PerspectiveCamera} camera\n * @param {number} [zoom=1]\n * @param {Vector3} [angle=VECTOR_ONE]\n */\nexport function resetCamera(camera: PerspectiveCamera, zoom: number = 1, angle: Vector3 = VECTOR_ONE) {\n  camera.position.set(angle.x * zoom, angle.y * zoom, angle.z * zoom);\n  camera.lookAt(VECTOR_ZERO);\n}\n\n/**\n * Utility for creating a perspective camera\n *\n * @export\n * @returns\n */\nexport function createPerspectiveCamera(aspect: number): PerspectiveCamera {\n  return new PerspectiveCamera(FOV, aspect, near, far);\n}\n\n/**\n * Utility for creating orbit controls\n *\n * @export\n * @param {PerspectiveCamera} camera\n * @returns\n */\nexport function createOrbitControls(camera: PerspectiveCamera): OrbitControls {\n  return new OrbitControls(camera, renderer.domElement);\n}\n","import detect from '@jam3/detect';\nimport settings from '../settings';\n\n/**\n * @class Folder\n */\nclass Folder {\n  add(object: any, key: string, list?: mixed[]) {\n    return this;\n  }\n  listen() {\n    return this;\n  }\n  name() {\n    return this;\n  }\n  open() {\n    return this;\n  }\n  close() {\n    return this;\n  }\n  onChange(value: mixed) {\n    return this;\n  }\n  addFolder(id: string) {\n    return this;\n  }\n  addColor() {\n    return this;\n  }\n  removeFolder(id: string) {\n    return this;\n  }\n  remove() {\n    return this;\n  }\n  step() {\n    return this;\n  }\n}\n\n/**\n * @class GUIWrapper\n */\nclass GUIWrapper {\n  static toggleHide() {\n    return this;\n  }\n  add(object: any, key: string, list?: mixed[]) {\n    return this;\n  }\n  addFolder(id: string) {\n    return new Folder();\n  }\n  removeFolder(id: string) {\n    return this;\n  }\n  addColor() {\n    return this;\n  }\n  listen() {\n    return this;\n  }\n  name() {\n    return this;\n  }\n  close() {\n    return this;\n  }\n  step() {\n    return this;\n  }\n  onChange(value: mixed) {\n    return this;\n  }\n  setValue() {\n    return this;\n  }\n  remove() {\n    return this;\n  }\n  open() {\n    return this;\n  }\n}\n\nlet Cls = GUIWrapper;\n\nif (settings.datGui) {\n  Cls = require('dat.gui').GUI;\n\n  Cls.prototype.removeFolder = function(name) {\n    var folder = this.__folders[name];\n    if (!folder) {\n      return;\n    }\n    folder.close();\n    this.__ul.removeChild(folder.domElement.parentNode);\n    delete this.__folders[name];\n    this.onResize();\n  };\n}\n\nexport const gui = new Cls();\nexport { GUIWrapper };\n\nif (!detect.device.isDesktop) {\n  // Cls.toggleHide();\n  gui.close();\n}\n","/**\n * Create a canvas and 2d context\n *\n * @export\n * @param {Number} width\n * @param {Number} height\n * @returns\n */\nexport default function createCanvas(width: number, height: number) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  return {\n    ctx,\n    canvas\n  };\n}\n","import { Scene, PerspectiveCamera, RGBAFormat, Object3D } from 'three';\nimport renderer from './renderer';\nimport { createRenderTarget } from './render-target';\nimport RenderTargetHelper from '../utils/render-target-helper';\n\nconst RENDER_TARGET_SIZE = 128;\nconst RENDER_TARGET_DEBUG = false;\n\nconst renderTarget = createRenderTarget(RENDER_TARGET_SIZE, RENDER_TARGET_SIZE, {\n  depthBuffer: false,\n  format: RGBAFormat\n});\n\nlet renderTargetHelper;\nif (RENDER_TARGET_DEBUG) {\n  renderTargetHelper = new RenderTargetHelper(renderTarget);\n}\n\n// https://medium.com/@hellomondaycom/how-we-built-the-google-cloud-infrastructure-webgl-experience-dec3ce7cd209\nfunction setAllCulled(obj: Object3D, overrideCulled: boolean) {\n  if (overrideCulled === false) {\n    obj.wasFrustumCulled = obj.frustumCulled;\n    obj.wasVisible = obj.visible;\n    obj.visible = true;\n    obj.frustumCulled = false;\n  } else {\n    obj.visible = obj.wasVisible;\n    obj.frustumCulled = obj.wasFrustumCulled;\n  }\n  obj.children.forEach(child => setAllCulled(child, overrideCulled));\n}\n\nexport default function preloadGpu(scene: Scene, camera: PerspectiveCamera) {\n  const cameraAspect = camera.aspect;\n  camera.aspect = 1;\n  camera.updateProjectionMatrix();\n  setAllCulled(scene, false);\n  renderer.setRenderTarget(renderTarget);\n  renderer.render(scene, camera);\n  if (RENDER_TARGET_DEBUG) renderTargetHelper.update();\n  renderer.setRenderTarget(null);\n  camera.aspect = cameraAspect;\n  camera.updateProjectionMatrix();\n  setAllCulled(scene, true);\n}\n","/**\n *\n *\n * @interface AssetConfig\n */\nexport interface AssetConfig {\n  id: string;\n  src: string;\n  type: string;\n  args?: Object;\n  data?: mixed;\n}\n\n/**\n *\n *\n * @export\n * @class Asset\n */\nexport default class Asset {\n  id: string;\n  src: string;\n  type: string;\n  args: Object;\n  data: mixed;\n  constructor(config: AssetConfig) {\n    Object.assign(this, config);\n  }\n}\n","import EventEmitter from 'eventemitter3';\nimport Asset from '../asset';\n\n/**\n * Base loader\n *\n * @class Loader\n * @extends {EventEmitter}\n */\nclass Loader extends EventEmitter {\n  asset: Asset;\n  static json: string = 'json';\n  static image: string = 'image';\n  static threeFBX: string = 'fbx';\n  static threeGLTF: string = 'gltf';\n  static threeTexture: string = 'texture';\n}\n\nexport default Loader;\n","import Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Image Loader\n *\n * @export\n * @class ImageLoader\n * @extends {Loader}\n */\nexport default class ImageLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const image = new Image();\n\n    image.onload = () => {\n      this.asset.data = image;\n      this.emit('loaded', this.asset);\n    };\n\n    image.onerror = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    image.src = this.asset.src;\n  };\n}\n","import Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Json loader\n *\n * @export\n * @class JsonLoader\n * @extends {Loader}\n */\nexport default class JsonLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const req = new XMLHttpRequest();\n\n    req.onreadystatechange = () => {\n      if (req.readyState !== 4) return;\n      if (req.readyState === 4 && req.status === 200) {\n        this.asset.data = JSON.parse(req.responseText);\n        this.emit('loaded', this.asset);\n      } else {\n        this.emit('error', `Failed to load ${this.asset.src}`);\n      }\n    };\n\n    req.open('GET', this.asset.src, true);\n    req.send();\n  };\n}\n","import { TextureLoader, Texture } from 'three';\nimport Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Threejs texture loader\n *\n * @export\n * @class ThreeTextureLoader\n * @extends {Loader}\n */\nexport default class ThreeTextureLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new TextureLoader();\n\n    const onLoaded = (texture: Texture) => {\n      this.asset.data = texture;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';\nimport Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Threejs FBX Loader\n *\n * @export\n * @class ThreeFBXLoader\n * @extends {Loader}\n */\nexport default class ThreeFBXLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new FBXLoader();\n\n    const onLoaded = (data: Object) => {\n      this.asset.data = data;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';\nimport Loader from './loader';\nimport Asset from '../asset';\nimport settings from '../../settings';\n\n// Use the draco loader for gltf if the glb file is compressed with draco\nconst dracoLoader = new DRACOLoader();\ndracoLoader.setDecoderPath(`${settings.baseUrl}/assets/lib/draco/gltf/`);\ndracoLoader.preload();\n\n/**\n * Threejs GLTF Loader\n *\n * @export\n * @class ThreeGLTFLoader\n * @extends {Loader}\n */\nexport default class ThreeGLTFLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new GLTFLoader();\n    loader.setDRACOLoader(dracoLoader);\n\n    const onLoaded = (gltf: Object) => {\n      this.asset.data = gltf;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import EventEmitter from 'eventemitter3';\nimport detect from '@jam3/detect';\nimport Asset from '../asset';\nimport Loader from './loader';\nimport ImageLoader from './image-loader';\nimport JsonLoader from './json-loader';\nimport ThreeTextureLoader from './three-texture-loader';\nimport ThreeFBXLoader from './three-fbx-loader';\nimport ThreeGLTFLoader from './three-gltf-loader';\n\nconst LOADERS = {\n  [Loader.image]: ImageLoader,\n  [Loader.json]: JsonLoader,\n  [Loader.threeTexture]: ThreeTextureLoader,\n  [Loader.threeFBX]: ThreeFBXLoader,\n  [Loader.threeGLTF]: ThreeGLTFLoader\n};\n\n/**\n * Group loader loads an array of assets based on their asset types\n *\n * @export\n * @class GroupLoader\n * @extends {EventEmitter}\n */\nexport default class GroupLoader extends EventEmitter {\n  constructor(options: Object = {}) {\n    super();\n    this.id = options.id || '';\n    this.minParallel = options.minParallel || 5;\n    this.maxParallel = options.maxParallel || 10;\n    // How many parallel loads at once\n    this.parallelLoads = detect.device.isDesktop ? this.maxParallel : this.minParallel;\n  }\n\n  load = (manifest: Asset[]) => {\n    this.loaders = [];\n\n    manifest.forEach(asset => {\n      if (LOADERS[asset.type] !== undefined) {\n        this.loaders.push(new LOADERS[asset.type](asset));\n      }\n    });\n\n    this.loaded = 0;\n    this.queue = 0;\n    this.currentParallel = 0;\n    this.total = this.loaders.length;\n\n    if (this.total === 0) {\n      this.emit('loaded', manifest);\n    } else {\n      this.loadNextInQueue();\n    }\n  };\n\n  /**\n   * Load the next in queue\n   *\n   * @memberof GroupLoader\n   */\n  loadNextInQueue = () => {\n    if (this.queue < this.total) {\n      if (this.currentParallel < this.parallelLoads) {\n        const loader = this.loaders[this.queue];\n        this.queue += 1;\n        this.currentParallel += 1;\n        loader.once('loaded', this.onLoaded);\n        loader.once('error', this.onError);\n        loader.load();\n        this.loadNextInQueue();\n      }\n    }\n  };\n\n  /**\n   * Loaded handler\n   *\n   * @memberof GroupLoader\n   */\n  onLoaded = () => {\n    this.loaded += 1;\n    // console.log(`${this.id} loaded`, this.loaded, '/', this.total);\n    this.emit('progress', this.loaded / this.total);\n    if (this.loaded === this.total) {\n      const assets = [];\n      this.loaders.forEach((loader: Loader) => {\n        assets.push(loader.asset);\n      });\n      this.emit('loaded', assets);\n    } else {\n      this.currentParallel -= 1;\n      this.loadNextInQueue();\n    }\n  };\n\n  /**\n   * Error handler\n   *\n   * @memberof GroupLoader\n   */\n  onError = (error: string) => {\n    this.emit('error', error);\n  };\n}\n","import EventEmitter from 'eventemitter3';\nimport Asset from './asset';\nimport GroupLoader from './loaders/group-loader';\n\n/**\n * Assetloader configures an instance of GroupLoader\n * and should be used for loading any asset groups for the asset manager\n *\n * @class AssetLoader\n * @extends {EventEmitter}\n */\nclass AssetLoader extends EventEmitter {\n  load = (id: string, assets: Asset[]) => {\n    const loader = new GroupLoader({ id });\n    assets.forEach(asset => {\n      if (asset.args === undefined) asset.args = {};\n    });\n\n    loader.on('progress', response => {\n      this.emit('progress', response);\n    });\n\n    loader.once('loaded', response => {\n      this.emit('loaded', response);\n    });\n\n    loader.once('error', error => {\n      this.emit('error', error);\n    });\n\n    loader.load(assets);\n  };\n}\n\nexport default new AssetLoader();\n","import Asset from './asset';\n\n/**\n * Asset manager's purpose is to store loaded assets by the AssetLoader\n * Assets can be retrived by using the get() function\n *\n * @class AssetManager\n */\nclass AssetManager {\n  assets: Object;\n\n  constructor() {\n    this.assets = {};\n  }\n\n  /**\n   * Add an asset group\n   *\n   * @param {String} group\n   * @param {Asset[]} assets\n   * @memberof AssetManager\n   */\n  add(group: String, assets: Asset[]) {\n    this.assets[group] = this.assets[group] || [];\n    this.assets[group].push(...assets);\n  }\n\n  /**\n   * Retrieve an asset by id\n   *\n   * @param {String} groupId\n   * @param {String} id\n   * @param {Boolean} [all=false]\n   * @returns\n   * @memberof AssetManager\n   */\n  get(groupId: string, id: string, all: boolean = false): boolean | mixed {\n    // console.log('groupId', groupId, 'id', id);\n    const asset = this.find(this.assets[groupId], id);\n    if (asset && asset instanceof Asset) {\n      return all ? asset : asset.data;\n    }\n    return false;\n  }\n\n  /**\n   * Find an asset by id\n   *\n   * @param {Asset[]} assets\n   * @param {String} id\n   * @returns\n   * @memberof AssetManager\n   */\n  find(assets: Asset[], id: string): boolean | Asset {\n    return assets.find(asset => asset.id === id) || false;\n  }\n}\n\nexport default new AssetManager();\n","// @flow\n\nimport EventEmitter from 'eventemitter3';\nimport { Scene, Group, GridHelper, AxesHelper } from 'three';\nimport { createPerspectiveCamera, createOrbitControls, resetCamera } from '../../cameras/cameras';\nimport { gui, GUIWrapper } from '../../utils/gui';\nimport Math3 from '../../utils/math';\nimport settings from '../../settings';\nimport { rendererSize } from '../../rendering/resize';\nimport preloadGpu from '../../rendering/preload-gpu';\nimport assetLoader from '../../loading/asset-loader';\nimport assetManager from '../../loading/asset-manager';\nimport Asset from '../../loading/asset';\nimport disposeObjects from '../../utils/dispose-objects';\n\n/**\n * A base scene for other scenes to inherit\n * It's main purpose is to abtract a lot of boilerplate code and serves\n * as a pattern for working with multiple scenes in a project\n *\n * @export\n * @class BaseScene\n * @extends {EventEmitter}\n */\nexport default class BaseScene extends EventEmitter {\n  constructor(options: Object) {\n    super();\n    // Unique scene id\n    this.id = options.id || Math3.generateUUID();\n    // Clear color for the scene\n    this.clearColor = options.clearColor || 0x000000;\n    // Array of lights to add to the scene\n    this.lights = options.lights || [];\n    // Assets manifest\n    this.assets = options.assets || [];\n    // The scene for objects\n    this.scene = new Scene();\n\n    // The cameras for rendering\n    this.cameras = {\n      dev: createPerspectiveCamera(rendererSize.x / rendererSize.y),\n      main: createPerspectiveCamera(rendererSize.x / rendererSize.y)\n    };\n\n    // Active rendering camera\n    this.camera = settings.devCamera ? this.cameras.dev : this.cameras.main;\n\n    // Set the initial camera positions\n    resetCamera(this.cameras.dev, 5);\n    resetCamera(this.cameras.main, 5);\n\n    // Orbit controls\n    this.controls = {};\n\n    // Optionally create orbit controls for main camera\n    if (options.controls) {\n      this.controls.dev = createOrbitControls(this.cameras.dev);\n      this.controls.main = createOrbitControls(this.cameras.main);\n    }\n\n    // Active camera control\n    this.control = settings.devCamera ? this.controls.dev : this.controls.main;\n\n    // Optionally create gui controls\n    if (options.gui) {\n      this.gui = gui.addFolder(`${this.id} scene`);\n      if (options.guiOpen) this.gui.open();\n    } else {\n      this.gui = new GUIWrapper();\n    }\n\n    // Add any lights to the scene\n    this.lights.forEach(light => {\n      this.scene.add(light.light);\n      light.gui(this.gui);\n    });\n  }\n\n  /**\n   *\n   *\n   * @memberof BaseScene\n   */\n  async loadAssets() {\n    await new Promise((resolve, reject) => {\n      try {\n        if (this.assets.length > 0) {\n          assetLoader.once('loaded', (response: Asset[]) => {\n            if (response.length > 0) assetManager.add(this.id, response);\n            resolve();\n          });\n          assetLoader.once('error', error => {\n            reject(error);\n          });\n          assetLoader.load(this.id, this.assets);\n        } else {\n          resolve();\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to setup any helpers for the scene\n   *\n   * @memberof BaseScene\n   */\n  async createSceneHelpers() {\n    await new Promise((resolve: Function, reject: Function) => {\n      try {\n        // Add helpers\n        this.helpers = new Group();\n        this.helpers.add(new GridHelper(10, 10), new AxesHelper());\n        this.helpers.visible = settings.helpers;\n        this.scene.add(this.helpers);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to setup any 3d objects once overridden\n   *\n   * @memberof BaseScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to show any materials or objects that can't be seen\n   * using the visible flag inside preloadGpu\n   * An example of this could be a materials alpha is set to 0\n   *\n   * @memberof BaseScene\n   */\n  preloadGpuCullScene = (culled: boolean) => {};\n\n  /**\n   * Setup is used to create any 3D objects\n   * and pre-upload them to the GPU to ensure smooth transitions when rendering\n   *\n   * @memberof BaseScene\n   */\n  async setup() {\n    await this.loadAssets();\n    await this.createSceneHelpers();\n    await this.createSceneObjects();\n    this.preloadGpuCullScene(true);\n    preloadGpu(this.scene, this.camera);\n    this.preloadGpuCullScene(false);\n  }\n\n  /**\n   * Toggle helpers on and off\n   *\n   * @memberof BaseScene\n   */\n  toggleHelpers = (visible: boolean = true) => {\n    this.helpers.visible = visible;\n  };\n\n  /**\n   * Toggle helpers on and off\n   *\n   * @memberof BaseScene\n   */\n  toogleCameras = (devCamera: boolean = true) => {\n    this.camera = devCamera ? this.cameras.dev : this.cameras.main;\n    this.control = devCamera ? this.controls.dev : this.controls.main;\n  };\n\n  /**\n   * Resize the camera's projection matrix\n   *\n   * @memberof BaseScene\n   */\n  resize = (width: number, height: number) => {\n    this.cameras.dev.aspect = width / height;\n    this.cameras.dev.updateProjectionMatrix();\n    this.cameras.main.aspect = width / height;\n    this.cameras.main.updateProjectionMatrix();\n  };\n\n  /**\n   * Provide a promise after the scene has animated in\n   *\n   * @memberof BaseScene\n   */\n  async animateIn() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Provide a promise after the scene has animated out\n   *\n   * @memberof BaseScene\n   */\n  async animateOut() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Update loop for animation, override this function\n   *\n   * @memberof BaseScene\n   */\n  update = (delta: number) => {};\n\n  /**\n   * Clear up scene objects\n   *\n   * @memberof BaseScene\n   */\n  dispose = () => {\n    disposeObjects(this.scene, null);\n    if (this.gui) gui.removeFolder(this.gui.name);\n  };\n}\n","import { Object3D, Scene } from 'three';\n\n/**\n * Recursively dispose threejs objects\n *\n * @export\n * @param {Object3D} object\n * @param {(Scene | Object3D)} parent\n * @returns\n */\nexport default function disposeObjects(object: Scene | Object3D, parent: Scene | Object3D) {\n  if (object === null || object === undefined) return;\n  if (parent) parent.remove(object);\n  if (object.dispose) {\n    object.dispose();\n  }\n  if (object.geometry) {\n    object.geometry.dispose();\n  }\n  if (object.material) {\n    object.material.dispose();\n  }\n  if (object.children) {\n    let i = 0;\n    const l = object.children.length;\n    while (i < l) {\n      disposeObjects(object.children[0], object);\n      i++;\n    }\n  }\n  if (object.type === 'Scene') object.dispose();\n  object = null;\n}\n","import { Scene, Mesh, ShaderMaterial, Vector2, BufferGeometry, OrthographicCamera, WebGLRenderTarget } from 'three';\nimport { TweenLite } from 'gsap';\nimport { GUI } from 'dat.gui';\nimport { vertexShader, fragmentShader } from './shader.glsl';\nimport { getRenderBufferSize } from '../../../resize';\nimport renderer from '../../../renderer';\nimport BaseScene from '../../../../scenes/base/base-scene';\nimport settings from '../../../../settings';\nimport EventEmitter from 'eventemitter3';\nconst animate = require('gsap-promisify')(Promise, TweenLite);\n\n/**\n * Transition pass handles transitioning between two scenes\n *\n * @export\n * @class TransitionPass\n */\nexport default class TransitionPass extends EventEmitter {\n  gui: GUI;\n  scene: Scene;\n  camera: OrthographicCamera;\n  active: boolean;\n  mesh: Mesh;\n\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    super();\n    // Create gui\n    this.gui = gui.addFolder('transition pass');\n    this.gui.close();\n    // Create scene\n    this.scene = new Scene();\n    this.camera = camera;\n    this.active = false;\n    const { width, height } = getRenderBufferSize();\n    // Setup shader\n    const material = new ShaderMaterial({\n      uniforms: {\n        texture0: {\n          value: null\n        },\n        texture1: {\n          value: null\n        },\n        transition: {\n          value: 0\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader,\n      fragmentShader\n    });\n\n    // Create the mesh and turn off matrixAutoUpdate\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n\n    // Setup gui\n    this.gui\n      .add(this.mesh.material.uniforms.transition, 'value', 0, 1)\n      .onChange((value: number) => {\n        this.active = value !== 0 && value !== 1;\n      })\n      .name('transition')\n      .listen();\n  }\n\n  /**\n   * Transition activates this pass and blends from sceneA to sceneB\n   *\n   * @memberof TransitionPass\n   */\n  async transition() {\n    if (settings.skipTransitions) {\n      this.mesh.material.uniforms.transition.value = 1;\n    } else {\n      this.mesh.material.uniforms.transition.value = 0;\n      this.active = true;\n      TweenLite.killTweensOf(this.mesh.material.uniforms.transition);\n      await animate\n        .to(this.mesh.material.uniforms.transition, 1, {\n          value: 1\n        })\n        .then(() => {\n          this.active = false;\n          this.emit('complete');\n        });\n    }\n  }\n\n  /**\n   * Resize handler\n   *\n   * @param {Number} width\n   * @param {Number} height\n   * @memberof TransitionPass\n   */\n  resize = (width: number, height: number) => {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n  };\n\n  /**\n   * Render both scenes to renderTargetA and renderTargetB\n   *\n   * @param {BaseScene} sceneA\n   * @param {BaseScene} sceneB\n   * @param {WebGLRenderTarget} renderTargetA\n   * @param {WebGLRenderTarget} renderTargetB\n   * @param {Number} delta\n   * @memberof TransitionPass\n   */\n  render = (\n    sceneA: BaseScene,\n    sceneB: BaseScene,\n    renderTargetA: WebGLRenderTarget,\n    renderTargetB: WebGLRenderTarget,\n    delta: number\n  ) => {\n    sceneA.update(delta);\n    sceneB.update(delta);\n    renderer.setClearColor(sceneA.clearColor);\n    renderer.setRenderTarget(renderTargetA);\n    renderer.render(sceneA.scene, sceneA.camera);\n    renderer.setClearColor(sceneB.clearColor);\n    renderer.setRenderTarget(renderTargetB);\n    renderer.render(sceneB.scene, sceneB.camera);\n    this.mesh.material.uniforms.texture0.value = renderTargetA.texture;\n    this.mesh.material.uniforms.texture1.value = renderTargetB.texture;\n    renderer.setRenderTarget(null);\n  };\n}\n","import { Vector2, Material } from 'three';\nimport { GUI } from 'dat.gui';\n\nexport const uniforms = {\n  fxaaEnabled: { value: 1 },\n  fxaaResolution: { value: new Vector2(1 / 1024, 1 / 512) }\n};\n\nexport const fragmentUniforms = `\n  precision highp float;\n  uniform bool fxaaEnabled;\n  uniform vec2 fxaaResolution;\n  varying vec2 vUv;\n`;\n\nexport const fragmentPass = `\n  // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n  //----------------------------------------------------------------------------------\n  // File:        es3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n  // SDK Version: v3.00\n  // Email:       gameworks@nvidia.com\n  // Site:        http://developer.nvidia.com/\n  //\n  // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions\n  // are met:\n  //  * Redistributions of source code must retain the above copyright\n  //    notice, this list of conditions and the following disclaimer.\n  //  * Redistributions in binary form must reproduce the above copyright\n  //    notice, this list of conditions and the following disclaimer in the\n  //    documentation and/or other materials provided with the distribution.\n  //  * Neither the name of NVIDIA CORPORATION nor the names of its\n  //    contributors may be used to endorse or promote products derived\n  //    from this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n  // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n  // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  //----------------------------------------------------------------------------------\n\n  #define FXAA_PC 1\n  #define FXAA_GLSL_100 1\n  #define FXAA_QUALITY_PRESET 12\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n      //\n      // The console algorithm for PC is included\n      // for developers targeting really low spec machines.\n      // Likely better to just run FXAA_PC, and use a really low preset.\n      //\n      #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n      #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n      #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n      #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n      #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n      #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n      //\n      // For those using non-linear color,\n      // and either not able to get luma in alpha, or not wanting to,\n      // this enables FXAA to run using green as a proxy for luma.\n      // So with this enabled, no need to pack luma in alpha.\n      //\n      // This will turn off AA on anything which lacks some amount of green.\n      // Pure red and blue or combination of only R and B, will get no AA.\n      //\n      // Might want to lower the settings for both,\n      //    fxaaConsoleEdgeThresholdMin\n      //    fxaaQualityEdgeThresholdMin\n      // In order to insure AA does not get turned off on colors\n      // which contain a minor amount of green.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n      //\n      // Controls algorithm's early exit path.\n      // On PS3 turning this ON adds 2 cycles to the shader.\n      // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n      // Turning this off on console will result in a more blurry image.\n      // So this defaults to on.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n      //\n      // Only valid for PC OpenGL currently.\n      // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n      //\n      // 1 = Use discard on pixels which don't need AA.\n      //     For APIs which enable concurrent TEX+ROP from same surface.\n      // 0 = Return unchanged color on pixels which don't need AA.\n      //\n      #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n      //\n      // Used for GLSL 120 only.\n      //\n      // 1 = GL API supports fast pixel offsets\n      // 0 = do not use fast pixel offsets\n      //\n      #ifdef GL_EXT_gpu_shader4\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifndef FXAA_FAST_PIXEL_OFFSET\n          #define FXAA_FAST_PIXEL_OFFSET 0\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n      //\n      // 1 = API supports gather4 on alpha channel.\n      // 0 = API does not support gather4 on alpha channel.\n      //\n      #if (FXAA_HLSL_5 == 1)\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifndef FXAA_GATHER4_ALPHA\n          #define FXAA_GATHER4_ALPHA 0\n      #endif\n  #endif\n\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITY_PRESET\n      //\n      // Choose the quality preset.\n      // This needs to be compiled into the shader as it effects code.\n      // Best option to include multiple presets is to\n      // in each shader define the preset, then include this file.\n      //\n      // OPTIONS\n      // -----------------------------------------------------------------------\n      // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n      // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n      // 39       - no dither, very expensive\n      //\n      // NOTES\n      // -----------------------------------------------------------------------\n      // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n      // 13 = about same speed as FXAA 3.9 and better than 12\n      // 23 = closest to FXAA 3.9 visually and performance wise\n      //  _ = the lowest digit is directly related to performance\n      // _  = the highest digit is directly related to style\n      //\n      #define FXAA_QUALITY_PRESET 12\n  #endif\n\n\n  /*============================================================================\n\n                              FXAA QUALITY - PRESETS\n\n  ============================================================================*/\n\n  /*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 10)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 3.0\n      #define FXAA_QUALITY_P2 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 11)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 3.0\n      #define FXAA_QUALITY_P3 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 12)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 4.0\n      #define FXAA_QUALITY_P4 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 13)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 4.0\n      #define FXAA_QUALITY_P5 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 14)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 4.0\n      #define FXAA_QUALITY_P6 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 15)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 12.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 20)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 2.0\n      #define FXAA_QUALITY_P2 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 21)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 22)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 23)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 24)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 3.0\n      #define FXAA_QUALITY_P6 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 25)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 26)\n      #define FXAA_QUALITY_PS 9\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 4.0\n      #define FXAA_QUALITY_P8 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 27)\n      #define FXAA_QUALITY_PS 10\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 4.0\n      #define FXAA_QUALITY_P9 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 28)\n      #define FXAA_QUALITY_PS 11\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 4.0\n      #define FXAA_QUALITY_P10 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 29)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 39)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.0\n      #define FXAA_QUALITY_P2 1.0\n      #define FXAA_QUALITY_P3 1.0\n      #define FXAA_QUALITY_P4 1.0\n      #define FXAA_QUALITY_P5 1.5\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n\n\n  /*============================================================================\n\n                                  API PORTING\n\n  ============================================================================*/\n  #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n      #define FxaaBool bool\n      #define FxaaDiscard discard\n      #define FxaaFloat float\n      #define FxaaFloat2 vec2\n      #define FxaaFloat3 vec3\n      #define FxaaFloat4 vec4\n      #define FxaaHalf float\n      #define FxaaHalf2 vec2\n      #define FxaaHalf3 vec3\n      #define FxaaHalf4 vec4\n      #define FxaaInt2 ivec2\n      #define FxaaSat(x) clamp(x, 0.0, 1.0)\n      #define FxaaTex sampler2D\n  #else\n      #define FxaaBool bool\n      #define FxaaDiscard clip(-1)\n      #define FxaaFloat float\n      #define FxaaFloat2 float2\n      #define FxaaFloat3 float3\n      #define FxaaFloat4 float4\n      #define FxaaHalf half\n      #define FxaaHalf2 half2\n      #define FxaaHalf3 half3\n      #define FxaaHalf4 half4\n      #define FxaaSat(x) saturate(x)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_120 == 1)\n      // Requires,\n      //  #version 120\n      // And at least,\n      //  #extension GL_EXT_gpu_shader4 : enable\n      //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n      #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n      #if (FXAA_FAST_PIXEL_OFFSET == 1)\n          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n      #else\n          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n      #endif\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_130 == 1)\n      // Requires #version 130 or better\n      #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_3 == 1)\n      #define FxaaInt2 float2\n      #define FxaaTex sampler2D\n      #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n      #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_4 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_5 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n      #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n      #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n      #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n      #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n  #endif\n\n\n  /*============================================================================\n                      GREEN AS LUMA OPTION SUPPORT FUNCTION\n  ============================================================================*/\n  #if (FXAA_GREEN_AS_LUMA == 0)\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n  #else\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n  #endif\n\n\n\n\n  /*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n  ============================================================================*/\n  #if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n      //\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy} = center of pixel\n      FxaaFloat2 pos,\n      //\n      // Used only for FXAA Console, and not used on the 360 version.\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy_} = upper left of pixel\n      // {_zw} = lower right of pixel\n      FxaaFloat4 fxaaConsolePosPos,\n      //\n      // Input color texture.\n      // {rgb_} = color in linear or perceptual color space\n      // if (FXAA_GREEN_AS_LUMA == 0)\n      //     {__a} = luma in perceptual color space (not linear)\n      FxaaTex tex,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 2nd sampler.\n      // This sampler needs to have an exponent bias of -1.\n      FxaaTex fxaaConsole360TexExpBiasNegOne,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 3nd sampler.\n      // This sampler needs to have an exponent bias of -2.\n      FxaaTex fxaaConsole360TexExpBiasNegTwo,\n      //\n      // Only used on FXAA Quality.\n      // This must be from a constant/uniform.\n      // {x_} = 1.0/screenWidthInPixels\n      // {_y} = 1.0/screenHeightInPixels\n      FxaaFloat2 fxaaQualityRcpFrame,\n      //\n      // Only used on FXAA Console.\n      // This must be from a constant/uniform.\n      // This effects sub-pixel AA quality and inversely sharpness.\n      //   Where N ranges between,\n      //     N = 0.50 (default)\n      //     N = 0.33 (sharper)\n      // {x__} = -N/screenWidthInPixels\n      // {_y_} = -N/screenHeightInPixels\n      // {_z_} =  N/screenWidthInPixels\n      // {__w} =  N/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt,\n      //\n      // Only used on FXAA Console.\n      // Not used on 360, but used on PS3 and PC.\n      // This must be from a constant/uniform.\n      // {x__} = -2.0/screenWidthInPixels\n      // {_y_} = -2.0/screenHeightInPixels\n      // {_z_} =  2.0/screenWidthInPixels\n      // {__w} =  2.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n      //\n      // Only used on FXAA Console.\n      // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n      // This must be from a constant/uniform.\n      // {x__} =  8.0/screenWidthInPixels\n      // {_y_} =  8.0/screenHeightInPixels\n      // {_z_} = -4.0/screenWidthInPixels\n      // {__w} = -4.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_SUBPIX define.\n      // It is here now to allow easier tuning.\n      // Choose the amount of sub-pixel aliasing removal.\n      // This can effect sharpness.\n      //   1.00 - upper limit (softer)\n      //   0.75 - default amount of filtering\n      //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n      //   0.25 - almost off\n      //   0.00 - completely off\n      FxaaFloat fxaaQualitySubpix,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // The minimum amount of local contrast required to apply algorithm.\n      //   0.333 - too little (faster)\n      //   0.250 - low quality\n      //   0.166 - default\n      //   0.125 - high quality\n      //   0.063 - overkill (slower)\n      FxaaFloat fxaaQualityEdgeThreshold,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n      //   0.0625 - high quality (faster)\n      //   0.0312 - visible limit (slower)\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaQualityEdgeThresholdMin,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only three safe values here: 2 and 4 and 8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // For all other platforms can be a non-power of two.\n      //   8.0 is sharper (default!!!)\n      //   4.0 is softer\n      //   2.0 is really soft (good only for vector graphics inputs)\n      FxaaFloat fxaaConsoleEdgeSharpness,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only two safe values here: 1/4 and 1/8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // The console setting has a different mapping than the quality setting.\n      // Other platforms can use other values.\n      //   0.125 leaves less aliasing, but is softer (default!!!)\n      //   0.25 leaves more aliasing, and is sharper\n      FxaaFloat fxaaConsoleEdgeThreshold,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      // The console setting has a different mapping than the quality setting.\n      // This only applies when FXAA_EARLY_EXIT is 1.\n      // This does not apply to PS3,\n      // PS3 was simplified to avoid more shader instructions.\n      //   0.06 - faster but more aliasing in darks\n      //   0.05 - default\n      //   0.04 - slower and less aliasing in darks\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaConsoleEdgeThresholdMin,\n      //\n      // Extra constants for 360 FXAA Console only.\n      // Use zeros or anything else for other platforms.\n      // These must be in physical constant registers and NOT immediates.\n      // Immediates will result in compiler un-optimizing.\n      // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n      FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posM;\n      posM.x = pos.x;\n      posM.y = pos.y;\n      #if (FXAA_GATHER4_ALPHA == 1)\n          #if (FXAA_DISCARD == 0)\n              FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n              #if (FXAA_GREEN_AS_LUMA == 0)\n                  #define lumaM rgbyM.w\n              #else\n                  #define lumaM rgbyM.y\n              #endif\n          #endif\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n          #else\n              FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n          #endif\n          #if (FXAA_DISCARD == 1)\n              #define lumaM luma4A.w\n          #endif\n          #define lumaE luma4A.z\n          #define lumaS luma4A.x\n          #define lumaSE luma4A.y\n          #define lumaNW luma4B.w\n          #define lumaN luma4B.z\n          #define lumaW luma4B.x\n      #else\n          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              #define lumaM rgbyM.w\n          #else\n              #define lumaM rgbyM.y\n          #endif\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n          #endif\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat maxSM = max(lumaS, lumaM);\n      FxaaFloat minSM = min(lumaS, lumaM);\n      FxaaFloat maxESM = max(lumaE, maxSM);\n      FxaaFloat minESM = min(lumaE, minSM);\n      FxaaFloat maxWN = max(lumaN, lumaW);\n      FxaaFloat minWN = min(lumaN, lumaW);\n      FxaaFloat rangeMax = max(maxWN, maxESM);\n      FxaaFloat rangeMin = min(minWN, minESM);\n      FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n      FxaaFloat range = rangeMax - rangeMin;\n      FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n      FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n      if(earlyExit)\n          #if (FXAA_DISCARD == 1)\n              FxaaDiscard;\n          #else\n              return rgbyM;\n          #endif\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_GATHER4_ALPHA == 0)\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n          #endif\n      #else\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNS = lumaN + lumaS;\n      FxaaFloat lumaWE = lumaW + lumaE;\n      FxaaFloat subpixRcpRange = 1.0/range;\n      FxaaFloat subpixNSWE = lumaNS + lumaWE;\n      FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n      FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNESE = lumaNE + lumaSE;\n      FxaaFloat lumaNWNE = lumaNW + lumaNE;\n      FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n      FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNWSW = lumaNW + lumaSW;\n      FxaaFloat lumaSWSE = lumaSW + lumaSE;\n      FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n      FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n      FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n      FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n      FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n      FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n      FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n      FxaaBool horzSpan = edgeHorz >= edgeVert;\n      FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n      if(!horzSpan) lumaN = lumaW;\n      if(!horzSpan) lumaS = lumaE;\n      if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n      FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat gradientN = lumaN - lumaM;\n      FxaaFloat gradientS = lumaS - lumaM;\n      FxaaFloat lumaNN = lumaN + lumaM;\n      FxaaFloat lumaSS = lumaS + lumaM;\n      FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n      FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n      if(pairN) lengthSign = -lengthSign;\n      FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posB;\n      posB.x = posM.x;\n      posB.y = posM.y;\n      FxaaFloat2 offNP;\n      offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n      offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n      if(!horzSpan) posB.x += lengthSign * 0.5;\n      if( horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posN;\n      posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n      posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat2 posP;\n      posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n      posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n      FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n      FxaaFloat subpixE = subpixC * subpixC;\n      FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n      if(!pairN) lumaNN = lumaSS;\n      FxaaFloat gradientScaled = gradient * 1.0/4.0;\n      FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n      FxaaFloat subpixF = subpixD * subpixE;\n      FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n      lumaEndN -= lumaNN * 0.5;\n      lumaEndP -= lumaNN * 0.5;\n      FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n      FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n      FxaaBool doneNP = (!doneN) || (!doneP);\n      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n  /*--------------------------------------------------------------------------*/\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 3)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 4)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 5)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 6)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n  /*--------------------------------------------------------------------------*/\n                          #if (FXAA_QUALITY_PS > 7)\n                          if(doneNP) {\n                              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                              doneN = abs(lumaEndN) >= gradientScaled;\n                              doneP = abs(lumaEndP) >= gradientScaled;\n                              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                              doneNP = (!doneN) || (!doneP);\n                              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_QUALITY_PS > 8)\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 9)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 10)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 11)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 12)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n      #endif\n  /*--------------------------------------------------------------------------*/\n                          }\n                          #endif\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat dstN = posM.x - posN.x;\n      FxaaFloat dstP = posP.x - posM.x;\n      if(!horzSpan) dstN = posM.y - posN.y;\n      if(!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n      FxaaFloat spanLength = (dstP + dstN);\n      FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n      FxaaFloat spanLengthRcp = 1.0/spanLength;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool directionN = dstN < dstP;\n      FxaaFloat dst = min(dstN, dstP);\n      FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n      FxaaFloat subpixG = subpixF * subpixF;\n      FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n      FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n      FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n      if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n      if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n      #if (FXAA_DISCARD == 1)\n          return FxaaTexTop(tex, posM);\n      #else\n          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n      #endif\n  }\n  /*==========================================================================*/\n  #endif\n`;\n\nexport const fragmentMain = `\n  // FXAA pass start\n  if (fxaaEnabled) {\n    outgoingColor = FxaaPixelShader(\n      uv,\n      vec4(0.0),\n      tDiffuse,\n      tDiffuse,\n      tDiffuse,\n      fxaaResolution,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n    );\n    // TODO avoid querying texture twice for same texel\n    outgoingColor.a = texture2D(tDiffuse, uv).a;\n  }\n  // FXAA pass end\n`;\n\nexport function guiControls(gui: GUI, material: Material) {\n  const guiPass = gui.addFolder('fxaa pass');\n  guiPass.close();\n  guiPass.add(material.uniforms.fxaaEnabled, 'value', 0, 1, 1).name('enabled');\n}\n","import {\n  fragmentUniforms as fxaaFragmentUniforms,\n  fragmentMain as fxaaFragmentMain,\n  fragmentPass as fxaaFragmentPass\n} from '../../passes/fxaa.glsl';\n\nexport const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform vec2 resolution;\n  uniform float time;\n  uniform sampler2D tDiffuse;\n  // FXAA pass\n  ${fxaaFragmentUniforms}\n  ${fxaaFragmentPass}\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 outgoingColor = texture2D(tDiffuse, uv);\n    // FXAA pass\n    ${fxaaFragmentMain}\n    gl_FragColor.rgb = outgoingColor.rgb;\n    gl_FragColor.a = outgoingColor.a;\n  }\n`;\n","import {\n  Scene,\n  Mesh,\n  ShaderMaterial,\n  Vector2,\n  UniformsUtils,\n  WebGLRenderTarget,\n  BufferGeometry,\n  OrthographicCamera,\n  PerspectiveCamera\n} from 'three';\nimport { GUI } from 'dat.gui';\nimport { vertexShader, fragmentShader } from './shader.glsl';\nimport { getRenderBufferSize } from '../../../resize';\nimport { uniforms as fxaaUniforms, guiControls as fxaaGuiControls } from '../../passes/fxaa.glsl';\nimport renderer from '../../../renderer';\n\n/**\n * The final pass contains the post fx and is then output to the screen\n *\n * @export\n * @class FinalPass\n */\nexport default class FinalPass {\n  gui: GUI;\n  scene: Scene;\n  camera: OrthographicCamera;\n  mesh: Mesh;\n\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    // Create gui\n    this.gui = gui.addFolder('final pass');\n    this.gui.close();\n    // Create scene\n    this.scene = new Scene();\n    // Use camera from post processing\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    // Setup shader and combine uniforms from any post fx you want to include\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([\n        {\n          time: {\n            value: 0\n          },\n          tDiffuse: {\n            // Keep it the same as threejs for reusability\n            value: null\n          },\n          resolution: {\n            value: new Vector2(width, height)\n          }\n        },\n        fxaaUniforms\n      ]),\n      vertexShader,\n      fragmentShader\n    });\n\n    // Add gui controls\n    fxaaGuiControls(this.gui, material);\n\n    // Create the mesh and turn off matrixAutoUpdate\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n  }\n\n  /**\n   * Resize handler, update uniforms\n   *\n   * @param {Number} width\n   * @param {Number} height\n   * @memberof FinalPass\n   */\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.mesh.material.uniforms.fxaaResolution.value.x = 1 / width;\n    this.mesh.material.uniforms.fxaaResolution.value.y = 1 / height;\n  }\n\n  /**\n   * Render the pass and output to screen\n   *\n   * @param {*} scene\n   * @param {WebGLRenderTarget} renderTarget\n   * @param {Number} delta\n   * @memberof FinalPass\n   */\n  render(scene: BaseScene, renderTarget: WebGLRenderTarget, delta: number) {\n    // renderer.setRenderTarget(renderTarget);\n    // renderer.render(scene.scene, scene.camera);\n    // renderer.setRenderTarget(null);\n    this.mesh.material.uniforms.tDiffuse.value = renderTarget.texture;\n    this.mesh.material.uniforms.time.value += delta;\n    renderer.render(this.scene, this.camera);\n  }\n\n  /**\n   * Render the final pass when used with the screenshot utility\n   *\n   * @param {Scene} scene\n   * @param {PerspectiveCamera} camera\n   * @param {WebGLRenderTarget} renderTargetA\n   * @param {WebGLRenderTarget} renderTargetB\n   * @param {number} delta\n   * @memberof FinalPass\n   */\n  screenshotRender(\n    scene: Scene,\n    camera: PerspectiveCamera,\n    renderTargetA: WebGLRenderTarget,\n    renderTargetB: WebGLRenderTarget,\n    delta: number\n  ) {\n    this.mesh.material.uniforms.tDiffuse.value = renderTargetA.texture;\n    this.mesh.material.uniforms.time.value += delta;\n    renderer.setRenderTarget(renderTargetB);\n    renderer.render(this.scene, this.camera);\n  }\n}\n","import BaseScene from '../base/base-scene';\nimport { VECTOR_ZERO } from '../../utils/math';\n\nexport default class EmptyScene extends BaseScene {\n  constructor(id: string, clearColor: number) {\n    super({ id, clearColor });\n    this.camera.position.set(0, 0, 10);\n    this.camera.lookAt(VECTOR_ZERO);\n  }\n}\n","import { Mesh, Scene, ShaderMaterial, Vector2, WebGLRenderTarget } from 'three';\nimport renderer from '../../../renderer';\nimport { getRenderBufferSize } from '../../../resize';\n\nexport default class CopyPass {\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    this.scene = new Scene();\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    const material = new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          // Keep it the same as threejs for reusability\n          value: null\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader: `\n        void main() {\n          gl_Position = vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n        void main() {\n          vec2 uv = gl_FragCoord.xy / resolution;\n          gl_FragColor = texture2D(tDiffuse, uv);\n        }\n      `\n    });\n\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n  }\n\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n  }\n\n  render(renderTarget: WebGLRenderTarget, renderTargetCopy: WebGLRenderTarget, toScreen: boolean = false) {\n    if (toScreen) {\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(renderTarget);\n      this.mesh.material.uniforms.tDiffuse.value = renderTargetCopy.texture;\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(null);\n    }\n  }\n}\n","import { Mesh, Scene, ShaderMaterial, Vector2, WebGLRenderTarget } from 'three';\nimport renderer from '../../../renderer';\nimport { getRenderBufferSize } from '../../../resize';\nimport { vertexShader, fragmentShader } from './shader.glsl';\n\nexport default class DenoisePass {\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    this.gui = gui.addFolder('denoise pass');\n    this.gui.open();\n    this.scene = new Scene();\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    const material = new ShaderMaterial({\n      uniforms: {\n        tDiffusePrev: {\n          value: null\n        },\n        tDiffuse: {\n          value: null\n        },\n        frameCount: {\n          value: 0\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader,\n      fragmentShader\n    });\n\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n\n    this.active = false;\n    this.passes = 0;\n    this.maxPasses = 2000;\n\n    this.gui.add(this, 'passes').listen();\n    this.gui.add(this, 'maxPasses', 0, 20000);\n    this.gui\n      .add(this, 'active')\n      .onChange(this.reset)\n      .listen();\n  }\n\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.reset();\n  }\n\n  reset = () => {\n    this.passes = 0;\n  };\n\n  render(\n    scene: BaseScene,\n    renderTargetCurrent: WebGLRenderTarget,\n    renderTargetPrev: WebGLRenderTarget,\n    renderTargetCombined: WebGLRenderTarget\n  ) {\n    this.mesh.material.uniforms.frameCount.value = this.passes;\n\n    // Render current scene\n    renderer.setRenderTarget(renderTargetCurrent);\n    renderer.render(scene.scene, scene.camera);\n\n    // Render previous and current frame together\n    renderer.setRenderTarget(renderTargetCombined);\n    this.mesh.material.uniforms.tDiffuse.value = renderTargetCurrent.texture;\n    this.mesh.material.uniforms.tDiffusePrev.value = renderTargetPrev.texture;\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(null);\n    this.passes++;\n  }\n\n  pauseRendering() {\n    return this.active && this.passes >= this.maxPasses;\n  }\n}\n","export const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform sampler2D tDiffuse;\n  uniform sampler2D tDiffusePrev;\n  uniform float frameCount;\n  uniform vec2 resolution;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(tDiffusePrev, uv);\n    vec4 texel1 = texture2D(tDiffuse, uv);\n    gl_FragColor = mix(texel0, texel1, clamp(1.0 / frameCount, 0.0, 1.0));\n  }\n`;\n","export default `\n  struct Camera {\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    float aspect;\n    vec3 origin;\n    float lensRadius;\n    vec3 u;\n    vec3 v;\n  };\n\n  struct Ray {\n    vec3 origin;\n    vec3 direction;\n  };\n\n  vec2 randomInUnitDisk() {\n    float x = rand(vUv + seed.xy);\n    float y = rand(vUv + seed.xz);\n    float r = mix(-1.0, 1.0, rand(vUv + seed.yw));\n\t  return r * vec2(sin(x * TWO_PI), cos(y * TWO_PI));\n  }\n\n  Ray getRay(float u, float v, Camera camera) {\n    vec2 rd = camera.lensRadius * randomInUnitDisk();\n    vec3 offset = camera.u * rd.x + camera.v * rd.y;\n    return Ray(camera.origin + offset, normalize(camera.lowerLeftCorner + u * camera.horizontal + v * camera.vertical - camera.origin - offset));\n  }\n\n  vec3 pointAtParameter(float t, Ray ray) {\n    return ray.origin + t * ray.direction;\n  }\n\n\n  Camera createCamera(vec3 origin, vec3 lookat, vec3 up, float aspect, float aperture, float focusDistance) {\n    Camera camera;\n\n    float theta = fov * (PI / 180.0);\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    vec3 w = normalize(origin - lookat);\n    camera.u = normalize(cross(up, w));\n    camera.v = cross(w, camera.u);\n\n    camera.aspect = aspect;\n    camera.lowerLeftCorner = origin - halfWidth * focusDistance * camera.u - halfHeight * focusDistance * camera.v - focusDistance * w;\n    camera.horizontal = 2.0 * halfWidth * focusDistance * camera.u;\n    camera.vertical = 2.0 * halfHeight * focusDistance * camera.v;\n    camera.origin = origin;\n    camera.lensRadius = aperture / 2.0;\n\n    return camera;\n  }\n`;\n","export default `\n  struct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n  };\n`;\n","import { WORLD_SIZE } from './constants';\n\nexport default `\n  bool sphereHit(Ray ray, const in float tMin, const in float tMax, const in Sphere sphere, inout HitRecord hitRecord) {\n\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction); // origin\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discriminant = b * b - a * c;\n\n    if (discriminant < 0.0) return false;\n\n    float s = sqrt(discriminant);\n\n    float temp = (-b - s) / a;\n    if (temp < tMax && temp > tMin) {\n      hitRecord.t = temp;\n      hitRecord.position = ray.origin + temp * ray.direction;\n      hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n      hitRecord.material = sphere.material;\n      return true;\n    }\n    temp = (-b + s) / a;\n    if (temp < tMax && temp > tMin) {\n      hitRecord.t = temp;\n      hitRecord.position = ray.origin + temp * ray.direction;\n      hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n      hitRecord.material = sphere.material;\n      return true;\n    }\n    return false;\n  }\n\n  bool hit(Ray ray, float tMin, float tMax, Sphere list[${WORLD_SIZE}], inout HitRecord hitRecord) {\n    bool hitAnything = false;\n    float closestSoFar = tMax;\n    // If record doesn't hit, we use the previous\n    HitRecord tempRecord = hitRecord;\n    for(int i = 0; i < ${WORLD_SIZE}; i++) {\n      if (sphereHit(ray, tMin, closestSoFar, list[i], tempRecord)) {\n        hitAnything = true;\n        closestSoFar = tempRecord.t;\n        hitRecord = tempRecord;\n      }\n    }\n    return hitAnything;\n  }\n\n\n`;\n","export const WORLD_SIZE = 5;\n","export default `\n\n  vec3 ref(vec3 direction, vec3 normal) {\n    return direction - 2.0 * dot(direction, normal) * normal;\n  }\n\n  bool refract(const in vec3 direction, const in vec3 normal, const in float niOverNt, out vec3 refracted) {\n    float dt = dot(direction, normal);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if (discriminant > 0.0) {\n      refracted = niOverNt * (direction - normal * dt) - normal * sqrt(discriminant);\n      return true;\n    }\n    return false;\n  }\n\n  float schlick(float cosine, float reflectionIndex) {\n    float r0 = (1.0 - reflectionIndex) / (1.0 + reflectionIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n  }\n\n  bool scatter(inout Ray ray, const in HitRecord hitRecord, out vec3 attenuation, out Ray scatteredRay) {\n    if(hitRecord.material.type == METAL) {\n      attenuation = hitRecord.material.albedo;\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float fuzz = clamp(hitRecord.material.value, 0.0, 1.0);\n      scatteredRay = Ray(hitRecord.position, normalize(reflected + fuzz * randomInSphere(hitRecord.normal.xz)));\n      return (dot(scatteredRay.direction, hitRecord.normal) > 0.0);\n    } else if(hitRecord.material.type == DIELECTRIC) {\n\n      vec3 outwardNormal = vec3(0);\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float niOverNt = 0.0;\n\n      float reflectionIndex = hitRecord.material.value;\n\n      attenuation = vec3(1.0);\n      vec3 refracted = vec3(0);\n      float reflectProbability = 0.0;\n      float cosine = 0.0;\n\n      if (dot(ray.direction, hitRecord.normal) > 0.0) {\n        outwardNormal = -hitRecord.normal;\n        niOverNt = reflectionIndex;\n        cosine = reflectionIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      } else {\n        outwardNormal = hitRecord.normal;\n        niOverNt = 1.0 / reflectionIndex;\n        cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      }\n\n      if(refract(ray.direction, outwardNormal, niOverNt, refracted)) {\n        scatteredRay = Ray(hitRecord.position, refracted);\n        reflectProbability = schlick(cosine, hitRecord.material.value);\n      } else {\n        scatteredRay = Ray(hitRecord.position, reflected);\n        reflectProbability = 1.0;\n      }\n\n      if (rand(vUv + seed.xy + hitRecord.position.xz) < reflectProbability) {\n        scatteredRay = Ray(hitRecord.position, reflected);\n      } else {\n        scatteredRay = Ray(hitRecord.position, refracted);\n      }\n\n      return true;\n    } else {\n      // lambert\n      attenuation = hitRecord.material.albedo;\n      vec3 target = hitRecord.position + hitRecord.normal + randomInSphere(hitRecord.normal.xz);\n      scatteredRay = Ray(hitRecord.position, normalize(target - hitRecord.position));\n      return true;\n    }\n  }\n`;\n","import { WORLD_SIZE } from './constants';\n\nexport default (maxBounces: number) => {\n  return `\n    vec3 raytraceWorld(in Ray ray, Sphere world[${WORLD_SIZE}]) {\n    HitRecord hitRecord;\n    vec3 color = vec3(1);\n\n    for(int i = 0; i < ${maxBounces}; i++) {\n      Ray scatteredRay;\n      if (hit(ray, 0.001, MAX_FLOAT, world, hitRecord)) {\n          vec3 attenuation;\n          if(scatter(ray, hitRecord, attenuation, scatteredRay)) {\n            color *= attenuation;\n            ray = scatteredRay;\n          } else {\n            return vec3(0);\n          }\n      } else {\n        // Sky color\n        float t = 0.5 * ray.direction.y + 1.0;\n        color *= mix(vec3(1), vec3(0.5, 0.7, 1.0), t);\n        return color;\n      }\n    }\n\n    return vec3(0);\n  }\n  `;\n};\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport camera from './camera.glsl';\nimport sphere from './sphere.glsl';\nimport hitables from './hitables.glsl';\nimport material from './material.glsl';\nimport world from './world.glsl';\nimport { WORLD_SIZE } from './constants';\n\nexport const uniforms = {\n  resolution: { value: new Vector2() },\n  fov: { value: 20 },\n  seed: { value: new Vector4(Math.random(), Math.random(), Math.random(), Math.random()) },\n  time: { value: 0 },\n  cameraAspect: { value: 1 },\n  cameraAperture: { value: 2 },\n  cameraPosition: { value: new Vector3() },\n  cameraTarget: { value: new Vector3() },\n  sphere0Position: { value: new Vector3(0.0, 0.0, -1.0) },\n  sphere1Position: { value: new Vector3(1.0, 0.0, -1.0) },\n  sphere2Position: { value: new Vector3(-1.0, 0.0, -1.0) },\n  refractionIndex: { value: 1.5 }\n};\n\nexport const vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = (maxBounces: number = 50) => {\n  return `\n    uniform vec2 resolution;\n    uniform float time;\n    uniform vec4 seed;\n    uniform float fov;\n    uniform vec3 cameraTarget;\n    uniform float cameraAspect;\n    uniform float refractionIndex;\n    uniform float cameraAperture;\n    uniform vec3 sphere0Position;\n    uniform vec3 sphere1Position;\n    uniform vec3 sphere2Position;\n    varying vec2 vUv;\n\n    #define MAX_FLOAT 1e5\n    #define PI 3.141592653589793\n    #define TWO_PI 6.283185307179586\n    #define LAMBERT 0\n    #define METAL 1\n    #define DIELECTRIC 2\n\n    float rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec3 randomInSphere(vec2 seed2){\n      vec2 uv = vec2(rand(vUv + seed.xy + seed2), rand(vUv + seed.xz + seed2));\n      float theta = 2.0 * PI * uv.x;\n      float phi = acos(2.0 * uv.y - 1.0);\n      float radius = 1.0;\n      float x = (radius * sin(phi) * cos(theta));\n      float y = (radius * sin(phi) * sin(theta));\n      float z = (radius * cos(phi));\n      return vec3(x, y, z);\n    }\n\n    struct Material {\n      int type;\n      vec3 albedo;\n      float value;\n    };\n\n    struct HitRecord {\n      float t;\n      vec3 position;\n      vec3 normal;\n      Material material;\n    };\n\n    ${camera}\n    ${sphere}\n    ${material}\n    ${hitables}\n    ${world(maxBounces)}\n\n    vec3 calculateNormals(float t, vec3 center, Ray ray) {\n      vec3 normal = pointAtParameter(t, ray) - center;\n      normal /= length(normal); // make normal unit length\n      return normal;\n    }\n\n    void main(){\n\n      // Fix aspect\n      vec2 uv = vUv;\n      uv.y -= 0.5;\n      uv.y *= 2.0 * resolution.y / resolution.x;\n      uv.y += 0.5;\n\n      Sphere world[${WORLD_SIZE}];\n      world[0] = Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(LAMBERT, vec3(0.1, 0.2, 0.5), 0.0));\n      world[1] = Sphere(vec3(0.0, -100.5, 0.0), 100.0, Material(LAMBERT, vec3(0.5), 0.0));\n      world[2] = Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(METAL, vec3(0.8, 0.6, 0.2), 0.0));\n      world[3] = Sphere(vec3(-1.0, 0.0, -1.0), 0.5, Material(DIELECTRIC, vec3(0), 1.5));\n      world[4] = Sphere(vec3(-1.0, 0.0, -1.0), -0.45, Material(DIELECTRIC, vec3(0), 1.5));\n\n      // Anti aliasing\n      // const int ns = 20;\n      // vec3 col = vec3(0);\n      // float scale = 0.00001;\n      // for(int i = 0; i < ns; i++) {\n      //   float u = ((random.x * 2.0 - 1.0) * scale) + uv.x;\n      //   float v = ((random.y * 2.0 - 1.0) * scale) + uv.y;\n\n      //   Ray ray = getRay(u, v, lowerLeftCorner, horizontal, vertical);\n      //   Camera camera = Camera(\n      //     lowerLeftCorner,\n      //     horizontal,\n      //     vertical,\n      //     ray\n      //   );\n\n      //   col += raytrace(ray, world);\n      // }\n\n      // col /= float(ns);\n      // vec3 outgoingColor = col;\n\n      float focusDistance = length(cameraPosition - cameraTarget);\n\n      Camera camera = createCamera(cameraPosition,\n                                  cameraTarget,\n                                  vec3(0.0, 1.0, 0.0),\n                                  2.0,\n                                  cameraAperture,\n                                  focusDistance);\n\n      Ray ray = getRay(uv.x, uv.y, camera);\n\n      vec3 outgoingColor = raytraceWorld(ray, world);\n\n      gl_FragColor = vec4(outgoingColor, 1.0);\n      gl_FragColor = LinearTosRGB(gl_FragColor);\n    }\n  `;\n};\n","import { Mesh, PerspectiveCamera, PlaneBufferGeometry, ShaderMaterial } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { postProcessing } from '../../../../rendering/renderer';\nimport { uniforms, vertexShader, fragmentShader } from './raytracer.glsl';\n\nexport default class Raytracer {\n  constructor(gui: GUI) {\n    this.gui = gui.addFolder('raytracer');\n    this.gui.open();\n\n    this.maxBounces = 50;\n\n    this.mesh = new Mesh(new PlaneBufferGeometry(2, 2), this.createMaterial());\n    this.gui\n      .add(this.mesh.material.uniforms.fov, 'value', 1, 100)\n      .name('fov')\n      .onChange(this.onChange);\n\n    this.gui.add(this, 'maxBounces', 1, 200, 1).onChange(this.rebuild);\n    this.gui\n      .add(this.mesh.material.uniforms.cameraAperture, 'value', 0, 10)\n      .name('cameraAperture')\n      .onChange(this.onChange);\n\n    // this.addControl(0);\n    // this.addControl(1);\n    // this.addControl(2);\n  }\n\n  createMaterial = () => {\n    return new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader: fragmentShader(this.maxBounces)\n    });\n  };\n\n  rebuild = () => {\n    this.mesh.material = this.createMaterial();\n    this.onChange();\n  };\n\n  onChange = () => {\n    postProcessing.denoisePass.reset();\n  };\n\n  addControl(index: number) {\n    const guiFolder = this.gui.addFolder(`sphere${index}`);\n    guiFolder.open();\n    const range = 5;\n    guiFolder\n      .add(this.mesh.material.uniforms[`sphere${index}Position`].value, 'x', -range, range)\n      .onChange(this.onChange);\n    guiFolder\n      .add(this.mesh.material.uniforms[`sphere${index}Position`].value, 'y', -range, range)\n      .onChange(this.onChange);\n    guiFolder\n      .add(this.mesh.material.uniforms[`sphere${index}Position`].value, 'z', -range, range)\n      .onChange(this.onChange);\n    guiFolder.add(this.mesh.material.uniforms.refractionIndex, 'value', 0, 5).onChange(this.onChange);\n  }\n\n  onChange = () => {\n    postProcessing.denoisePass.reset();\n  };\n\n  resize(width: number, height: number, camera: PerspectiveCamera) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.mesh.material.uniforms.cameraAspect.value = camera.aspect;\n  }\n\n  update(delta: number, camera: PerspectiveCamera, control: OrbitControls) {\n    this.mesh.material.uniforms.seed.value.set(Math.random(), Math.random(), Math.random(), Math.random());\n    this.mesh.material.uniforms.time.value += delta;\n    this.mesh.material.uniforms.cameraPosition.value.copy(camera.position);\n    this.mesh.material.uniforms.cameraTarget.value.copy(control.target);\n  }\n}\n","import BaseScene from '../base/base-scene';\nimport assets from './assets';\nimport Raytracer from './objects/raytracer/raytracer';\nimport { postProcessing } from '../../rendering/renderer';\n\nexport const MAIN_SCENE_ID = 'main';\n\nexport default class MainScene extends BaseScene {\n  constructor() {\n    super({ id: MAIN_SCENE_ID, assets, gui: true, guiOpen: true, controls: true });\n    this.cameras.main.position.set(3, 3, 2);\n    this.control.target.set(0, 0, -1);\n    this.control.update();\n  }\n\n  /**\n   * Create and setup any objects for the scene\n   *\n   * @memberof LandingScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        this.raytracer = new Raytracer(this.gui);\n        this.scene.add(this.raytracer.mesh);\n\n        this.control.addEventListener('change', () => {\n          postProcessing.denoisePass.reset();\n        });\n\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  resize = (width: number, height: number) => {\n    this.cameras.dev.aspect = width / height;\n    this.cameras.dev.updateProjectionMatrix();\n    this.cameras.main.aspect = width / height;\n    this.cameras.main.updateProjectionMatrix();\n    this.raytracer.resize(width, height, this.camera);\n  };\n\n  /**\n   * Update loop\n   *\n   * @memberof LandingScene\n   */\n  update = (delta: number) => {\n    this.controls.main.update();\n    this.raytracer.update(delta, this.camera, this.control);\n  };\n}\n","import { OrthographicCamera, RGBAFormat, WebGLRenderTarget } from 'three';\nimport { GUI } from 'dat.gui';\nimport { bigTriangle } from '../../utils/geometry';\nimport { createRenderTarget } from '../render-target';\nimport { getRenderBufferSize } from '../resize';\nimport TransitionPass from './passes/transition-pass/transition-pass';\nimport FinalPass from './passes/final-pass/final-pass';\nimport EmptyScene from '../../scenes/empty/empty-scene';\nimport renderer from '../renderer';\nimport BaseScene from '../../scenes/base/base-scene';\nimport CopyPass from './passes/copy-pass/copy-pass';\nimport DenoisePass from './passes/denoise-pass/denoise-pass';\nimport { MAIN_SCENE_ID } from '../../scenes/main/main-scene';\n\nexport default class PostProcessing {\n  gui: GUI;\n  camera: OrthographicCamera;\n  renderTargetA: WebGLRenderTarget;\n  renderTargetB: WebGLRenderTarget;\n  renderTargetC: WebGLRenderTarget;\n  transitionPass: TransitionPass;\n  finalPass: FinalPass;\n  currentScene: BaseScene;\n  lastPass: mixed;\n  sceneA: BaseScene;\n  sceneB: BaseScene;\n\n  constructor(gui: GUI) {\n    this.gui = gui;\n    // Create gui\n    // Create big triangle geometry, faster than using quad\n    const geometry = bigTriangle();\n    // Post camera\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    // Setup render targets\n    const { width, height } = getRenderBufferSize();\n    const options = { stencilBuffer: false, format: RGBAFormat };\n    this.renderTargetTransitionA = createRenderTarget(width, height, options);\n    this.renderTargetTransitionB = createRenderTarget(width, height, options);\n    this.renderTargetDenoise = createRenderTarget(width, height, options);\n    this.renderTargetDenoisePrev = createRenderTarget(width, height, options);\n    this.renderTargetDenoiseCombined = createRenderTarget(width, height, options);\n\n    // Create passes\n    this.transitionPass = new TransitionPass(this.gui, geometry, this.camera);\n    this.finalPass = new FinalPass(this.gui, geometry, this.camera);\n    this.denoisePass = new DenoisePass(this.gui, geometry, this.camera);\n    this.copyPass = new CopyPass(this.gui, geometry, this.camera);\n\n    this.transitionPass.on('complete', () => {\n      if (this.sceneB.id === MAIN_SCENE_ID) {\n        this.denoisePass.active = true;\n      }\n    });\n\n    // Create empty scenes\n    const sceneA = new EmptyScene('post scene a', 0x000000);\n    const sceneB = new EmptyScene('post scene b', 0x000000);\n    sceneA.setup();\n    sceneB.setup();\n\n    this.setScenes(sceneA, sceneB);\n    this.resize();\n  }\n\n  /**\n   * Set the two main scenes used for the transition pass\n   *\n   * @param {BaseScene} sceneA\n   * @param {BaseScene} sceneB\n   * @memberof PostProcessing\n   */\n  setScenes(sceneA: BaseScene, sceneB: BaseScene) {\n    this.sceneA = sceneA;\n    this.sceneB = sceneB;\n  }\n\n  /**\n   * Resize handler for passes and render targets\n   *\n   * @memberof PostProcessing\n   */\n  resize() {\n    // const scale = settings.devCamera ? settings.viewportPreviewScale : 1;\n    let { width, height } = getRenderBufferSize();\n\n    // width *= scale;\n    // height *= scale;\n    this.renderTargetTransitionA.setSize(width, height);\n    this.renderTargetTransitionB.setSize(width, height);\n    this.renderTargetDenoise.setSize(width, height);\n    this.renderTargetDenoisePrev.setSize(width, height);\n    this.renderTargetDenoiseCombined.setSize(width, height);\n    this.transitionPass.resize(width, height);\n    this.denoisePass.resize(width, height);\n    this.copyPass.resize(width, height);\n    this.finalPass.resize(width, height);\n  }\n\n  /**\n   * Render passes and output to screen\n   *\n   * @param {Number} delta\n   * @memberof PostProcessing\n   */\n  render(delta: number) {\n    // Stop rendering past x many passes\n    if (this.denoisePass.pauseRendering()) {\n      return;\n    }\n\n    // Determine the current scene based on the transition pass value\n    this.currentScene = this.transitionPass.mesh.material.uniforms.transition.value === 0 ? this.sceneA : this.sceneB;\n    this.lastPass = this.currentScene;\n\n    this.currentScene.update(delta);\n\n    // // If the transition pass is active\n    if (this.transitionPass.active) {\n      this.transitionPass.render(\n        this.sceneA,\n        this.sceneB,\n        this.renderTargetTransitionA,\n        this.renderTargetTransitionB,\n        delta\n      );\n      this.lastPass = this.transitionPass;\n    } else {\n      // Otherwise we just render the current scene\n      renderer.setClearColor(this.currentScene.clearColor);\n      this.currentScene.update(delta);\n    }\n\n    if (this.denoisePass.active) {\n      this.denoisePass.render(\n        this.lastPass,\n        this.renderTargetDenoise,\n        this.renderTargetDenoisePrev,\n        this.renderTargetDenoiseCombined,\n        this.transitionPass.active\n      );\n      // Copy combined result to prev textuer\n      this.copyPass.render(this.renderTargetDenoisePrev, this.renderTargetDenoiseCombined);\n      // this.copyPass.render(this.renderTargetB, this.renderTargetC, true);\n    } else {\n      renderer.setRenderTarget(this.renderTargetDenoiseCombined);\n      renderer.render(this.lastPass.scene, this.lastPass.camera);\n      renderer.setRenderTarget(null);\n    }\n\n    // // Render the final pass which contains all the post fx\n    this.finalPass.render(this.lastPass, this.renderTargetDenoiseCombined, delta);\n  }\n}\n","import { BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * Return a triangle that covers screen-space\n * Mainly used for post processing\n * https://github.com/mikolalysenko/a-big-triangle\n *\n * @export\n * @returns\n */\nexport function bigTriangle() {\n  const geometry = new BufferGeometry();\n  const attribute = new BufferAttribute(new Float32Array([-1, -1, 0, -1, 4, 0, 4, -1, 0]), 3);\n  geometry.setAttribute('position', attribute);\n  geometry.setIndex([0, 2, 1]);\n  return geometry;\n}\n","import { sRGBEncoding, WebGLRenderer } from 'three';\nimport graphics, { getGraphicsMode, getTier } from './graphics';\nimport settings from '../settings';\nimport { setRendererSize } from './resize';\nimport PostProcessing from './post-processing/post-processing';\nimport { gui } from '../utils/gui';\n\nconst { pixelRatio, antialias } = graphics[getGraphicsMode()];\n\nconst renderer = new WebGLRenderer({\n  antialias,\n  powerPreference: 'high-performance',\n  stencil: false,\n  preserveDrawingBuffer: true\n});\nrenderer.setClearColor(0x000000);\nrenderer.outputEncoding = sRGBEncoding;\n\n// Enable shader errors during dev\nrenderer.debug.checkShaderErrors = settings.isDevelopment;\n\nconst guiRendering = gui.addFolder('rendering');\nguiRendering.open();\n\nrenderer.setPixelRatio(pixelRatio);\nrenderer.setScissorTest(true);\nsetRendererSize(renderer, window.innerWidth, window.innerHeight);\n\nexport const postProcessing = new PostProcessing(guiRendering);\n\nconst gl = renderer.getContext();\nconst gpuInfo = gl.getExtension('WEBGL_debug_renderer_info');\nconst gpu = gl.getParameter(gpuInfo.UNMASKED_RENDERER_WEBGL);\n\nif (settings.isDevelopment) console.log(`Graphics: ${getGraphicsMode()}\\nGPU: ${gpu}\\nTier: ${getTier()}`);\n\nexport default renderer;\n","import { WebGLRenderer } from 'three';\nimport settings from '../settings';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author jetienne / http://jetienne.com/\n */\n\n/**\n * Provide info on THREE.WebGLRenderer\n *\n * @param {Object} renderer the renderer to update\n * @param {Object} Camera the camera to update\n */\nconst RendererStats = function() {\n  const container = document.createElement('div');\n  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer;z-index:100000;top:48px;position:absolute;';\n\n  const msDiv = document.createElement('div');\n  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:rgb(0, 0, 0);';\n  container.appendChild(msDiv);\n\n  const msText = document.createElement('div');\n  msText.style.cssText =\n    'color:rgb(255, 255, 255);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';\n  msText.innerHTML = 'WebGLRenderer';\n  msDiv.appendChild(msText);\n\n  const msTexts = [];\n  const nLines = 9;\n  for (var i = 0; i < nLines; i++) {\n    msTexts[i] = document.createElement('div');\n    msTexts[i].style.cssText =\n      'color:rgb(255, 255, 255);background-color:rgb(0, 0, 0);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';\n    msDiv.appendChild(msTexts[i]);\n    msTexts[i].innerHTML = '-';\n  }\n\n  let lastTime = Date.now();\n  return {\n    domElement: container,\n\n    update: function(webglRenderer: WebGLRenderer) {\n      // sanity check\n      console.assert(webglRenderer instanceof WebGLRenderer);\n\n      // refresh only 30time per second\n      if (Date.now() - lastTime < 1000 / 30) return;\n      lastTime = Date.now();\n\n      msTexts[0].textContent = '=== Memory ===';\n      msTexts[1].textContent = 'Programs: ' + webglRenderer.info.programs.length;\n      msTexts[2].textContent = 'Geometries: ' + webglRenderer.info.memory.geometries;\n      msTexts[3].textContent = 'Textures: ' + webglRenderer.info.memory.textures;\n      msTexts[4].textContent = '=== Render ===';\n      msTexts[5].textContent = 'Calls: ' + webglRenderer.info.render.calls;\n      msTexts[6].textContent = 'Triangles: ' + webglRenderer.info.render.triangles;\n      msTexts[7].textContent = 'Lines: ' + webglRenderer.info.render.lines;\n      msTexts[8].textContent = 'Points: ' + webglRenderer.info.render.points;\n    }\n  };\n};\n\nexport function RenderStatsWrapper() {\n  return {\n    domElement: document.createElement('div'),\n    update: (renderer: WebGLRenderer) => {}\n  };\n}\n\nconst Cls = settings.isDevelopment ? RendererStats : RenderStatsWrapper;\n\nexport default Cls;\n","import settings from '../settings';\nimport RendererStats from './render-stats';\n\nconst rendererStats = new RendererStats();\nif (settings.stats) {\n  rendererStats.domElement.style.position = 'absolute';\n  rendererStats.domElement.style.left = '0px';\n  rendererStats.domElement.style.top = '48px';\n  // if (document.body) document.body.appendChild(rendererStats.domElement);\n}\n\nexport { rendererStats };\n\nif (settings.stats) {\n  const stats = require('@jam3/stats')();\n  stats.domElement.style.cssText = 'position:fixed;left:0;top:0;z-index:10000';\n}\n","import { TweenLite } from 'gsap/gsap-core';\nimport { Mesh, RingBufferGeometry, ShaderMaterial } from 'three';\nimport BaseScene from '../base/base-scene';\nimport { TWO_PI, VECTOR_ZERO } from '../../utils/math';\nimport settings from '../../settings';\n\nexport const PRELOADER_SCENE_ID = 'preloader';\n\nexport default class PreloaderScene extends BaseScene {\n  constructor() {\n    super({ id: PRELOADER_SCENE_ID });\n    this.camera.position.set(0, 0, 10);\n    this.camera.lookAt(VECTOR_ZERO);\n  }\n\n  /**\n   * Create and setup any objects for the scene\n   *\n   * @memberof PreloaderScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        // Create a spinner mesh to show loading progression\n        this.spinner = new Mesh(\n          new RingBufferGeometry(0.9, 1, 32, 1, 0, TWO_PI * 0.75),\n          new ShaderMaterial({\n            transparent: true,\n            uniforms: {\n              opacity: { value: 0 }\n            },\n            vertexShader: `\n              varying vec2 vUv;\n              void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n              }\n            `,\n            fragmentShader: `\n              uniform float opacity;\n              varying vec2 vUv;\n              void main() {\n                gl_FragColor = vec4(vUv, 1.0, vUv.y * opacity);\n              }\n          `\n          })\n        );\n        this.spinner.name = 'spinner';\n        this.scene.add(this.spinner);\n        this.animateInit();\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  preloadGpuCullScene = (culled: boolean) => {\n    this.spinner.material.uniforms.opacity.value = culled ? 1 : 0;\n  };\n\n  animateInit = () => {\n    TweenLite.killTweensOf(this.spinner.material.uniforms.opacity);\n    this.spinner.material.uniforms.opacity.value = 0;\n  };\n\n  async animateIn() {\n    await new Promise((resolve, reject) => {\n      if (settings.skipTransitions) {\n        resolve();\n        return;\n      }\n      TweenLite.to(this.spinner.material.uniforms.opacity, 1, {\n        value: 1,\n        onComplete: () => {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async animateOut() {\n    await new Promise((resolve, reject) => {\n      if (settings.skipTransitions) {\n        resolve();\n        return;\n      }\n      TweenLite.to(this.spinner.material.uniforms.opacity, 1, {\n        value: 0,\n        onComplete: () => {\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Update loop\n   *\n   * @memberof PreloaderScene\n   */\n  update = (delta: number) => {\n    this.spinner.rotation.z -= delta * 2;\n  };\n}\n","/**\n * A class to manage the state of the webgl app\n *\n * @export\n * @class AppState\n */\nexport default class AppState {\n  ready: boolean;\n\n  constructor(props: Object = {}) {\n    this.ready = props.ready || false;\n  }\n\n  equals(state: AppState) {\n    return this.ready === state.ready;\n  }\n\n  clone() {\n    return new AppState({\n      ready: this.ready\n    });\n  }\n}\n","import { WebGLRenderTarget, LinearFilter, RGBAFormat, PerspectiveCamera } from 'three';\nimport { GUI } from 'dat.gui';\nimport { saveAs } from 'file-saver';\nimport createCanvas from './canvas';\nimport { rendererSize } from '../rendering/resize';\nimport renderer, { postProcessing } from '../rendering/renderer';\nimport BaseScene from '../scenes/base/base-scene';\n\nconst DEBUG_RENDER = false;\n\n/**\n * This screenshot utility renders out a custom size render and saves it to an image\n * Please note if the post processing passes change it will require updating\n *\n * @export\n * @class Screenshot\n */\nexport default class Screenshot {\n  gui: GUI;\n  renderTargetA: WebGLRenderTarget;\n  renderTargetB: WebGLRenderTarget;\n  imageData: ImageData;\n  canvas: HTMLCanvasElement;\n  canvasFlipped: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  ctxFlipped: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n  pixelBuffer: Uint8Array;\n\n  constructor(gui: GUI, width: number, height: number, pixelRatio: number = 1) {\n    this.gui = gui.addFolder('screenshot');\n    this.gui.open();\n    this.width = width * pixelRatio;\n    this.height = height * pixelRatio;\n\n    this.renderTargetA = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat,\n      stencilBuffer: false\n    });\n    this.renderTargetB = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat,\n      stencilBuffer: false\n    });\n\n    const { canvas, ctx } = createCanvas(this.width, this.height);\n    const { canvas: canvasFlipped, ctx: ctxFlipped } = createCanvas(this.width, this.height);\n\n    this.canvas = canvas;\n    this.canvasFlipped = canvasFlipped;\n    this.ctx = ctx;\n    this.ctxFlipped = ctxFlipped;\n\n    this.pixelBuffer = new Uint8Array(this.renderTargetA.width * this.renderTargetA.height * 4);\n    this.imageData = this.ctxFlipped.createImageData(this.canvas.width, this.canvas.height);\n\n    if (DEBUG_RENDER) {\n      Object.assign(this.canvas.style, {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        zIndex: '100',\n        border: '1px solid white',\n        pointerEvents: 'none',\n        width: `${width}px`,\n        height: `${height}px`\n      });\n      if (document.body) document.body.appendChild(this.canvas);\n    }\n  }\n\n  /**\n   * Save the canvas to an image\n   *\n   * @memberof Screenshot\n   */\n  save = () => {\n    // const quality = 0.75;\n    const filename = 'screenshot.png';\n    const format = 'image/png';\n    this.canvas.toBlob(\n      function(blob) {\n        saveAs(blob, filename);\n      },\n      format\n      // quality\n    );\n  };\n\n  /**\n   * Capture the current scene and save to an image\n   *\n   * @memberof Screenshot\n   */\n  capture = (scene: BaseScene, camera: PerspectiveCamera) => {\n    // Clear current context\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Save aspect for resetting after render\n    const aspect = camera.aspect;\n\n    // Update aspect to the screenshot size ratio\n    camera.aspect = this.width / this.height;\n    camera.updateProjectionMatrix();\n\n    // Save current width / height\n    const finalPassWidth = postProcessing.finalPass.mesh.material.uniforms.resolution.value.x;\n    const finalPassHeight = postProcessing.finalPass.mesh.material.uniforms.resolution.value.y;\n    const left = 0;\n    const bottom = 0;\n    const width = rendererSize.x;\n    const height = rendererSize.y;\n\n    // Update renderer viewport, this will get reset in the main render loop\n    // inside webgl-app.js\n    renderer.setViewport(left, bottom, width, height);\n    renderer.setScissor(left, bottom, width, height);\n\n    // Update the final pass uniforms\n    scene.resize(this.width, this.height);\n    postProcessing.finalPass.resize(this.width, this.height);\n\n    // Render the current scene into renderTargetA\n    renderer.setRenderTarget(this.renderTargetA);\n    renderer.render(scene.scene, camera);\n    renderer.setRenderTarget(null);\n\n    // Apply the post processing fx which is output into renderTargetB\n    postProcessing.finalPass.screenshotRender(scene.scene, camera, this.renderTargetA, this.renderTargetB, 0);\n    // Put the rendered pixels into the pixelBuffer\n    renderer.readRenderTargetPixels(\n      this.renderTargetB,\n      0,\n      0,\n      this.renderTargetB.width,\n      this.renderTargetB.height,\n      this.pixelBuffer\n    );\n    this.imageData.data.set(this.pixelBuffer);\n\n    // The image is rendered upside down, so we flip it\n    this.ctxFlipped.putImageData(this.imageData, 0, 0);\n    this.ctx.save();\n    this.ctx.scale(1, -1);\n    this.ctx.drawImage(this.canvasFlipped, 0, -this.canvas.height, this.canvas.width, this.canvas.height);\n    this.ctx.restore();\n\n    // Reset the camera aspect\n    camera.aspect = aspect;\n    camera.updateProjectionMatrix();\n\n    // Reset the finalpass uniforms\n    postProcessing.finalPass.resize(finalPassWidth, finalPassHeight);\n    scene.resize(finalPassWidth, finalPassHeight);\n\n    // Save out the image\n    this.save();\n  };\n\n  capture2(scene: BaseScene, camera: PerspectiveCamera) {\n    // Save aspect for resetting after render\n    // const aspect = camera.aspect;\n\n    // // Update aspect to the screenshot size ratio\n    // camera.aspect = this.width / this.height;\n    // camera.updateProjectionMatrix();\n\n    // // Save current width / height\n    // const finalPassWidth = postProcessing.finalPass.mesh.material.uniforms.resolution.value.x;\n    // const finalPassHeight = postProcessing.finalPass.mesh.material.uniforms.resolution.value.y;\n    // const left = 0;\n    // const bottom = 0;\n    // const width = rendererSize.x;\n    // const height = rendererSize.y;\n\n    // renderer.setSize(this.width, this.height);\n    // renderer.setViewport(left, bottom, this.width, this.height);\n    // renderer.setScissor(left, bottom, this.width, this.height);\n\n    // // Update the final pass uniforms\n    // scene.resize(this.width, this.height);\n\n    // // Render the current scene into renderTargetA\n    // renderer.render(scene.scene, camera);\n\n    // // Reset the camera aspect\n    // camera.aspect = aspect;\n    // camera.updateProjectionMatrix();\n\n    // // Reset the finalpass uniforms\n    // scene.resize(finalPassWidth, finalPassHeight);\n    // renderer.setSize(this.width, this.height);\n    // renderer.setViewport(left, bottom, width, height);\n    // renderer.setScissor(left, bottom, width, height);\n\n    const filename = 'screenshot.png';\n    const format = 'image/png';\n    renderer.domElement.toBlob(function(blob) {\n      saveAs(blob, filename);\n    }, format);\n  }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Clock, Vector4, PerspectiveCamera } from 'three';\nimport renderer, { postProcessing } from './rendering/renderer';\nimport { setRendererSize, rendererSize } from './rendering/resize';\nimport settings from './settings';\nimport { rendererStats } from './utils/stats';\nimport { setQuery, getQueryFromParams } from './utils/query-params';\nimport { gui } from './utils/gui';\nimport PreloaderScene, { PRELOADER_SCENE_ID } from './scenes/preloader/preloader-scene';\nimport AppState from './app-state';\nimport MainScene, { MAIN_SCENE_ID } from './scenes/main/main-scene';\nimport Screenshot from './utils/screenshot';\n\nclass WebGLApp extends EventEmitter {\n  /**\n   * Creates an instance of WebGLApp.\n   * @param {HTMLElement} parent\n   * @memberof WebGLApp\n   */\n  constructor(parent: HTMLElement) {\n    super();\n    // Append the renderer canvas to the component reference\n    parent.appendChild(renderer.domElement);\n\n    // Clock for elapsed time and delta\n    this.clock = new Clock(true);\n\n    // Current request animation frame id\n    this.rafId = 0;\n\n    // Current frame delta\n    this.delta = 0;\n\n    // Flag to prevent multiple raf's running\n    this.isRendering = false;\n\n    // Initial state\n    this.state = new AppState({ ready: false });\n\n    // Scenes map\n    this.scenes = {\n      [PRELOADER_SCENE_ID]: PreloaderScene,\n      [MAIN_SCENE_ID]: MainScene\n    };\n    // List of ids to switch between\n    const sceneIds = [MAIN_SCENE_ID];\n\n    // The target scene id\n    this.sceneId = MAIN_SCENE_ID;\n    if (sceneIds.includes(getQueryFromParams('sceneId'))) {\n      this.sceneId = getQueryFromParams('sceneId');\n    }\n\n    this.viewport = {\n      debug: new Vector4(\n        0,\n        0,\n        rendererSize.x * settings.viewportPreviewScale,\n        rendererSize.y * settings.viewportPreviewScale\n      ),\n      main: new Vector4(0, 0, rendererSize.x, rendererSize.y)\n    };\n\n    // Add screenshot utility\n    this.screenshot = new Screenshot(gui, 720, 1280, 2);\n    this.screenshot.gui.add(this, 'captureScreenshot').name('capture');\n\n    // Gui settings group\n    const guiSettings = gui.addFolder('settings');\n    guiSettings.open();\n\n    // Toggle between dev and scene camera\n    // guiSettings.add(settings, 'devCamera').onChange((value: string) => {\n    //   setQuery('devCamera', value);\n    //   postProcessing.resize();\n    //   this.currentScene.toogleCameras(value);\n    // });\n\n    // Toggle between dev and scene camera\n    guiSettings.add(settings, 'postProcessing').onChange((value: string) => {\n      setQuery('postProcessing', value);\n    });\n\n    // Toggle scene helpers\n    // guiSettings.add(settings, 'helpers').onChange((value: string) => {\n    //   setQuery('helpers', value);\n    //   this.currentScene.toggleHelpers(value);\n    // });\n\n    // Toggle between scenes\n    // guiSettings\n    //   .add(this, 'sceneId', sceneIds)\n    //   .onChange((value: string) => {\n    //     this.setScene(value);\n    //     setQuery('sceneId', value);\n    //   })\n    //   .listen();\n\n    guiSettings\n      .add(settings, 'renderBufferFullscreen')\n      .name('max resolution')\n      .onChange((value: boolean) => {\n        setQuery('hd', value);\n        this.resize(window.innerWidth, window.innerHeight);\n      });\n  }\n\n  captureScreenshot = () => {\n    this.screenshot.capture2(this.currentScene, this.currentScene.camera);\n  };\n\n  /**\n   * Setup any\n   *\n   * @memberof WebGLApp\n   */\n  async setup() {\n    await new Promise((resolve, reject) => {\n      try {\n        // Setup the preloader scene right away as we need a scene to render on page load\n        this.setScene(PRELOADER_SCENE_ID)\n          .then(resolve)\n          .catch(reject);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  // Set the new state\n  setState = (state: AppState) => {\n    if (state.equals(this.state)) return;\n    this.prevState = this.state.clone();\n    this.state = state;\n    this.onStateChanged(this.state);\n  };\n\n  onStateChanged = (state: AppState) => {\n    if (this.state.ready && this.state.ready !== this.prevState.ready) {\n      this.setScene(this.sceneId);\n    }\n  };\n\n  /**\n   * Set the current scene to render\n   * The scene should be inheritted from BaseScene\n   *\n   * @param {BaseScene} scene\n   * @memberof WebGLApp\n   */\n  async setScene(sceneId: string) {\n    await new Promise((resolve, reject) => {\n      if (this.currentScene && sceneId === this.currentScene.id) return;\n      // Create new scene instance\n      const scene = new this.scenes[sceneId]();\n      scene\n        .setup()\n        .then(() => {\n          // Cache the previous scene\n          const previousScene = this.currentScene;\n          // Callback when the previous scene has animated out\n          const nextScene = () => {\n            // Set the current scene\n            this.currentScene = scene;\n            this.currentScene.resize(rendererSize.x, rendererSize.y);\n            // Animate the scene in\n            this.currentScene.animateIn().then(resolve, reject);\n            // Update the post processing scene transition pass\n            postProcessing.setScenes(postProcessing.sceneB, scene);\n            postProcessing.transitionPass.transition().then(() => {\n              // After the transition has ended, dispose of any objects\n              if (previousScene) previousScene.dispose();\n            });\n          };\n          // If the previous scene exists, animate out\n          if (previousScene) {\n            previousScene\n              .animateOut()\n              .then(nextScene)\n              .catch(reject);\n          } else {\n            // Otherwise go to the next scene immediately\n            nextScene();\n          }\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * resize handler\n   *\n   * @memberof WebGLApp\n   */\n  resize = (width: number, height: number) => {\n    setRendererSize(renderer, width, height);\n    this.currentScene.resize(rendererSize.x, rendererSize.y);\n    postProcessing.resize();\n    this.viewport.debug.set(\n      0,\n      0,\n      rendererSize.x * settings.viewportPreviewScale,\n      rendererSize.y * settings.viewportPreviewScale\n    );\n    this.viewport.main.set(0, 0, rendererSize.x, rendererSize.y);\n  };\n\n  /**\n   * Render the scene within viewport coordinates\n   *\n   * @memberof WebGLApp\n   */\n  renderScene = (camera: PerspectiveCamera, viewport: Vector4, delta: number, usePostProcessing: boolean) => {\n    renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);\n    renderer.setScissor(viewport.x, viewport.y, viewport.z, viewport.w);\n\n    if (usePostProcessing) {\n      postProcessing.render(delta);\n    } else {\n      this.currentScene.update(this.delta);\n      renderer.setClearColor(this.currentScene.clearColor);\n      renderer.render(this.currentScene.scene, camera);\n    }\n  };\n\n  /**\n   * Toggle the rendering and animation loop\n   *\n   * @memberof WebGLApp\n   */\n  render = (render: boolean) => {\n    if (this.isRendering === render) return;\n    this.isRendering = render;\n    if (render) {\n      this.update();\n    } else {\n      cancelAnimationFrame(this.rafId);\n    }\n  };\n\n  /**\n   * Main render loop and update of animations\n   *\n   * @memberof WebGLApp\n   */\n  update = () => {\n    this.rafId = requestAnimationFrame(this.update);\n    this.delta = this.clock.getDelta();\n\n    if (settings.devCamera) {\n      this.renderScene(this.currentScene.cameras.dev, this.viewport.main, this.delta, false);\n      this.renderScene(this.currentScene.cameras.main, this.viewport.debug, this.delta, settings.postProcessing);\n    } else {\n      this.renderScene(this.currentScene.cameras.main, this.viewport.main, this.delta, settings.postProcessing);\n    }\n\n    if (settings.stats) {\n      rendererStats.update(renderer);\n    }\n  };\n}\n\nexport default WebGLApp;\n","import React from 'react';\nimport { TweenLite } from 'gsap/gsap-core';\nimport './App.css';\nimport WebGLApp from './webgl-app/webgl-app';\nimport AppState from './webgl-app/app-state';\n\ntype Props = {};\n\ntype State = {|\n  ready: boolean,\n  windowSize: { width: number, height: number }\n|};\n\nclass App extends React.PureComponent<Props, State> {\n  state = {\n    ready: false,\n    windowSize: { width: window.innerWidth, height: window.innerHeight }\n  };\n\n  componentDidMount() {\n    if (this.container === null) return;\n    this.webglApp = new WebGLApp(this.container);\n    this.webglApp\n      .setup()\n      .then(() => {\n        this.webglApp.setState(new AppState(this.state));\n        this.webglApp.render(true);\n        TweenLite.delayedCall(1, this.onReady);\n      })\n      .catch((error: String) => {\n        console.log(error);\n      });\n\n    window.addEventListener('resize', this.onResize);\n  }\n\n  componentDidUpdate(prevProps: Object, prevState: Object) {\n    if (this.container === null) return;\n\n    this.webglApp.setState(new AppState(this.state));\n\n    if (\n      this.state.windowSize.width !== prevState.windowSize.width ||\n      this.state.windowSize.height !== prevState.windowSize.height\n    ) {\n      // Resize the app\n      this.webglApp.resize(this.state.windowSize.width, this.state.windowSize.height);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.container === null) return;\n    this.webglApp.render(false);\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  container: HTMLElement | null;\n  webglApp: WebGLApp;\n\n  onReady = () => {\n    this.setState({\n      ready: true\n    });\n  };\n\n  onResize = () => {\n    this.setState({\n      windowSize: { width: window.innerWidth, height: window.innerHeight }\n    });\n  };\n\n  render() {\n    return (\n      <div\n        className=\"App\"\n        ref={(node: HTMLElement | null) => {\n          this.container = node;\n        }}\n      >\n        <div className=\"About\">\n          <p>\n            A simple{' '}\n            <a href=\"https://github.com/ameliemaia/raytracing-in-one-weekend\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Raytracer\n            </a>{' '}\n            based on <br />\n            <a href=\"https://raytracing.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Ray Tracing in One Weekend\n            </a>{' '}\n            <br />\n            by{' '}\n            <a href=\"https://twitter.com/Peter_shirley\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Peter Shirley\n            </a>\n          </p>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nconst root = document.getElementById('root');\nif (root) ReactDOM.render(<App />, root);\n"],"sourceRoot":""}
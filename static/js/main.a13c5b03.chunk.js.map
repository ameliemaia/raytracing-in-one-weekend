{"version":3,"sources":["webgl-app/utils/math.js","webgl-app/utils/query-params.js","webgl-app/rendering/graphics.js","webgl-app/settings.js","webgl-app/rendering/resize.js","webgl-app/rendering/render-target.js","webgl-app/rendering/post-processing/passes/transition-pass/shader.glsl.js","webgl-app/cameras/cameras.js","webgl-app/utils/gui.js","webgl-app/loading/asset.js","webgl-app/loading/loaders/loader.js","webgl-app/loading/loaders/image-loader.js","webgl-app/loading/loaders/json-loader.js","webgl-app/loading/loaders/three-texture-loader.js","webgl-app/loading/loaders/three-fbx-loader.js","webgl-app/loading/loaders/three-gltf-loader.js","webgl-app/loading/loaders/group-loader.js","webgl-app/loading/asset-loader.js","webgl-app/loading/asset-manager.js","webgl-app/scenes/base/base-scene.js","webgl-app/utils/dispose-objects.js","webgl-app/rendering/post-processing/passes/transition-pass/transition-pass.js","webgl-app/rendering/post-processing/passes/fxaa.glsl.js","webgl-app/rendering/post-processing/passes/final-pass/shader.glsl.js","webgl-app/rendering/post-processing/passes/final-pass/final-pass.js","webgl-app/scenes/empty/empty-scene.js","webgl-app/rendering/post-processing/passes/copy-pass/copy-pass.js","webgl-app/rendering/post-processing/passes/denoise-pass/denoise-pass.js","webgl-app/rendering/post-processing/passes/denoise-pass/shader.glsl.js","webgl-app/scenes/main/objects/raytracer/camera.glsl.js","webgl-app/scenes/main/objects/raytracer/sphere.glsl.js","webgl-app/scenes/main/objects/raytracer/hitables.glsl.js","webgl-app/scenes/main/objects/raytracer/material.glsl.js","webgl-app/scenes/main/objects/raytracer/world.glsl.js","webgl-app/scenes/main/objects/raytracer/raytracer.glsl.js","webgl-app/scenes/main/objects/raytracer/raytracer.js","webgl-app/scenes/main/main-scene.js","webgl-app/rendering/post-processing/post-processing.js","webgl-app/utils/geometry.js","webgl-app/utils/canvas.js","webgl-app/rendering/renderer.js","webgl-app/utils/render-stats.js","webgl-app/utils/stats.js","webgl-app/scenes/preloader/preloader-scene.js","webgl-app/app-state.js","webgl-app/utils/screenshot.js","webgl-app/webgl-app.js","App.js","index.js"],"names":["TWO_PI","Math","PI","VECTOR_ZERO","Vector3","VECTOR_ONE","Math3","queryString","require","getQueryFromParams","prop","params","parse","window","location","search","undefined","setQuery","query","val","reload","queries","newQueries","Object","assign","stringified","stringify","href","pathname","url","protocol","host","history","pushState","path","GRAPHICS_MODES","GRAPHICS_MODE","getGraphicsMode","gpuTier","getGPUTier","graphicsMode","includes","tier","profiler","antialias","pixelRatio","math","clamp","devicePixelRatio","maxFrameBufferSize","Vector2","settings","process","renderBufferFullscreen","postProcessing","graphics","baseSize","sqrt","x","y","maxSize","rendererSize","getRenderBufferSize","ratio","renderer","WebGLRenderer","getPixelRatio","width","height","setRendererSize","windowWidth","windowHeight","newSize","floor","scalar","resize","setSize","domElement","style","createRenderTarget","options","defaults","minFilter","LinearFilter","magFilter","NearestFilter","format","RGBFormat","type","UnsignedByteType","stencilBuffer","WebGLRenderTarget","resetCamera","camera","zoom","angle","position","set","z","lookAt","createPerspectiveCamera","aspect","PerspectiveCamera","createOrbitControls","OrbitControls","Folder","object","key","list","this","value","id","GUIWrapper","Cls","datGui","GUI","prototype","removeFolder","name","folder","__folders","close","__ul","removeChild","parentNode","onResize","gui","detect","device","isDesktop","Asset","config","Loader","EventEmitter","json","image","threeFBX","threeGLTF","threeTexture","ImageLoader","asset","load","Image","onload","data","emit","onerror","src","JsonLoader","req","XMLHttpRequest","onreadystatechange","readyState","status","JSON","responseText","open","send","ThreeTextureLoader","TextureLoader","texture","ThreeFBXLoader","FBXLoader","dracoLoader","DRACOLoader","setDecoderPath","baseUrl","preload","ThreeGLTFLoader","loader","GLTFLoader","setDRACOLoader","gltf","LOADERS","GroupLoader","manifest","loaders","forEach","push","loaded","queue","currentParallel","total","length","loadNextInQueue","parallelLoads","once","onLoaded","onError","assets","error","minParallel","maxParallel","args","on","response","group","groupId","all","find","BaseScene","preloadGpuCullScene","culled","toggleHelpers","visible","helpers","toogleCameras","devCamera","cameras","dev","main","control","controls","updateProjectionMatrix","update","delta","dispose","disposeObjects","parent","remove","geometry","material","children","i","l","scene","generateUUID","clearColor","lights","Scene","addFolder","guiOpen","light","add","Promise","resolve","reject","assetLoader","assetManager","Group","GridHelper","AxesHelper","loadAssets","createSceneHelpers","createSceneObjects","animate","TweenLite","TransitionPass","mesh","uniforms","resolution","render","sceneA","sceneB","renderTargetA","renderTargetB","setClearColor","setRenderTarget","texture0","texture1","active","ShaderMaterial","transition","vertexShader","fragmentShader","Mesh","matrixAutoUpdate","updateMatrix","onChange","listen","skipTransitions","killTweensOf","to","then","fxaaEnabled","fxaaResolution","FinalPass","UniformsUtils","merge","time","tDiffuse","fxaaUniforms","guiPass","fxaaGuiControls","renderTarget","EmptyScene","CopyPass","renderTargetCopy","toScreen","DenoisePass","reset","passes","tDiffusePrev","frameCount","maxPasses","renderTargetCurrent","renderTargetPrev","renderTargetCombined","worldSize","maxBounces","fov","seed","Vector4","random","cameraAspect","cameraAperture","cameraFocusDistance","cameraAutoFocus","cameraPosition","cameraTarget","sphere","hitables","world","Raytracer","createMaterial","getSceneShader","size","rebuild","target","setAperture","setFocusDistance","setAutoFocus","denoisePass","scenes","maxSpheres","gridSize","PlaneBufferGeometry","guiCamera","offset","grid","n","chooseMat","center","row","col","MathUtils","lerp","randFloat","distanceTo","createFinalScene","createSimpleScene","copy","MainScene","raytracer","addEventListener","PostProcessing","BufferGeometry","attribute","BufferAttribute","Float32Array","setAttribute","setIndex","bigTriangle","OrthographicCamera","RGBAFormat","renderTargetTransitionA","renderTargetTransitionB","renderTargetDenoise","renderTargetDenoisePrev","renderTargetDenoiseCombined","transitionPass","finalPass","copyPass","setup","setScenes","pauseRendering","currentScene","lastPass","createCanvas","canvas","document","createElement","ctx","getContext","powerPreference","stencil","preserveDrawingBuffer","WEBGL","isWebGL2Available","context","outputEncoding","sRGBEncoding","debug","checkShaderErrors","isDevelopment","guiRendering","setPixelRatio","setScissorTest","innerWidth","innerHeight","gl","gpuInfo","getExtension","gpu","getParameter","UNMASKED_RENDERER_WEBGL","console","log","rendererStats","container","cssText","msDiv","appendChild","msText","innerHTML","msTexts","lastTime","Date","now","webglRenderer","assert","textContent","info","programs","memory","geometries","textures","calls","triangles","lines","points","stats","left","top","PreloaderScene","spinner","opacity","animateInit","rotation","RingBufferGeometry","transparent","onComplete","AppState","props","ready","state","Screenshot","save","toBlob","blob","saveAs","capture","clearRect","finalPassWidth","finalPassHeight","setViewport","setScissor","screenshotRender","readRenderTargetPixels","pixelBuffer","imageData","ctxFlipped","putImageData","scale","drawImage","canvasFlipped","restore","Uint8Array","createImageData","WebGLApp","captureScreenshot","screenshot","capture2","setState","equals","prevState","clone","onStateChanged","setScene","sceneId","viewport","viewportPreviewScale","renderScene","usePostProcessing","w","isRendering","cancelAnimationFrame","rafId","requestAnimationFrame","clock","getDelta","Clock","sceneIds","guiSettings","maxRatio","catch","previousScene","nextScene","animateIn","animateOut","App","windowSize","onReady","webglApp","delayedCall","prevProps","removeEventListener","className","ref","node","rel","React","PureComponent","root","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.a13c5b03.chunk.js","sourcesContent":["import { Math as Math3, Vector3 } from 'three';\n\n// Math constants that are regularly used\nexport const TWO_PI = Math.PI * 2;\nexport const PI = Math.PI;\nexport const HALF_PI = Math.PI / 2;\nexport const QUARTER_PI = Math.PI / 4;\nexport const VECTOR_ZERO = new Vector3();\nexport const VECTOR_ONE = new Vector3(1, 1, 1);\nexport const VECTOR_UP = new Vector3(0, 1, 0);\n\nexport default Math3;\n","const queryString = require('query-string');\n\n/**\n * Get a query parameter\n *\n * @export\n * @param {String} prop\n * @returns\n */\nexport function getQueryFromParams(prop: string): mixed {\n  const params = queryString.parse(window.location.search);\n  return params[prop] !== undefined ? params[prop] : false;\n}\n\n/**\n * Set a query parmeter\n *\n * @export\n * @param {String} query\n * @param {String} val\n * @param {boolean} [reload=false]\n * @returns\n */\nexport function setQuery(query: string, val: string, reload: boolean = false) {\n  const queries = queryString.parse(window.location.search);\n  const newQueries = Object.assign({}, queries, {\n    [query]: val\n  });\n  const stringified = queryString.stringify(newQueries);\n\n  if (reload) {\n    window.location.href = `${window.location.pathname}?${stringified}`;\n    return;\n  }\n  const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?${stringified}`;\n  window.history.pushState({ path: url }, '', url);\n}\n","import { getGPUTier } from 'detect-gpu';\nimport { Vector2 } from 'three';\nimport math from '../utils/math';\nimport { getQueryFromParams } from '../utils/query-params';\n\n// Graphics mode constants\nexport const GRAPHICS_HIGH = 'high';\nexport const GRAPHICS_NORMAL = 'normal';\nexport const GRAPHICS_MODES = [GRAPHICS_HIGH, GRAPHICS_NORMAL];\n\nlet GRAPHICS_MODE = GRAPHICS_NORMAL;\n\n/**\n * Get the current graphics mode\n *\n * @export\n * @returns\n */\nexport function getGraphicsMode(): string {\n  return GRAPHICS_MODE;\n}\n\nconst gpuTier = getGPUTier();\n\nexport function profiler(): string {\n  switch (gpuTier.tier) {\n    case 'GPU_DESKTOP_TIER_3':\n    case 'GPU_DESKTOP_TIER_2':\n    case 'GPU_MOBILE_TIER_3':\n      return GRAPHICS_HIGH;\n    case 'GPU_DESKTOP_TIER_1':\n    default:\n      return GRAPHICS_NORMAL;\n  }\n}\n\n// If the graphics query parameter is set, use it over the current gpu tier\nconst graphicsMode = getQueryFromParams('graphics');\nif (GRAPHICS_MODES.includes(graphicsMode) && typeof graphicsMode === 'string') {\n  GRAPHICS_MODE = graphicsMode;\n} else {\n  GRAPHICS_MODE = profiler();\n}\n\nexport function getTier(): string {\n  return gpuTier.tier;\n}\n\n// Graphics settings for the renderer\nexport default {\n  [GRAPHICS_HIGH]: {\n    antialias: false, // Enable antialias if you're not using post processing\n    pixelRatio: getQueryFromParams('hd') === 'true' ? math.clamp(window.devicePixelRatio, 1, 2) : 1,\n    maxFrameBufferSize: new Vector2(1280, 720)\n  },\n  [GRAPHICS_NORMAL]: {\n    antialias: false,\n    pixelRatio: 1,\n    maxFrameBufferSize: new Vector2(1280, 720)\n  }\n};\n","import { getQueryFromParams } from './utils/query-params';\n\nconst settings = {};\n\n// Enviroment setting\nsettings.isDevelopment = process.env.NODE_ENV !== 'production';\n\n// Base url\nsettings.baseUrl = process.env.PUBLIC_URL || '';\n\n// Show fps stats\nsettings.stats = true; //getQueryFromParams('stats') === null;\n\n// Enable dev camera rendering\nsettings.devCamera = false; //getQueryFromParams('devCamera') === 'true';\n\n// Enable helpers\nsettings.helpers = false; //getQueryFromParams('helpers') === 'true';\n\n// Enable dat gui\nsettings.datGui = true; //getQueryFromParams('gui') === null;\n\n// Skips all transitions\nsettings.skipTransitions = false; //getQueryFromParams('skipTransitions') === null;\n\n// GUI Number precision\nsettings.guiPrecision = 0.001;\n\n// Viewport preview scale (when using devCamera)\nsettings.viewportPreviewScale = 0.25;\n\n// Unlock full render size (should be false for prod)\nsettings.renderBufferFullscreen = getQueryFromParams('hd') === 'true' || false;\n\nsettings.postProcessing = true;\n\nexport default settings;\n","import { Vector2, WebGLRenderer } from 'three';\nimport graphics, { getGraphicsMode } from './graphics';\nimport settings from '../settings';\nimport renderer from './renderer';\n\nconst { maxFrameBufferSize, pixelRatio } = graphics[getGraphicsMode()];\n\nconst baseSize = Math.sqrt(maxFrameBufferSize.x * maxFrameBufferSize.y);\nconst maxSize = baseSize * baseSize;\n\nexport const rendererSize = new Vector2();\n\nexport function getRenderBufferSize(): { width: number, height: number } {\n  let ratio = pixelRatio;\n\n  if (renderer instanceof WebGLRenderer) {\n    ratio = renderer.getPixelRatio();\n  }\n\n  return {\n    width: rendererSize.x * ratio,\n    height: rendererSize.y * ratio\n  };\n}\n\nfunction resize(windowWidth: number, windowHeight: number): { width: number, height: number } {\n  let width = windowWidth;\n  let height = windowHeight;\n  if (windowWidth * windowHeight > maxSize) {\n    const ratio = height / width;\n    width = baseSize;\n    height = Math.floor(baseSize * ratio);\n    let newSize = width * height;\n    const scalar = Math.sqrt(maxSize / newSize);\n    width = Math.floor(width * scalar);\n    height = Math.floor(height * scalar);\n  }\n  return {\n    width,\n    height\n  };\n}\n\nconst screenshot = false;\nconst isPortrait = false;\n\nexport function setRendererSize(renderer: WebGLRenderer, windowWidth: number, windowHeight: number) {\n  let { width, height } = resize(windowWidth, windowHeight);\n  if (settings.renderBufferFullscreen) {\n    width = windowWidth;\n    height = windowHeight;\n  }\n\n  if (screenshot) {\n    width = maxFrameBufferSize.x;\n    height = maxFrameBufferSize.y;\n  }\n\n  rendererSize.x = isPortrait ? height : width;\n  rendererSize.y = isPortrait ? width : height;\n  renderer.setSize(rendererSize.x, rendererSize.y);\n\n  if (!screenshot) {\n    renderer.domElement.style.width = `${windowWidth}px`;\n    renderer.domElement.style.height = `${windowHeight}px`;\n  }\n}\n","import { WebGLRenderTarget, LinearFilter, NearestFilter, RGBFormat, UnsignedByteType } from 'three';\n\nexport function createRenderTarget(width: number = 1024, height: number = 1024, options: Object = {}) {\n  const defaults = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBFormat,\n    type: UnsignedByteType,\n    stencilBuffer: false\n  };\n  return new WebGLRenderTarget(width, height, Object.assign({}, defaults, options));\n}\n","export const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform sampler2D texture0;\n  uniform sampler2D texture1;\n  uniform float transition;\n  uniform vec2 resolution;\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(texture0, uv);\n    vec4 texel1 = texture2D(texture1, uv);\n    gl_FragColor = mix(texel0, texel1, transition);\n  }\n`;\n","import { PerspectiveCamera, Vector3 } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport renderer from '../rendering/renderer';\nimport { VECTOR_ZERO, VECTOR_ONE } from '../utils/math';\n\n// Perspective camera defaults\nexport const FOV = 65;\nconst near = 0.1;\nconst far = 1000;\n\n/**\n * Reset the camera position\n *\n * @export\n * @param {PerspectiveCamera} camera\n * @param {number} [zoom=1]\n * @param {Vector3} [angle=VECTOR_ONE]\n */\nexport function resetCamera(camera: PerspectiveCamera, zoom: number = 1, angle: Vector3 = VECTOR_ONE) {\n  camera.position.set(angle.x * zoom, angle.y * zoom, angle.z * zoom);\n  camera.lookAt(VECTOR_ZERO);\n}\n\n/**\n * Utility for creating a perspective camera\n *\n * @export\n * @returns\n */\nexport function createPerspectiveCamera(aspect: number): PerspectiveCamera {\n  return new PerspectiveCamera(FOV, aspect, near, far);\n}\n\n/**\n * Utility for creating orbit controls\n *\n * @export\n * @param {PerspectiveCamera} camera\n * @returns\n */\nexport function createOrbitControls(camera: PerspectiveCamera): OrbitControls {\n  return new OrbitControls(camera, renderer.domElement);\n}\n","import detect from '@jam3/detect';\nimport settings from '../settings';\n\n/**\n * @class Folder\n */\nclass Folder {\n  add(object: any, key: string, list?: mixed[]) {\n    return this;\n  }\n  listen() {\n    return this;\n  }\n  name() {\n    return this;\n  }\n  open() {\n    return this;\n  }\n  close() {\n    return this;\n  }\n  onChange(value: mixed) {\n    return this;\n  }\n  addFolder(id: string) {\n    return this;\n  }\n  addColor() {\n    return this;\n  }\n  removeFolder(id: string) {\n    return this;\n  }\n  remove() {\n    return this;\n  }\n  step() {\n    return this;\n  }\n}\n\n/**\n * @class GUIWrapper\n */\nclass GUIWrapper {\n  static toggleHide() {\n    return this;\n  }\n  add(object: any, key: string, list?: mixed[]) {\n    return this;\n  }\n  addFolder(id: string) {\n    return new Folder();\n  }\n  removeFolder(id: string) {\n    return this;\n  }\n  addColor() {\n    return this;\n  }\n  listen() {\n    return this;\n  }\n  name() {\n    return this;\n  }\n  close() {\n    return this;\n  }\n  step() {\n    return this;\n  }\n  onChange(value: mixed) {\n    return this;\n  }\n  setValue() {\n    return this;\n  }\n  remove() {\n    return this;\n  }\n  open() {\n    return this;\n  }\n}\n\nlet Cls = GUIWrapper;\n\nif (settings.datGui) {\n  Cls = require('dat.gui').GUI;\n\n  Cls.prototype.removeFolder = function(name) {\n    var folder = this.__folders[name];\n    if (!folder) {\n      return;\n    }\n    folder.close();\n    this.__ul.removeChild(folder.domElement.parentNode);\n    delete this.__folders[name];\n    this.onResize();\n  };\n}\n\nexport const gui = new Cls();\nexport { GUIWrapper };\n\nif (!detect.device.isDesktop) {\n  // Cls.toggleHide();\n  gui.close();\n}\n","/**\n *\n *\n * @interface AssetConfig\n */\nexport interface AssetConfig {\n  id: string;\n  src: string;\n  type: string;\n  args?: Object;\n  data?: mixed;\n}\n\n/**\n *\n *\n * @export\n * @class Asset\n */\nexport default class Asset {\n  id: string;\n  src: string;\n  type: string;\n  args: Object;\n  data: mixed;\n  constructor(config: AssetConfig) {\n    Object.assign(this, config);\n  }\n}\n","import EventEmitter from 'eventemitter3';\nimport Asset from '../asset';\n\n/**\n * Base loader\n *\n * @class Loader\n * @extends {EventEmitter}\n */\nclass Loader extends EventEmitter {\n  asset: Asset;\n  static json: string = 'json';\n  static image: string = 'image';\n  static threeFBX: string = 'fbx';\n  static threeGLTF: string = 'gltf';\n  static threeTexture: string = 'texture';\n}\n\nexport default Loader;\n","import Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Image Loader\n *\n * @export\n * @class ImageLoader\n * @extends {Loader}\n */\nexport default class ImageLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const image = new Image();\n\n    image.onload = () => {\n      this.asset.data = image;\n      this.emit('loaded', this.asset);\n    };\n\n    image.onerror = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    image.src = this.asset.src;\n  };\n}\n","import Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Json loader\n *\n * @export\n * @class JsonLoader\n * @extends {Loader}\n */\nexport default class JsonLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const req = new XMLHttpRequest();\n\n    req.onreadystatechange = () => {\n      if (req.readyState !== 4) return;\n      if (req.readyState === 4 && req.status === 200) {\n        this.asset.data = JSON.parse(req.responseText);\n        this.emit('loaded', this.asset);\n      } else {\n        this.emit('error', `Failed to load ${this.asset.src}`);\n      }\n    };\n\n    req.open('GET', this.asset.src, true);\n    req.send();\n  };\n}\n","import { TextureLoader, Texture } from 'three';\nimport Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Threejs texture loader\n *\n * @export\n * @class ThreeTextureLoader\n * @extends {Loader}\n */\nexport default class ThreeTextureLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new TextureLoader();\n\n    const onLoaded = (texture: Texture) => {\n      this.asset.data = texture;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';\nimport Loader from './loader';\nimport Asset from '../asset';\n\n/**\n * Threejs FBX Loader\n *\n * @export\n * @class ThreeFBXLoader\n * @extends {Loader}\n */\nexport default class ThreeFBXLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new FBXLoader();\n\n    const onLoaded = (data: Object) => {\n      this.asset.data = data;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';\nimport Loader from './loader';\nimport Asset from '../asset';\nimport settings from '../../settings';\n\n// Use the draco loader for gltf if the glb file is compressed with draco\nconst dracoLoader = new DRACOLoader();\ndracoLoader.setDecoderPath(`${settings.baseUrl}/assets/lib/draco/gltf/`);\ndracoLoader.preload();\n\n/**\n * Threejs GLTF Loader\n *\n * @export\n * @class ThreeGLTFLoader\n * @extends {Loader}\n */\nexport default class ThreeGLTFLoader extends Loader {\n  constructor(asset: Asset) {\n    super();\n    this.asset = asset;\n  }\n\n  load = () => {\n    const loader = new GLTFLoader();\n    loader.setDRACOLoader(dracoLoader);\n\n    const onLoaded = (gltf: Object) => {\n      this.asset.data = gltf;\n      this.emit('loaded', this.asset);\n    };\n\n    const onError = () => {\n      this.emit('error', `Failed to load ${this.asset.src}`);\n    };\n\n    loader.load(this.asset.src, onLoaded, null, onError);\n  };\n}\n","import EventEmitter from 'eventemitter3';\nimport detect from '@jam3/detect';\nimport Asset from '../asset';\nimport Loader from './loader';\nimport ImageLoader from './image-loader';\nimport JsonLoader from './json-loader';\nimport ThreeTextureLoader from './three-texture-loader';\nimport ThreeFBXLoader from './three-fbx-loader';\nimport ThreeGLTFLoader from './three-gltf-loader';\n\nconst LOADERS = {\n  [Loader.image]: ImageLoader,\n  [Loader.json]: JsonLoader,\n  [Loader.threeTexture]: ThreeTextureLoader,\n  [Loader.threeFBX]: ThreeFBXLoader,\n  [Loader.threeGLTF]: ThreeGLTFLoader\n};\n\n/**\n * Group loader loads an array of assets based on their asset types\n *\n * @export\n * @class GroupLoader\n * @extends {EventEmitter}\n */\nexport default class GroupLoader extends EventEmitter {\n  constructor(options: Object = {}) {\n    super();\n    this.id = options.id || '';\n    this.minParallel = options.minParallel || 5;\n    this.maxParallel = options.maxParallel || 10;\n    // How many parallel loads at once\n    this.parallelLoads = detect.device.isDesktop ? this.maxParallel : this.minParallel;\n  }\n\n  load = (manifest: Asset[]) => {\n    this.loaders = [];\n\n    manifest.forEach(asset => {\n      if (LOADERS[asset.type] !== undefined) {\n        this.loaders.push(new LOADERS[asset.type](asset));\n      }\n    });\n\n    this.loaded = 0;\n    this.queue = 0;\n    this.currentParallel = 0;\n    this.total = this.loaders.length;\n\n    if (this.total === 0) {\n      this.emit('loaded', manifest);\n    } else {\n      this.loadNextInQueue();\n    }\n  };\n\n  /**\n   * Load the next in queue\n   *\n   * @memberof GroupLoader\n   */\n  loadNextInQueue = () => {\n    if (this.queue < this.total) {\n      if (this.currentParallel < this.parallelLoads) {\n        const loader = this.loaders[this.queue];\n        this.queue += 1;\n        this.currentParallel += 1;\n        loader.once('loaded', this.onLoaded);\n        loader.once('error', this.onError);\n        loader.load();\n        this.loadNextInQueue();\n      }\n    }\n  };\n\n  /**\n   * Loaded handler\n   *\n   * @memberof GroupLoader\n   */\n  onLoaded = () => {\n    this.loaded += 1;\n    // console.log(`${this.id} loaded`, this.loaded, '/', this.total);\n    this.emit('progress', this.loaded / this.total);\n    if (this.loaded === this.total) {\n      const assets = [];\n      this.loaders.forEach((loader: Loader) => {\n        assets.push(loader.asset);\n      });\n      this.emit('loaded', assets);\n    } else {\n      this.currentParallel -= 1;\n      this.loadNextInQueue();\n    }\n  };\n\n  /**\n   * Error handler\n   *\n   * @memberof GroupLoader\n   */\n  onError = (error: string) => {\n    this.emit('error', error);\n  };\n}\n","import EventEmitter from 'eventemitter3';\nimport Asset from './asset';\nimport GroupLoader from './loaders/group-loader';\n\n/**\n * Assetloader configures an instance of GroupLoader\n * and should be used for loading any asset groups for the asset manager\n *\n * @class AssetLoader\n * @extends {EventEmitter}\n */\nclass AssetLoader extends EventEmitter {\n  load = (id: string, assets: Asset[]) => {\n    const loader = new GroupLoader({ id });\n    assets.forEach(asset => {\n      if (asset.args === undefined) asset.args = {};\n    });\n\n    loader.on('progress', response => {\n      this.emit('progress', response);\n    });\n\n    loader.once('loaded', response => {\n      this.emit('loaded', response);\n    });\n\n    loader.once('error', error => {\n      this.emit('error', error);\n    });\n\n    loader.load(assets);\n  };\n}\n\nexport default new AssetLoader();\n","import Asset from './asset';\n\n/**\n * Asset manager's purpose is to store loaded assets by the AssetLoader\n * Assets can be retrived by using the get() function\n *\n * @class AssetManager\n */\nclass AssetManager {\n  assets: Object;\n\n  constructor() {\n    this.assets = {};\n  }\n\n  /**\n   * Add an asset group\n   *\n   * @param {String} group\n   * @param {Asset[]} assets\n   * @memberof AssetManager\n   */\n  add(group: String, assets: Asset[]) {\n    this.assets[group] = this.assets[group] || [];\n    this.assets[group].push(...assets);\n  }\n\n  /**\n   * Retrieve an asset by id\n   *\n   * @param {String} groupId\n   * @param {String} id\n   * @param {Boolean} [all=false]\n   * @returns\n   * @memberof AssetManager\n   */\n  get(groupId: string, id: string, all: boolean = false): boolean | mixed {\n    // console.log('groupId', groupId, 'id', id);\n    const asset = this.find(this.assets[groupId], id);\n    if (asset && asset instanceof Asset) {\n      return all ? asset : asset.data;\n    }\n    return false;\n  }\n\n  /**\n   * Find an asset by id\n   *\n   * @param {Asset[]} assets\n   * @param {String} id\n   * @returns\n   * @memberof AssetManager\n   */\n  find(assets: Asset[], id: string): boolean | Asset {\n    return assets.find(asset => asset.id === id) || false;\n  }\n}\n\nexport default new AssetManager();\n","// @flow\n\nimport EventEmitter from 'eventemitter3';\nimport { Scene, Group, GridHelper, AxesHelper } from 'three';\nimport { createPerspectiveCamera, createOrbitControls, resetCamera } from '../../cameras/cameras';\nimport { gui, GUIWrapper } from '../../utils/gui';\nimport Math3 from '../../utils/math';\nimport settings from '../../settings';\nimport { rendererSize } from '../../rendering/resize';\n// import preloadGpu from '../../rendering/preload-gpu';\nimport assetLoader from '../../loading/asset-loader';\nimport assetManager from '../../loading/asset-manager';\nimport Asset from '../../loading/asset';\nimport disposeObjects from '../../utils/dispose-objects';\n\n/**\n * A base scene for other scenes to inherit\n * It's main purpose is to abtract a lot of boilerplate code and serves\n * as a pattern for working with multiple scenes in a project\n *\n * @export\n * @class BaseScene\n * @extends {EventEmitter}\n */\nexport default class BaseScene extends EventEmitter {\n  constructor(options: Object) {\n    super();\n    // Unique scene id\n    this.id = options.id || Math3.generateUUID();\n    // Clear color for the scene\n    this.clearColor = options.clearColor || 0x000000;\n    // Array of lights to add to the scene\n    this.lights = options.lights || [];\n    // Assets manifest\n    this.assets = options.assets || [];\n    // The scene for objects\n    this.scene = new Scene();\n\n    // The cameras for rendering\n    this.cameras = {\n      dev: createPerspectiveCamera(rendererSize.x / rendererSize.y),\n      main: createPerspectiveCamera(rendererSize.x / rendererSize.y)\n    };\n\n    // Active rendering camera\n    this.camera = settings.devCamera ? this.cameras.dev : this.cameras.main;\n\n    // Set the initial camera positions\n    resetCamera(this.cameras.dev, 5);\n    resetCamera(this.cameras.main, 5);\n\n    // Orbit controls\n    this.controls = {};\n\n    // Optionally create orbit controls for main camera\n    if (options.controls) {\n      this.controls.dev = createOrbitControls(this.cameras.dev);\n      this.controls.main = createOrbitControls(this.cameras.main);\n    }\n\n    // Active camera control\n    this.control = settings.devCamera ? this.controls.dev : this.controls.main;\n\n    // Optionally create gui controls\n    if (options.gui) {\n      this.gui = gui.addFolder(`${this.id} scene`);\n      if (options.guiOpen) this.gui.open();\n    } else {\n      this.gui = new GUIWrapper();\n    }\n\n    // Add any lights to the scene\n    this.lights.forEach(light => {\n      this.scene.add(light.light);\n      light.gui(this.gui);\n    });\n  }\n\n  /**\n   *\n   *\n   * @memberof BaseScene\n   */\n  async loadAssets() {\n    await new Promise((resolve, reject) => {\n      try {\n        if (this.assets.length > 0) {\n          assetLoader.once('loaded', (response: Asset[]) => {\n            if (response.length > 0) assetManager.add(this.id, response);\n            resolve();\n          });\n          assetLoader.once('error', error => {\n            reject(error);\n          });\n          assetLoader.load(this.id, this.assets);\n        } else {\n          resolve();\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to setup any helpers for the scene\n   *\n   * @memberof BaseScene\n   */\n  async createSceneHelpers() {\n    await new Promise((resolve: Function, reject: Function) => {\n      try {\n        // Add helpers\n        this.helpers = new Group();\n        this.helpers.add(new GridHelper(10, 10), new AxesHelper());\n        this.helpers.visible = settings.helpers;\n        this.scene.add(this.helpers);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to setup any 3d objects once overridden\n   *\n   * @memberof BaseScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Use this function to show any materials or objects that can't be seen\n   * using the visible flag inside preloadGpu\n   * An example of this could be a materials alpha is set to 0\n   *\n   * @memberof BaseScene\n   */\n  preloadGpuCullScene = (culled: boolean) => {};\n\n  /**\n   * Setup is used to create any 3D objects\n   * and pre-upload them to the GPU to ensure smooth transitions when rendering\n   *\n   * @memberof BaseScene\n   */\n  async setup() {\n    await this.loadAssets();\n    await this.createSceneHelpers();\n    await this.createSceneObjects();\n    // this.preloadGpuCullScene(true);\n    // preloadGpu(this.scene, this.camera);\n    // this.preloadGpuCullScene(false);\n  }\n\n  /**\n   * Toggle helpers on and off\n   *\n   * @memberof BaseScene\n   */\n  toggleHelpers = (visible: boolean = true) => {\n    this.helpers.visible = visible;\n  };\n\n  /**\n   * Toggle helpers on and off\n   *\n   * @memberof BaseScene\n   */\n  toogleCameras = (devCamera: boolean = true) => {\n    this.camera = devCamera ? this.cameras.dev : this.cameras.main;\n    this.control = devCamera ? this.controls.dev : this.controls.main;\n  };\n\n  /**\n   * Resize the camera's projection matrix\n   *\n   * @memberof BaseScene\n   */\n  resize = (width: number, height: number) => {\n    this.cameras.dev.aspect = width / height;\n    this.cameras.dev.updateProjectionMatrix();\n    this.cameras.main.aspect = width / height;\n    this.cameras.main.updateProjectionMatrix();\n  };\n\n  /**\n   * Provide a promise after the scene has animated in\n   *\n   * @memberof BaseScene\n   */\n  async animateIn() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Provide a promise after the scene has animated out\n   *\n   * @memberof BaseScene\n   */\n  async animateOut() {\n    await new Promise((resolve, reject) => {\n      try {\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Update loop for animation, override this function\n   *\n   * @memberof BaseScene\n   */\n  update = (delta: number) => {};\n\n  /**\n   * Clear up scene objects\n   *\n   * @memberof BaseScene\n   */\n  dispose = () => {\n    disposeObjects(this.scene, null);\n    if (this.gui) gui.removeFolder(this.gui.name);\n  };\n}\n","import { Object3D, Scene } from 'three';\n\n/**\n * Recursively dispose threejs objects\n *\n * @export\n * @param {Object3D} object\n * @param {(Scene | Object3D)} parent\n * @returns\n */\nexport default function disposeObjects(object: Scene | Object3D, parent: Scene | Object3D) {\n  if (object === null || object === undefined) return;\n  if (parent) parent.remove(object);\n  if (object.dispose && object.type !== 'Scene') {\n    object.dispose();\n  }\n  if (object.geometry) {\n    object.geometry.dispose();\n  }\n  if (object.material) {\n    object.material.dispose();\n  }\n  if (object.children) {\n    let i = 0;\n    const l = object.children.length;\n    while (i < l) {\n      disposeObjects(object.children[0], object);\n      i++;\n    }\n  }\n  object = null;\n}\n","import { Scene, Mesh, ShaderMaterial, Vector2, BufferGeometry, OrthographicCamera, WebGLRenderTarget } from 'three';\nimport { TweenLite } from 'gsap';\nimport { GUI } from 'dat.gui';\nimport { vertexShader, fragmentShader } from './shader.glsl';\nimport { getRenderBufferSize } from '../../../resize';\nimport renderer from '../../../renderer';\nimport BaseScene from '../../../../scenes/base/base-scene';\nimport settings from '../../../../settings';\nimport EventEmitter from 'eventemitter3';\nconst animate = require('gsap-promisify')(Promise, TweenLite);\n\n/**\n * Transition pass handles transitioning between two scenes\n *\n * @export\n * @class TransitionPass\n */\nexport default class TransitionPass extends EventEmitter {\n  gui: GUI;\n  scene: Scene;\n  camera: OrthographicCamera;\n  active: boolean;\n  mesh: Mesh;\n\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    super();\n    // Create gui\n    this.gui = gui.addFolder('transition pass');\n    this.gui.close();\n    // Create scene\n    this.scene = new Scene();\n    this.camera = camera;\n    this.active = false;\n    const { width, height } = getRenderBufferSize();\n    // Setup shader\n    const material = new ShaderMaterial({\n      uniforms: {\n        texture0: {\n          value: null\n        },\n        texture1: {\n          value: null\n        },\n        transition: {\n          value: 0\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader,\n      fragmentShader\n    });\n\n    // Create the mesh and turn off matrixAutoUpdate\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n\n    // Setup gui\n    this.gui\n      .add(this.mesh.material.uniforms.transition, 'value', 0, 1)\n      .onChange((value: number) => {\n        this.active = value !== 0 && value !== 1;\n      })\n      .name('transition')\n      .listen();\n  }\n\n  /**\n   * Transition activates this pass and blends from sceneA to sceneB\n   *\n   * @memberof TransitionPass\n   */\n  async transition() {\n    if (settings.skipTransitions) {\n      this.mesh.material.uniforms.transition.value = 1;\n    } else {\n      this.mesh.material.uniforms.transition.value = 0;\n      this.active = true;\n      TweenLite.killTweensOf(this.mesh.material.uniforms.transition);\n      await animate\n        .to(this.mesh.material.uniforms.transition, 1, {\n          value: 1\n        })\n        .then(() => {\n          this.active = false;\n          this.emit('complete');\n        });\n    }\n  }\n\n  /**\n   * Resize handler\n   *\n   * @param {Number} width\n   * @param {Number} height\n   * @memberof TransitionPass\n   */\n  resize = (width: number, height: number) => {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n  };\n\n  /**\n   * Render both scenes to renderTargetA and renderTargetB\n   *\n   * @param {BaseScene} sceneA\n   * @param {BaseScene} sceneB\n   * @param {WebGLRenderTarget} renderTargetA\n   * @param {WebGLRenderTarget} renderTargetB\n   * @param {Number} delta\n   * @memberof TransitionPass\n   */\n  render = (\n    sceneA: BaseScene,\n    sceneB: BaseScene,\n    renderTargetA: WebGLRenderTarget,\n    renderTargetB: WebGLRenderTarget,\n    delta: number\n  ) => {\n    sceneA.update(delta);\n    sceneB.update(delta);\n    renderer.setClearColor(sceneA.clearColor);\n    renderer.setRenderTarget(renderTargetA);\n    renderer.render(sceneA.scene, sceneA.camera);\n    renderer.setClearColor(sceneB.clearColor);\n    renderer.setRenderTarget(renderTargetB);\n    renderer.render(sceneB.scene, sceneB.camera);\n    this.mesh.material.uniforms.texture0.value = renderTargetA.texture;\n    this.mesh.material.uniforms.texture1.value = renderTargetB.texture;\n    renderer.setRenderTarget(null);\n  };\n}\n","import { Vector2, Material } from 'three';\nimport { GUI } from 'dat.gui';\n\nexport const uniforms = {\n  fxaaEnabled: { value: 1 },\n  fxaaResolution: { value: new Vector2(1 / 1024, 1 / 512) }\n};\n\nexport const fragmentUniforms = `\n  precision highp float;\n  uniform bool fxaaEnabled;\n  uniform vec2 fxaaResolution;\n  varying vec2 vUv;\n`;\n\nexport const fragmentPass = `\n  // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n  //----------------------------------------------------------------------------------\n  // File:        es3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n  // SDK Version: v3.00\n  // Email:       gameworks@nvidia.com\n  // Site:        http://developer.nvidia.com/\n  //\n  // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions\n  // are met:\n  //  * Redistributions of source code must retain the above copyright\n  //    notice, this list of conditions and the following disclaimer.\n  //  * Redistributions in binary form must reproduce the above copyright\n  //    notice, this list of conditions and the following disclaimer in the\n  //    documentation and/or other materials provided with the distribution.\n  //  * Neither the name of NVIDIA CORPORATION nor the names of its\n  //    contributors may be used to endorse or promote products derived\n  //    from this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n  // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n  // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  //----------------------------------------------------------------------------------\n\n  #define FXAA_PC 1\n  #define FXAA_GLSL_100 1\n  #define FXAA_QUALITY_PRESET 12\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n      //\n      // The console algorithm for PC is included\n      // for developers targeting really low spec machines.\n      // Likely better to just run FXAA_PC, and use a really low preset.\n      //\n      #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n      #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n      #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n      #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n      #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n      #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n      //\n      // For those using non-linear color,\n      // and either not able to get luma in alpha, or not wanting to,\n      // this enables FXAA to run using green as a proxy for luma.\n      // So with this enabled, no need to pack luma in alpha.\n      //\n      // This will turn off AA on anything which lacks some amount of green.\n      // Pure red and blue or combination of only R and B, will get no AA.\n      //\n      // Might want to lower the settings for both,\n      //    fxaaConsoleEdgeThresholdMin\n      //    fxaaQualityEdgeThresholdMin\n      // In order to insure AA does not get turned off on colors\n      // which contain a minor amount of green.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n      //\n      // Controls algorithm's early exit path.\n      // On PS3 turning this ON adds 2 cycles to the shader.\n      // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n      // Turning this off on console will result in a more blurry image.\n      // So this defaults to on.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n      //\n      // Only valid for PC OpenGL currently.\n      // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n      //\n      // 1 = Use discard on pixels which don't need AA.\n      //     For APIs which enable concurrent TEX+ROP from same surface.\n      // 0 = Return unchanged color on pixels which don't need AA.\n      //\n      #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n      //\n      // Used for GLSL 120 only.\n      //\n      // 1 = GL API supports fast pixel offsets\n      // 0 = do not use fast pixel offsets\n      //\n      #ifdef GL_EXT_gpu_shader4\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifndef FXAA_FAST_PIXEL_OFFSET\n          #define FXAA_FAST_PIXEL_OFFSET 0\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n      //\n      // 1 = API supports gather4 on alpha channel.\n      // 0 = API does not support gather4 on alpha channel.\n      //\n      #if (FXAA_HLSL_5 == 1)\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifndef FXAA_GATHER4_ALPHA\n          #define FXAA_GATHER4_ALPHA 0\n      #endif\n  #endif\n\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITY_PRESET\n      //\n      // Choose the quality preset.\n      // This needs to be compiled into the shader as it effects code.\n      // Best option to include multiple presets is to\n      // in each shader define the preset, then include this file.\n      //\n      // OPTIONS\n      // -----------------------------------------------------------------------\n      // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n      // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n      // 39       - no dither, very expensive\n      //\n      // NOTES\n      // -----------------------------------------------------------------------\n      // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n      // 13 = about same speed as FXAA 3.9 and better than 12\n      // 23 = closest to FXAA 3.9 visually and performance wise\n      //  _ = the lowest digit is directly related to performance\n      // _  = the highest digit is directly related to style\n      //\n      #define FXAA_QUALITY_PRESET 12\n  #endif\n\n\n  /*============================================================================\n\n                              FXAA QUALITY - PRESETS\n\n  ============================================================================*/\n\n  /*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 10)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 3.0\n      #define FXAA_QUALITY_P2 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 11)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 3.0\n      #define FXAA_QUALITY_P3 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 12)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 4.0\n      #define FXAA_QUALITY_P4 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 13)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 4.0\n      #define FXAA_QUALITY_P5 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 14)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 4.0\n      #define FXAA_QUALITY_P6 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 15)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 12.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 20)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 2.0\n      #define FXAA_QUALITY_P2 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 21)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 22)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 23)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 24)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 3.0\n      #define FXAA_QUALITY_P6 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 25)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 26)\n      #define FXAA_QUALITY_PS 9\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 4.0\n      #define FXAA_QUALITY_P8 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 27)\n      #define FXAA_QUALITY_PS 10\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 4.0\n      #define FXAA_QUALITY_P9 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 28)\n      #define FXAA_QUALITY_PS 11\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 4.0\n      #define FXAA_QUALITY_P10 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 29)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 39)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.0\n      #define FXAA_QUALITY_P2 1.0\n      #define FXAA_QUALITY_P3 1.0\n      #define FXAA_QUALITY_P4 1.0\n      #define FXAA_QUALITY_P5 1.5\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n\n\n  /*============================================================================\n\n                                  API PORTING\n\n  ============================================================================*/\n  #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n      #define FxaaBool bool\n      #define FxaaDiscard discard\n      #define FxaaFloat float\n      #define FxaaFloat2 vec2\n      #define FxaaFloat3 vec3\n      #define FxaaFloat4 vec4\n      #define FxaaHalf float\n      #define FxaaHalf2 vec2\n      #define FxaaHalf3 vec3\n      #define FxaaHalf4 vec4\n      #define FxaaInt2 ivec2\n      #define FxaaSat(x) clamp(x, 0.0, 1.0)\n      #define FxaaTex sampler2D\n  #else\n      #define FxaaBool bool\n      #define FxaaDiscard clip(-1)\n      #define FxaaFloat float\n      #define FxaaFloat2 float2\n      #define FxaaFloat3 float3\n      #define FxaaFloat4 float4\n      #define FxaaHalf half\n      #define FxaaHalf2 half2\n      #define FxaaHalf3 half3\n      #define FxaaHalf4 half4\n      #define FxaaSat(x) saturate(x)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_120 == 1)\n      // Requires,\n      //  #version 120\n      // And at least,\n      //  #extension GL_EXT_gpu_shader4 : enable\n      //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n      #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n      #if (FXAA_FAST_PIXEL_OFFSET == 1)\n          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n      #else\n          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n      #endif\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_130 == 1)\n      // Requires #version 130 or better\n      #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_3 == 1)\n      #define FxaaInt2 float2\n      #define FxaaTex sampler2D\n      #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n      #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_4 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_5 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n      #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n      #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n      #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n      #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n  #endif\n\n\n  /*============================================================================\n                      GREEN AS LUMA OPTION SUPPORT FUNCTION\n  ============================================================================*/\n  #if (FXAA_GREEN_AS_LUMA == 0)\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n  #else\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n  #endif\n\n\n\n\n  /*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n  ============================================================================*/\n  #if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n      //\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy} = center of pixel\n      FxaaFloat2 pos,\n      //\n      // Used only for FXAA Console, and not used on the 360 version.\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy_} = upper left of pixel\n      // {_zw} = lower right of pixel\n      FxaaFloat4 fxaaConsolePosPos,\n      //\n      // Input color texture.\n      // {rgb_} = color in linear or perceptual color space\n      // if (FXAA_GREEN_AS_LUMA == 0)\n      //     {__a} = luma in perceptual color space (not linear)\n      FxaaTex tex,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 2nd sampler.\n      // This sampler needs to have an exponent bias of -1.\n      FxaaTex fxaaConsole360TexExpBiasNegOne,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 3nd sampler.\n      // This sampler needs to have an exponent bias of -2.\n      FxaaTex fxaaConsole360TexExpBiasNegTwo,\n      //\n      // Only used on FXAA Quality.\n      // This must be from a constant/uniform.\n      // {x_} = 1.0/screenWidthInPixels\n      // {_y} = 1.0/screenHeightInPixels\n      FxaaFloat2 fxaaQualityRcpFrame,\n      //\n      // Only used on FXAA Console.\n      // This must be from a constant/uniform.\n      // This effects sub-pixel AA quality and inversely sharpness.\n      //   Where N ranges between,\n      //     N = 0.50 (default)\n      //     N = 0.33 (sharper)\n      // {x__} = -N/screenWidthInPixels\n      // {_y_} = -N/screenHeightInPixels\n      // {_z_} =  N/screenWidthInPixels\n      // {__w} =  N/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt,\n      //\n      // Only used on FXAA Console.\n      // Not used on 360, but used on PS3 and PC.\n      // This must be from a constant/uniform.\n      // {x__} = -2.0/screenWidthInPixels\n      // {_y_} = -2.0/screenHeightInPixels\n      // {_z_} =  2.0/screenWidthInPixels\n      // {__w} =  2.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n      //\n      // Only used on FXAA Console.\n      // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n      // This must be from a constant/uniform.\n      // {x__} =  8.0/screenWidthInPixels\n      // {_y_} =  8.0/screenHeightInPixels\n      // {_z_} = -4.0/screenWidthInPixels\n      // {__w} = -4.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_SUBPIX define.\n      // It is here now to allow easier tuning.\n      // Choose the amount of sub-pixel aliasing removal.\n      // This can effect sharpness.\n      //   1.00 - upper limit (softer)\n      //   0.75 - default amount of filtering\n      //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n      //   0.25 - almost off\n      //   0.00 - completely off\n      FxaaFloat fxaaQualitySubpix,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // The minimum amount of local contrast required to apply algorithm.\n      //   0.333 - too little (faster)\n      //   0.250 - low quality\n      //   0.166 - default\n      //   0.125 - high quality\n      //   0.063 - overkill (slower)\n      FxaaFloat fxaaQualityEdgeThreshold,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n      //   0.0625 - high quality (faster)\n      //   0.0312 - visible limit (slower)\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaQualityEdgeThresholdMin,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only three safe values here: 2 and 4 and 8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // For all other platforms can be a non-power of two.\n      //   8.0 is sharper (default!!!)\n      //   4.0 is softer\n      //   2.0 is really soft (good only for vector graphics inputs)\n      FxaaFloat fxaaConsoleEdgeSharpness,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only two safe values here: 1/4 and 1/8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // The console setting has a different mapping than the quality setting.\n      // Other platforms can use other values.\n      //   0.125 leaves less aliasing, but is softer (default!!!)\n      //   0.25 leaves more aliasing, and is sharper\n      FxaaFloat fxaaConsoleEdgeThreshold,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      // The console setting has a different mapping than the quality setting.\n      // This only applies when FXAA_EARLY_EXIT is 1.\n      // This does not apply to PS3,\n      // PS3 was simplified to avoid more shader instructions.\n      //   0.06 - faster but more aliasing in darks\n      //   0.05 - default\n      //   0.04 - slower and less aliasing in darks\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaConsoleEdgeThresholdMin,\n      //\n      // Extra constants for 360 FXAA Console only.\n      // Use zeros or anything else for other platforms.\n      // These must be in physical constant registers and NOT immediates.\n      // Immediates will result in compiler un-optimizing.\n      // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n      FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posM;\n      posM.x = pos.x;\n      posM.y = pos.y;\n      #if (FXAA_GATHER4_ALPHA == 1)\n          #if (FXAA_DISCARD == 0)\n              FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n              #if (FXAA_GREEN_AS_LUMA == 0)\n                  #define lumaM rgbyM.w\n              #else\n                  #define lumaM rgbyM.y\n              #endif\n          #endif\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n          #else\n              FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n          #endif\n          #if (FXAA_DISCARD == 1)\n              #define lumaM luma4A.w\n          #endif\n          #define lumaE luma4A.z\n          #define lumaS luma4A.x\n          #define lumaSE luma4A.y\n          #define lumaNW luma4B.w\n          #define lumaN luma4B.z\n          #define lumaW luma4B.x\n      #else\n          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              #define lumaM rgbyM.w\n          #else\n              #define lumaM rgbyM.y\n          #endif\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n          #endif\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat maxSM = max(lumaS, lumaM);\n      FxaaFloat minSM = min(lumaS, lumaM);\n      FxaaFloat maxESM = max(lumaE, maxSM);\n      FxaaFloat minESM = min(lumaE, minSM);\n      FxaaFloat maxWN = max(lumaN, lumaW);\n      FxaaFloat minWN = min(lumaN, lumaW);\n      FxaaFloat rangeMax = max(maxWN, maxESM);\n      FxaaFloat rangeMin = min(minWN, minESM);\n      FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n      FxaaFloat range = rangeMax - rangeMin;\n      FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n      FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n      if(earlyExit)\n          #if (FXAA_DISCARD == 1)\n              FxaaDiscard;\n          #else\n              return rgbyM;\n          #endif\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_GATHER4_ALPHA == 0)\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n          #endif\n      #else\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNS = lumaN + lumaS;\n      FxaaFloat lumaWE = lumaW + lumaE;\n      FxaaFloat subpixRcpRange = 1.0/range;\n      FxaaFloat subpixNSWE = lumaNS + lumaWE;\n      FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n      FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNESE = lumaNE + lumaSE;\n      FxaaFloat lumaNWNE = lumaNW + lumaNE;\n      FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n      FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNWSW = lumaNW + lumaSW;\n      FxaaFloat lumaSWSE = lumaSW + lumaSE;\n      FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n      FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n      FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n      FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n      FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n      FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n      FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n      FxaaBool horzSpan = edgeHorz >= edgeVert;\n      FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n      if(!horzSpan) lumaN = lumaW;\n      if(!horzSpan) lumaS = lumaE;\n      if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n      FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat gradientN = lumaN - lumaM;\n      FxaaFloat gradientS = lumaS - lumaM;\n      FxaaFloat lumaNN = lumaN + lumaM;\n      FxaaFloat lumaSS = lumaS + lumaM;\n      FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n      FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n      if(pairN) lengthSign = -lengthSign;\n      FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posB;\n      posB.x = posM.x;\n      posB.y = posM.y;\n      FxaaFloat2 offNP;\n      offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n      offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n      if(!horzSpan) posB.x += lengthSign * 0.5;\n      if( horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posN;\n      posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n      posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat2 posP;\n      posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n      posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n      FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n      FxaaFloat subpixE = subpixC * subpixC;\n      FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n      if(!pairN) lumaNN = lumaSS;\n      FxaaFloat gradientScaled = gradient * 1.0/4.0;\n      FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n      FxaaFloat subpixF = subpixD * subpixE;\n      FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n      lumaEndN -= lumaNN * 0.5;\n      lumaEndP -= lumaNN * 0.5;\n      FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n      FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n      FxaaBool doneNP = (!doneN) || (!doneP);\n      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n  /*--------------------------------------------------------------------------*/\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 3)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 4)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 5)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 6)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n  /*--------------------------------------------------------------------------*/\n                          #if (FXAA_QUALITY_PS > 7)\n                          if(doneNP) {\n                              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                              doneN = abs(lumaEndN) >= gradientScaled;\n                              doneP = abs(lumaEndP) >= gradientScaled;\n                              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                              doneNP = (!doneN) || (!doneP);\n                              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_QUALITY_PS > 8)\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 9)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 10)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 11)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 12)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n      #endif\n  /*--------------------------------------------------------------------------*/\n                          }\n                          #endif\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat dstN = posM.x - posN.x;\n      FxaaFloat dstP = posP.x - posM.x;\n      if(!horzSpan) dstN = posM.y - posN.y;\n      if(!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n      FxaaFloat spanLength = (dstP + dstN);\n      FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n      FxaaFloat spanLengthRcp = 1.0/spanLength;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool directionN = dstN < dstP;\n      FxaaFloat dst = min(dstN, dstP);\n      FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n      FxaaFloat subpixG = subpixF * subpixF;\n      FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n      FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n      FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n      if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n      if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n      #if (FXAA_DISCARD == 1)\n          return FxaaTexTop(tex, posM);\n      #else\n          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n      #endif\n  }\n  /*==========================================================================*/\n  #endif\n`;\n\nexport const fragmentMain = `\n  // FXAA pass start\n  if (fxaaEnabled) {\n    outgoingColor = FxaaPixelShader(\n      uv,\n      vec4(0.0),\n      tDiffuse,\n      tDiffuse,\n      tDiffuse,\n      fxaaResolution,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n    );\n    // TODO avoid querying texture twice for same texel\n    outgoingColor.a = texture2D(tDiffuse, uv).a;\n  }\n  // FXAA pass end\n`;\n\nexport function guiControls(gui: GUI, material: Material) {\n  const guiPass = gui.addFolder('fxaa pass');\n  guiPass.close();\n  guiPass.add(material.uniforms.fxaaEnabled, 'value', 0, 1, 1).name('enabled');\n}\n","import {\n  fragmentUniforms as fxaaFragmentUniforms,\n  fragmentMain as fxaaFragmentMain,\n  fragmentPass as fxaaFragmentPass\n} from '../../passes/fxaa.glsl';\n\nexport const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform vec2 resolution;\n  uniform float time;\n  uniform sampler2D tDiffuse;\n  // FXAA pass\n  ${fxaaFragmentUniforms}\n  ${fxaaFragmentPass}\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 outgoingColor = texture2D(tDiffuse, uv);\n    // FXAA pass\n    ${fxaaFragmentMain}\n    gl_FragColor.rgb = outgoingColor.rgb;\n    gl_FragColor.a = outgoingColor.a;\n  }\n`;\n","import {\n  Scene,\n  Mesh,\n  ShaderMaterial,\n  Vector2,\n  UniformsUtils,\n  WebGLRenderTarget,\n  BufferGeometry,\n  OrthographicCamera,\n  PerspectiveCamera\n} from 'three';\nimport { GUI } from 'dat.gui';\nimport { vertexShader, fragmentShader } from './shader.glsl';\nimport { getRenderBufferSize } from '../../../resize';\nimport { uniforms as fxaaUniforms, guiControls as fxaaGuiControls } from '../../passes/fxaa.glsl';\nimport renderer from '../../../renderer';\n\n/**\n * The final pass contains the post fx and is then output to the screen\n *\n * @export\n * @class FinalPass\n */\nexport default class FinalPass {\n  gui: GUI;\n  scene: Scene;\n  camera: OrthographicCamera;\n  mesh: Mesh;\n\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    // Create gui\n    this.gui = gui.addFolder('final pass');\n    this.gui.close();\n    // Create scene\n    this.scene = new Scene();\n    // Use camera from post processing\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    // Setup shader and combine uniforms from any post fx you want to include\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([\n        {\n          time: {\n            value: 0\n          },\n          tDiffuse: {\n            // Keep it the same as threejs for reusability\n            value: null\n          },\n          resolution: {\n            value: new Vector2(width, height)\n          }\n        },\n        fxaaUniforms\n      ]),\n      vertexShader,\n      fragmentShader\n    });\n\n    // Add gui controls\n    fxaaGuiControls(this.gui, material);\n\n    // Create the mesh and turn off matrixAutoUpdate\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n  }\n\n  /**\n   * Resize handler, update uniforms\n   *\n   * @param {Number} width\n   * @param {Number} height\n   * @memberof FinalPass\n   */\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.mesh.material.uniforms.fxaaResolution.value.x = 1 / width;\n    this.mesh.material.uniforms.fxaaResolution.value.y = 1 / height;\n  }\n\n  /**\n   * Render the pass and output to screen\n   *\n   * @param {*} scene\n   * @param {WebGLRenderTarget} renderTarget\n   * @param {Number} delta\n   * @memberof FinalPass\n   */\n  render(scene: BaseScene, renderTarget: WebGLRenderTarget, delta: number) {\n    // renderer.setRenderTarget(renderTarget);\n    // renderer.render(scene.scene, scene.camera);\n    // renderer.setRenderTarget(null);\n    this.mesh.material.uniforms.tDiffuse.value = renderTarget.texture;\n    this.mesh.material.uniforms.time.value += delta;\n    renderer.render(this.scene, this.camera);\n  }\n\n  /**\n   * Render the final pass when used with the screenshot utility\n   *\n   * @param {Scene} scene\n   * @param {PerspectiveCamera} camera\n   * @param {WebGLRenderTarget} renderTargetA\n   * @param {WebGLRenderTarget} renderTargetB\n   * @param {number} delta\n   * @memberof FinalPass\n   */\n  screenshotRender(\n    scene: Scene,\n    camera: PerspectiveCamera,\n    renderTargetA: WebGLRenderTarget,\n    renderTargetB: WebGLRenderTarget,\n    delta: number\n  ) {\n    this.mesh.material.uniforms.tDiffuse.value = renderTargetA.texture;\n    this.mesh.material.uniforms.time.value += delta;\n    renderer.setRenderTarget(renderTargetB);\n    renderer.render(this.scene, this.camera);\n  }\n}\n","import BaseScene from '../base/base-scene';\nimport { VECTOR_ZERO } from '../../utils/math';\n\nexport default class EmptyScene extends BaseScene {\n  constructor(id: string, clearColor: number) {\n    super({ id, clearColor });\n    this.camera.position.set(0, 0, 10);\n    this.camera.lookAt(VECTOR_ZERO);\n  }\n}\n","import { Mesh, Scene, ShaderMaterial, Vector2, WebGLRenderTarget } from 'three';\nimport renderer from '../../../renderer';\nimport { getRenderBufferSize } from '../../../resize';\n\nexport default class CopyPass {\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    this.scene = new Scene();\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    const material = new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          // Keep it the same as threejs for reusability\n          value: null\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader: `\n        void main() {\n          gl_Position = vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n        void main() {\n          vec2 uv = gl_FragCoord.xy / resolution;\n          gl_FragColor = texture2D(tDiffuse, uv);\n        }\n      `\n    });\n\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n  }\n\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n  }\n\n  render(renderTarget: WebGLRenderTarget, renderTargetCopy: WebGLRenderTarget, toScreen: boolean = false) {\n    if (toScreen) {\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(renderTarget);\n      this.mesh.material.uniforms.tDiffuse.value = renderTargetCopy.texture;\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(null);\n    }\n  }\n}\n","import { Mesh, Scene, ShaderMaterial, Vector2, WebGLRenderTarget } from 'three';\nimport renderer from '../../../renderer';\nimport { getRenderBufferSize } from '../../../resize';\nimport { vertexShader, fragmentShader } from './shader.glsl';\n\nexport default class DenoisePass {\n  constructor(gui: GUI, geometry: BufferGeometry, camera: OrthographicCamera) {\n    this.gui = gui.addFolder('denoise pass');\n    this.gui.open();\n    this.scene = new Scene();\n    this.camera = camera;\n    const { width, height } = getRenderBufferSize();\n    const material = new ShaderMaterial({\n      uniforms: {\n        tDiffusePrev: {\n          value: null\n        },\n        tDiffuse: {\n          value: null\n        },\n        frameCount: {\n          value: 0\n        },\n        resolution: {\n          value: new Vector2(width, height)\n        }\n      },\n      vertexShader,\n      fragmentShader\n    });\n\n    this.mesh = new Mesh(geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.mesh.updateMatrix();\n    this.scene.add(this.mesh);\n\n    this.active = false;\n    this.passes = 0;\n    this.maxPasses = 2000;\n\n    this.gui.add(this, 'passes').listen();\n    this.gui.add(this, 'maxPasses', 0, 20000);\n    this.gui\n      .add(this, 'active')\n      .onChange(this.reset)\n      .listen();\n  }\n\n  resize(width: number, height: number) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.reset();\n  }\n\n  reset = () => {\n    this.passes = 0;\n  };\n\n  render(\n    scene: BaseScene,\n    renderTargetCurrent: WebGLRenderTarget,\n    renderTargetPrev: WebGLRenderTarget,\n    renderTargetCombined: WebGLRenderTarget\n  ) {\n    this.mesh.material.uniforms.frameCount.value = this.passes;\n\n    // Render current scene\n    renderer.setRenderTarget(renderTargetCurrent);\n    renderer.render(scene.scene, scene.camera);\n\n    // Render previous and current frame together\n    renderer.setRenderTarget(renderTargetCombined);\n    this.mesh.material.uniforms.tDiffuse.value = renderTargetCurrent.texture;\n    this.mesh.material.uniforms.tDiffusePrev.value = renderTargetPrev.texture;\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(null);\n    this.passes++;\n  }\n\n  pauseRendering() {\n    return this.active && this.passes >= this.maxPasses;\n  }\n}\n","export const vertexShader = `\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = `\n  uniform sampler2D tDiffuse;\n  uniform sampler2D tDiffusePrev;\n  uniform float frameCount;\n  uniform vec2 resolution;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(tDiffusePrev, uv);\n    vec4 texel1 = texture2D(tDiffuse, uv);\n    gl_FragColor = mix(texel0, texel1, clamp(1.0 / frameCount, 0.0, 1.0));\n  }\n`;\n","export default `\n  struct Camera {\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    float aspect;\n    vec3 origin;\n    float lensRadius;\n    vec3 u;\n    vec3 v;\n  };\n\n  struct Ray {\n    vec3 origin;\n    vec3 direction;\n  };\n\n  vec2 randomInUnitDisk() {\n    float x = rand(vUv + seed.xy);\n    float y = rand(vUv + seed.xz);\n    float r = mix(-1.0, 1.0, rand(vUv + seed.yw));\n\t  return r * vec2(sin(x * TWO_PI), cos(y * TWO_PI));\n  }\n\n  Ray getRay(float u, float v, Camera camera) {\n    vec2 rd = camera.lensRadius * randomInUnitDisk();\n    vec3 offset = camera.u * rd.x + camera.v * rd.y;\n    return Ray(camera.origin + offset, normalize(camera.lowerLeftCorner + u * camera.horizontal + v * camera.vertical - camera.origin - offset));\n  }\n\n  vec3 pointAtParameter(float t, Ray ray) {\n    return ray.origin + t * ray.direction;\n  }\n\n\n  Camera createCamera(vec3 origin, vec3 lookat, vec3 up, float aspect, float aperture, float focusDistance) {\n    Camera camera;\n\n    float theta = fov * (PI / 180.0);\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    vec3 w = normalize(origin - lookat);\n    camera.u = normalize(cross(up, w));\n    camera.v = cross(w, camera.u);\n\n    camera.aspect = aspect;\n    camera.lowerLeftCorner = origin - halfWidth * focusDistance * camera.u - halfHeight * focusDistance * camera.v - focusDistance * w;\n    camera.horizontal = 2.0 * halfWidth * focusDistance * camera.u;\n    camera.vertical = 2.0 * halfHeight * focusDistance * camera.v;\n    camera.origin = origin;\n    camera.lensRadius = aperture / 2.0;\n\n    return camera;\n  }\n`;\n","export default `\n  struct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n  };\n`;\n","export default (worldSize: number) => {\n  return `\n    bool sphereHit(Ray ray, const in float tMin, const in float tMax, const in Sphere sphere, inout HitRecord hitRecord) {\n\n      vec3 oc = ray.origin - sphere.center;\n      float a = dot(ray.direction, ray.direction); // origin\n      float b = dot(oc, ray.direction);\n      float c = dot(oc, oc) - sphere.radius * sphere.radius;\n      float discriminant = b * b - a * c;\n\n      if (discriminant < 0.0) return false;\n\n      float s = sqrt(discriminant);\n\n      float temp = (-b - s) / a;\n      if (temp < tMax && temp > tMin) {\n        hitRecord.t = temp;\n        hitRecord.position = ray.origin + temp * ray.direction;\n        hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n        hitRecord.material = sphere.material;\n        return true;\n      }\n      temp = (-b + s) / a;\n      if (temp < tMax && temp > tMin) {\n        hitRecord.t = temp;\n        hitRecord.position = ray.origin + temp * ray.direction;\n        hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n        hitRecord.material = sphere.material;\n        return true;\n      }\n      return false;\n    }\n\n    bool hit(Ray ray, float tMin, float tMax, Sphere list[${worldSize}], inout HitRecord hitRecord) {\n      bool hitAnything = false;\n      float closestSoFar = tMax;\n      // If record doesn't hit, we use the previous\n      HitRecord tempRecord = hitRecord;\n      for(int i = 0; i < ${worldSize}; i++) {\n        if (sphereHit(ray, tMin, closestSoFar, list[i], tempRecord)) {\n          hitAnything = true;\n          closestSoFar = tempRecord.t;\n          hitRecord = tempRecord;\n        }\n      }\n      return hitAnything;\n    }\n  `;\n};\n","export default `\n\n  vec3 ref(vec3 direction, vec3 normal) {\n    return direction - 2.0 * dot(direction, normal) * normal;\n  }\n\n  bool refract(const in vec3 direction, const in vec3 normal, const in float niOverNt, out vec3 refracted) {\n    float dt = dot(direction, normal);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if (discriminant > 0.0) {\n      refracted = niOverNt * (direction - normal * dt) - normal * sqrt(discriminant);\n      return true;\n    }\n    return false;\n  }\n\n  float schlick(float cosine, float reflectionIndex) {\n    float r0 = (1.0 - reflectionIndex) / (1.0 + reflectionIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n  }\n\n  bool scatter(inout Ray ray, const in HitRecord hitRecord, out vec3 attenuation, out Ray scatteredRay) {\n    if(hitRecord.material.type == METAL) {\n      attenuation = hitRecord.material.albedo;\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float fuzz = clamp(hitRecord.material.value, 0.0, 1.0);\n      scatteredRay = Ray(hitRecord.position, normalize(reflected + fuzz * randomInSphere(hitRecord.normal.xz)));\n      return (dot(scatteredRay.direction, hitRecord.normal) > 0.0);\n    } else if(hitRecord.material.type == DIELECTRIC) {\n\n      vec3 outwardNormal = vec3(0);\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float niOverNt = 0.0;\n\n      float reflectionIndex = hitRecord.material.value;\n\n      attenuation = vec3(1.0);\n      vec3 refracted = vec3(0);\n      float reflectProbability = 0.0;\n      float cosine = 0.0;\n\n      if (dot(ray.direction, hitRecord.normal) > 0.0) {\n        outwardNormal = -hitRecord.normal;\n        niOverNt = reflectionIndex;\n        cosine = reflectionIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      } else {\n        outwardNormal = hitRecord.normal;\n        niOverNt = 1.0 / reflectionIndex;\n        cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      }\n\n      if(refract(ray.direction, outwardNormal, niOverNt, refracted)) {\n        scatteredRay = Ray(hitRecord.position, refracted);\n        reflectProbability = schlick(cosine, hitRecord.material.value);\n      } else {\n        scatteredRay = Ray(hitRecord.position, reflected);\n        reflectProbability = 1.0;\n      }\n\n      if (rand(vUv + seed.xy + hitRecord.position.xz) < reflectProbability) {\n        scatteredRay = Ray(hitRecord.position, reflected);\n      } else {\n        scatteredRay = Ray(hitRecord.position, refracted);\n      }\n\n      return true;\n    } else {\n      // lambert\n      attenuation = hitRecord.material.albedo;\n      vec3 target = hitRecord.position + hitRecord.normal + randomInSphere(hitRecord.normal.xz);\n      scatteredRay = Ray(hitRecord.position, normalize(target - hitRecord.position));\n      return true;\n    }\n  }\n`;\n","export default (worldSize: number, maxBounces: number) => {\n  return `\n    vec3 raytraceWorld(in Ray ray, Sphere world[${worldSize}]) {\n    HitRecord hitRecord;\n    vec3 color = vec3(1);\n\n    for(int i = 0; i < ${maxBounces}; i++) {\n      Ray scatteredRay;\n      if (hit(ray, 0.001, MAX_FLOAT, world, hitRecord)) {\n          vec3 attenuation;\n          if(scatter(ray, hitRecord, attenuation, scatteredRay)) {\n            color *= attenuation;\n            ray = scatteredRay;\n          } else {\n            return vec3(0);\n          }\n      } else {\n        // Sky color\n        float t = 0.5 * ray.direction.y + 1.0;\n        color *= mix(vec3(1), vec3(0.5, 0.7, 1.0), t);\n        return color;\n      }\n    }\n\n    return vec3(0);\n  }\n  `;\n};\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport camera from './camera.glsl';\nimport sphere from './sphere.glsl';\nimport hitables from './hitables.glsl';\nimport material from './material.glsl';\nimport world from './world.glsl';\n\nexport const uniforms = {\n  resolution: { value: new Vector2() },\n  fov: { value: 20 },\n  seed: { value: new Vector4(Math.random(), Math.random(), Math.random(), Math.random()) },\n  time: { value: 0 },\n  cameraAspect: { value: 1 },\n  cameraAperture: { value: 0.1 },\n  cameraFocusDistance: { value: 10 },\n  cameraAutoFocus: { value: 0 },\n  cameraPosition: { value: new Vector3() },\n  cameraTarget: { value: new Vector3() }\n};\n\nexport const vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n`;\n\nexport const fragmentShader = (worldSize: number, maxBounces: number = 50, scene: string = '') => {\n  return `\n    uniform vec2 resolution;\n    uniform float time;\n    uniform vec4 seed;\n    uniform float fov;\n    uniform vec3 cameraTarget;\n    uniform float cameraAspect;\n    uniform float cameraAperture;\n    uniform float cameraFocusDistance;\n    uniform float cameraAutoFocus;\n    varying vec2 vUv;\n\n    #define MAX_FLOAT 1e5\n    #define PI 3.141592653589793\n    #define TWO_PI 6.283185307179586\n    #define LAMBERT 0\n    #define METAL 1\n    #define DIELECTRIC 2\n\n    float rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec3 randomInSphere(vec2 seed2){\n      vec2 uv = vec2(rand(vUv + seed.xy + seed2), rand(vUv + seed.xz + seed2));\n      float theta = 2.0 * PI * uv.x;\n      float phi = acos(2.0 * uv.y - 1.0);\n      float radius = 1.0;\n      float x = (radius * sin(phi) * cos(theta));\n      float y = (radius * sin(phi) * sin(theta));\n      float z = (radius * cos(phi));\n      return vec3(x, y, z);\n    }\n\n    struct Material {\n      int type;\n      vec3 albedo;\n      float value;\n    };\n\n    struct HitRecord {\n      float t;\n      vec3 position;\n      vec3 normal;\n      Material material;\n    };\n\n    ${camera}\n    ${sphere}\n    ${material}\n    ${hitables(worldSize)}\n    ${world(worldSize, maxBounces)}\n\n    vec3 calculateNormals(float t, vec3 center, Ray ray) {\n      vec3 normal = pointAtParameter(t, ray) - center;\n      normal /= length(normal); // make normal unit length\n      return normal;\n    }\n\n    void main(){\n\n      // Fix aspect\n      vec2 uv = vUv;\n      uv.y -= 0.5;\n      uv.y *= 2.0 * resolution.y / resolution.x;\n      uv.y += 0.5;\n\n      ${scene}\n\n      float focusDistance = mix(cameraFocusDistance, length(cameraPosition - cameraTarget), cameraAutoFocus);\n\n      Camera camera = createCamera(cameraPosition,\n                                  cameraTarget,\n                                  vec3(0.0, 1.0, 0.0),\n                                  2.0,\n                                  cameraAperture,\n                                  focusDistance);\n\n      Ray ray = getRay(uv.x, uv.y, camera);\n\n      vec3 outgoingColor = raytraceWorld(ray, world);\n\n      gl_FragColor = vec4(outgoingColor, 1.0);\n      gl_FragColor = LinearTosRGB(gl_FragColor);\n    }\n  `;\n};\n","import { MathUtils, Mesh, PerspectiveCamera, PlaneBufferGeometry, ShaderMaterial, Vector3 } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { postProcessing } from '../../../../rendering/renderer';\nimport { uniforms, vertexShader, fragmentShader } from './raytracer.glsl';\n\nconst SCENE_FINAL = 'final';\nconst SCENE_SIMPLE = 'simple';\n\nexport default class Raytracer {\n  constructor(gui: GUI, camera: PerspectiveCamera, control: OrbitControls) {\n    this.gui = gui.addFolder('raytracer');\n    this.gui.open();\n\n    this.camera = camera;\n    this.control = control;\n\n    const scenes = [SCENE_FINAL, SCENE_SIMPLE];\n\n    this.scene = scenes[0];\n    this.maxSpheres = 200;\n    this.maxBounces = 50;\n    this.gridSize = 11;\n    this.cameraAutoFocus = uniforms.cameraAutoFocus.value === 1;\n\n    this.mesh = new Mesh(new PlaneBufferGeometry(2, 2), this.createMaterial());\n\n    this.gui.add(this, 'scene', scenes).onChange(this.rebuild);\n    this.gui.add(this, 'maxBounces', 1, 100, 1).onChange(this.rebuild);\n    this.gui.add(this, 'maxSpheres', 1, 500, 1).onChange(this.rebuild);\n    this.gui.add(this, 'gridSize', 1, 11).onChange(this.rebuild);\n\n    const guiCamera = this.gui.addFolder('camera');\n    guiCamera.open();\n\n    guiCamera\n      .add(this.mesh.material.uniforms.fov, 'value', 1, 100)\n      .name('fov')\n      .onChange(this.onChange);\n    guiCamera\n      .add(this.mesh.material.uniforms.cameraAperture, 'value', 0, 10)\n      .name('aperture')\n      .onChange(this.onChange)\n      .listen();\n    guiCamera\n      .add(this.mesh.material.uniforms.cameraFocusDistance, 'value', 0, 100)\n      .name('focus dist')\n      .onChange(this.onChange)\n      .listen();\n    guiCamera\n      .add(this, 'cameraAutoFocus', 0, 1)\n      .name('auto focus')\n      .onChange(() => {\n        this.mesh.material.uniforms.cameraAutoFocus.value = this.cameraAutoFocus ? 1 : 0;\n        this.onChange();\n      })\n      .listen();\n  }\n\n  createSimpleScene() {\n    const scene = `\n    Sphere world[5];\n    world[0] = Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(LAMBERT, vec3(0.1, 0.2, 0.5), 0.0));\n    world[1] = Sphere(vec3(0.0, -100.5, 0.0), 100.0, Material(LAMBERT, vec3(0.5), 0.0));\n    world[2] = Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(METAL, vec3(0.8, 0.6, 0.2), 0.0));\n    world[3] = Sphere(vec3(-1.0, 0.0, -1.0), 0.5, Material(DIELECTRIC, vec3(0), 1.5));\n    world[4] = Sphere(vec3(-1.0, 0.0, -1.0), -0.45, Material(DIELECTRIC, vec3(0), 1.5));\n  `;\n    return { scene, size: 5 };\n  }\n\n  createFinalScene() {\n    const size = this.maxSpheres + 4;\n\n    let scene = '';\n    const world = [];\n    world[0] = `Sphere(vec3(0.0, -1000.0, 0.0), 1000.0, Material(LAMBERT, vec3(0.5), 0.0))`;\n    world[1] = `Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(DIELECTRIC, vec3(0), 1.5))`;\n    world[2] = `Sphere(vec3(-4.0, 1.0, 0.0), 1.0, Material(LAMBERT, vec3(0.4, 0.2, 0.1), 0.0))`;\n    world[3] = `Sphere(vec3(4.0, 1.0, 0.0), 1.0, Material(METAL, vec3(0.7, 0.6, 0.5), 0.0))`;\n\n    const offset = new Vector3(4, 0.2, 0);\n    const total = size - world.length;\n    const grid = Math.floor(Math.sqrt(total));\n    let n = world.length;\n\n    for (let i = 0; i < total; i++) {\n      const chooseMat = Math.random();\n      const center = new Vector3(0, 0.2, 0);\n\n      const row = Math.floor(i / grid) / grid;\n      const col = (i % grid) / grid;\n\n      center.x = MathUtils.lerp(-this.gridSize, this.gridSize, row) + MathUtils.randFloat(0, 0.9);\n      center.z = MathUtils.lerp(-this.gridSize, this.gridSize, col) + MathUtils.randFloat(0, 0.9);\n\n      if (center.distanceTo(offset) > 0.9) {\n        if (chooseMat < 0.8) {\n          world[n++] = `Sphere(vec3(${center.x},${center.y},${center.z}), 0.2, Material(LAMBERT, vec3(${Math.random() *\n            Math.random()}, ${Math.random() * Math.random()}, ${Math.random() * Math.random()}), 0.0))`;\n        } else if (chooseMat < 0.95) {\n          world[n++] = `Sphere(vec3(${center.x},${center.y},${center.z}), 0.2, Material(METAL, vec3(${0.5 *\n            (Math.random() + 1)},${0.5 * (Math.random() + 1)}, ${0.5 * (Math.random() + 1)}), ${Math.random() * 0.5}))`;\n        } else {\n          world[n++] = `Sphere(vec3(${center.x},${center.y},${center.z}), 0.2, Material(DIELECTRIC, vec3(0), 1.5));`;\n        }\n      }\n    }\n\n    for (let i = 0; i < world.length; i++) {\n      scene += `world[${i}] = ${world[i]};\\n`;\n    }\n\n    // Prefix\n    scene = `Sphere world[${world.length}];\\n` + scene;\n\n    return { scene, size: world.length };\n  }\n\n  createMaterial = () => {\n    const data = this.getSceneShader();\n    return new ShaderMaterial({\n      uniforms,\n      vertexShader,\n      fragmentShader: fragmentShader(data.size, this.maxBounces, data.scene)\n    });\n  };\n\n  getSceneShader() {\n    switch (this.scene) {\n      case SCENE_FINAL:\n        return this.createFinalScene();\n      default:\n        return this.createSimpleScene();\n    }\n  }\n\n  rebuild = () => {\n    this.mesh.material = this.createMaterial();\n    switch (this.scene) {\n      case SCENE_FINAL:\n        this.camera.position.set(13, 2, 3);\n        this.control.target.set(0, 0, 0);\n        this.setAperture(0.1);\n        this.setFocusDistance(10);\n        this.setAutoFocus(false);\n        break;\n      default:\n        this.camera.position.set(3, 3, 2);\n        this.control.target.set(0, 0, -1);\n        this.setAperture(2);\n        this.setAutoFocus(true);\n        break;\n    }\n\n    this.onChange();\n  };\n\n  setAperture(value: number) {\n    this.mesh.material.uniforms.cameraAperture.value = value;\n  }\n\n  setAutoFocus(value: boolean) {\n    this.mesh.material.uniforms.cameraAutoFocus.value = value ? 1 : 0;\n    this.cameraAutoFocus = value;\n  }\n\n  setFocusDistance(value: boolean) {\n    this.mesh.material.uniforms.cameraFocusDistance.value = value;\n  }\n\n  onChange = () => {\n    postProcessing.denoisePass.reset();\n  };\n\n  onChange = () => {\n    postProcessing.denoisePass.reset();\n  };\n\n  resize(width: number, height: number, camera: PerspectiveCamera) {\n    this.mesh.material.uniforms.resolution.value.x = width;\n    this.mesh.material.uniforms.resolution.value.y = height;\n    this.mesh.material.uniforms.cameraAspect.value = camera.aspect;\n  }\n\n  update(delta: number, camera: PerspectiveCamera, control: OrbitControls) {\n    this.mesh.material.uniforms.seed.value.set(Math.random(), Math.random(), Math.random(), Math.random());\n    this.mesh.material.uniforms.time.value += delta;\n    this.mesh.material.uniforms.cameraPosition.value.copy(camera.position);\n    this.mesh.material.uniforms.cameraTarget.value.copy(control.target);\n  }\n}\n","import BaseScene from '../base/base-scene';\nimport assets from './assets';\nimport Raytracer from './objects/raytracer/raytracer';\nimport { postProcessing } from '../../rendering/renderer';\n\nexport const MAIN_SCENE_ID = 'main';\n\nexport default class MainScene extends BaseScene {\n  constructor() {\n    super({ id: MAIN_SCENE_ID, assets, gui: true, guiOpen: true, controls: true });\n    this.cameras.main.position.set(13, 2, 3);\n    this.control.target.set(0, 0, 0);\n    this.control.update();\n  }\n\n  /**\n   * Create and setup any objects for the scene\n   *\n   * @memberof LandingScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        this.raytracer = new Raytracer(this.gui, this.camera, this.control);\n        this.scene.add(this.raytracer.mesh);\n\n        this.control.addEventListener('change', () => {\n          postProcessing.denoisePass.reset();\n        });\n\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  resize = (width: number, height: number) => {\n    this.cameras.dev.aspect = width / height;\n    this.cameras.dev.updateProjectionMatrix();\n    this.cameras.main.aspect = width / height;\n    this.cameras.main.updateProjectionMatrix();\n    this.raytracer.resize(width, height, this.camera);\n  };\n\n  /**\n   * Update loop\n   *\n   * @memberof LandingScene\n   */\n  update = (delta: number) => {\n    this.controls.main.update();\n    this.raytracer.update(delta, this.camera, this.control);\n  };\n}\n","import { OrthographicCamera, RGBAFormat, WebGLRenderTarget } from 'three';\nimport { GUI } from 'dat.gui';\nimport { bigTriangle } from '../../utils/geometry';\nimport { createRenderTarget } from '../render-target';\nimport { getRenderBufferSize } from '../resize';\nimport TransitionPass from './passes/transition-pass/transition-pass';\nimport FinalPass from './passes/final-pass/final-pass';\nimport EmptyScene from '../../scenes/empty/empty-scene';\nimport renderer from '../renderer';\nimport BaseScene from '../../scenes/base/base-scene';\nimport CopyPass from './passes/copy-pass/copy-pass';\nimport DenoisePass from './passes/denoise-pass/denoise-pass';\nimport { MAIN_SCENE_ID } from '../../scenes/main/main-scene';\n\nexport default class PostProcessing {\n  gui: GUI;\n  camera: OrthographicCamera;\n  renderTargetA: WebGLRenderTarget;\n  renderTargetB: WebGLRenderTarget;\n  renderTargetC: WebGLRenderTarget;\n  transitionPass: TransitionPass;\n  finalPass: FinalPass;\n  currentScene: BaseScene;\n  lastPass: mixed;\n  sceneA: BaseScene;\n  sceneB: BaseScene;\n\n  constructor(gui: GUI) {\n    this.gui = gui;\n    // Create gui\n    // Create big triangle geometry, faster than using quad\n    const geometry = bigTriangle();\n    // Post camera\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    // Setup render targets\n    const { width, height } = getRenderBufferSize();\n    const options = { stencilBuffer: false, format: RGBAFormat };\n    this.renderTargetTransitionA = createRenderTarget(width, height, options);\n    this.renderTargetTransitionB = createRenderTarget(width, height, options);\n    this.renderTargetDenoise = createRenderTarget(width, height, options);\n    this.renderTargetDenoisePrev = createRenderTarget(width, height, options);\n    this.renderTargetDenoiseCombined = createRenderTarget(width, height, options);\n\n    // Create passes\n    this.transitionPass = new TransitionPass(this.gui, geometry, this.camera);\n    this.finalPass = new FinalPass(this.gui, geometry, this.camera);\n    this.denoisePass = new DenoisePass(this.gui, geometry, this.camera);\n    this.copyPass = new CopyPass(this.gui, geometry, this.camera);\n\n    this.transitionPass.on('complete', () => {\n      if (this.sceneB.id === MAIN_SCENE_ID) {\n        this.denoisePass.active = true;\n      }\n    });\n\n    // Create empty scenes\n    const sceneA = new EmptyScene('post scene a', 0x000000);\n    const sceneB = new EmptyScene('post scene b', 0x000000);\n    sceneA.setup();\n    sceneB.setup();\n\n    this.setScenes(sceneA, sceneB);\n    this.resize();\n  }\n\n  /**\n   * Set the two main scenes used for the transition pass\n   *\n   * @param {BaseScene} sceneA\n   * @param {BaseScene} sceneB\n   * @memberof PostProcessing\n   */\n  setScenes(sceneA: BaseScene, sceneB: BaseScene) {\n    this.sceneA = sceneA;\n    this.sceneB = sceneB;\n  }\n\n  /**\n   * Resize handler for passes and render targets\n   *\n   * @memberof PostProcessing\n   */\n  resize() {\n    // const scale = settings.devCamera ? settings.viewportPreviewScale : 1;\n    let { width, height } = getRenderBufferSize();\n\n    // width *= scale;\n    // height *= scale;\n    this.renderTargetTransitionA.setSize(width, height);\n    this.renderTargetTransitionB.setSize(width, height);\n    this.renderTargetDenoise.setSize(width, height);\n    this.renderTargetDenoisePrev.setSize(width, height);\n    this.renderTargetDenoiseCombined.setSize(width, height);\n    this.transitionPass.resize(width, height);\n    this.denoisePass.resize(width, height);\n    this.copyPass.resize(width, height);\n    this.finalPass.resize(width, height);\n  }\n\n  /**\n   * Render passes and output to screen\n   *\n   * @param {Number} delta\n   * @memberof PostProcessing\n   */\n  render(delta: number) {\n    // Stop rendering past x many passes\n    if (this.denoisePass.pauseRendering()) {\n      return;\n    }\n\n    // Determine the current scene based on the transition pass value\n    this.currentScene = this.transitionPass.mesh.material.uniforms.transition.value === 0 ? this.sceneA : this.sceneB;\n    this.lastPass = this.currentScene;\n\n    this.currentScene.update(delta);\n\n    // // If the transition pass is active\n    if (this.transitionPass.active) {\n      this.transitionPass.render(\n        this.sceneA,\n        this.sceneB,\n        this.renderTargetTransitionA,\n        this.renderTargetTransitionB,\n        delta\n      );\n      this.lastPass = this.transitionPass;\n    } else {\n      // Otherwise we just render the current scene\n      renderer.setClearColor(this.currentScene.clearColor);\n      this.currentScene.update(delta);\n    }\n\n    if (this.denoisePass.active) {\n      this.denoisePass.render(\n        this.lastPass,\n        this.renderTargetDenoise,\n        this.renderTargetDenoisePrev,\n        this.renderTargetDenoiseCombined,\n        this.transitionPass.active\n      );\n      // Copy combined result to prev textuer\n      this.copyPass.render(this.renderTargetDenoisePrev, this.renderTargetDenoiseCombined);\n      // this.copyPass.render(this.renderTargetB, this.renderTargetC, true);\n    } else {\n      renderer.setRenderTarget(this.renderTargetDenoiseCombined);\n      renderer.render(this.lastPass.scene, this.lastPass.camera);\n      renderer.setRenderTarget(null);\n    }\n\n    // // Render the final pass which contains all the post fx\n    this.finalPass.render(this.lastPass, this.renderTargetDenoiseCombined, delta);\n  }\n}\n","import { BufferGeometry, BufferAttribute } from 'three';\n\n/**\n * Return a triangle that covers screen-space\n * Mainly used for post processing\n * https://github.com/mikolalysenko/a-big-triangle\n *\n * @export\n * @returns\n */\nexport function bigTriangle() {\n  const geometry = new BufferGeometry();\n  const attribute = new BufferAttribute(new Float32Array([-1, -1, 0, -1, 4, 0, 4, -1, 0]), 3);\n  geometry.setAttribute('position', attribute);\n  geometry.setIndex([0, 2, 1]);\n  return geometry;\n}\n","/**\n * Create a canvas and 2d context\n *\n * @export\n * @param {Number} width\n * @param {Number} height\n * @returns\n */\nexport default function createCanvas(width: number, height: number) {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  return {\n    ctx,\n    canvas\n  };\n}\n","import { sRGBEncoding, WebGLRenderer } from 'three';\nimport { WEBGL } from 'three/examples/jsm/WebGL';\nimport graphics, { getGraphicsMode, getTier } from './graphics';\nimport settings from '../settings';\nimport { setRendererSize } from './resize';\nimport PostProcessing from './post-processing/post-processing';\nimport { gui } from '../utils/gui';\nimport createCanvas from '../utils/canvas';\n\nconst { pixelRatio, antialias } = graphics[getGraphicsMode()];\n\nconst options = {\n  antialias,\n  powerPreference: 'high-performance',\n  stencil: false,\n  preserveDrawingBuffer: true\n};\n\nif (WEBGL.isWebGL2Available()) {\n  const { canvas } = createCanvas(1, 1);\n  options.context = canvas.getContext('webgl2');\n}\n\nconst renderer = new WebGLRenderer(options);\nrenderer.setClearColor(0x000000);\nrenderer.outputEncoding = sRGBEncoding;\n\n// Enable shader errors during dev\nrenderer.debug.checkShaderErrors = settings.isDevelopment;\n\nconst guiRendering = gui.addFolder('rendering');\nguiRendering.open();\n\nrenderer.setPixelRatio(pixelRatio);\nrenderer.setScissorTest(true);\nsetRendererSize(renderer, window.innerWidth, window.innerHeight);\n\nexport const postProcessing = new PostProcessing(guiRendering);\n\nconst gl = renderer.getContext();\nconst gpuInfo = gl.getExtension('WEBGL_debug_renderer_info');\nconst gpu = gl.getParameter(gpuInfo.UNMASKED_RENDERER_WEBGL);\n\nif (settings.isDevelopment) console.log(`Graphics: ${getGraphicsMode()}\\nGPU: ${gpu}\\nTier: ${getTier()}`);\n\nexport default renderer;\n","import { WebGLRenderer } from 'three';\nimport settings from '../settings';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author jetienne / http://jetienne.com/\n */\n\n/**\n * Provide info on THREE.WebGLRenderer\n *\n * @param {Object} renderer the renderer to update\n * @param {Object} Camera the camera to update\n */\nconst RendererStats = function() {\n  const container = document.createElement('div');\n  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer;z-index:100000;top:48px;position:absolute;';\n\n  const msDiv = document.createElement('div');\n  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:rgb(0, 0, 0);';\n  container.appendChild(msDiv);\n\n  const msText = document.createElement('div');\n  msText.style.cssText =\n    'color:rgb(255, 255, 255);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';\n  msText.innerHTML = 'WebGLRenderer';\n  msDiv.appendChild(msText);\n\n  const msTexts = [];\n  const nLines = 9;\n  for (var i = 0; i < nLines; i++) {\n    msTexts[i] = document.createElement('div');\n    msTexts[i].style.cssText =\n      'color:rgb(255, 255, 255);background-color:rgb(0, 0, 0);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';\n    msDiv.appendChild(msTexts[i]);\n    msTexts[i].innerHTML = '-';\n  }\n\n  let lastTime = Date.now();\n  return {\n    domElement: container,\n\n    update: function(webglRenderer: WebGLRenderer) {\n      // sanity check\n      console.assert(webglRenderer instanceof WebGLRenderer);\n\n      // refresh only 30time per second\n      if (Date.now() - lastTime < 1000 / 30) return;\n      lastTime = Date.now();\n\n      msTexts[0].textContent = '=== Memory ===';\n      msTexts[1].textContent = 'Programs: ' + webglRenderer.info.programs.length;\n      msTexts[2].textContent = 'Geometries: ' + webglRenderer.info.memory.geometries;\n      msTexts[3].textContent = 'Textures: ' + webglRenderer.info.memory.textures;\n      msTexts[4].textContent = '=== Render ===';\n      msTexts[5].textContent = 'Calls: ' + webglRenderer.info.render.calls;\n      msTexts[6].textContent = 'Triangles: ' + webglRenderer.info.render.triangles;\n      msTexts[7].textContent = 'Lines: ' + webglRenderer.info.render.lines;\n      msTexts[8].textContent = 'Points: ' + webglRenderer.info.render.points;\n    }\n  };\n};\n\nexport function RenderStatsWrapper() {\n  return {\n    domElement: document.createElement('div'),\n    update: (renderer: WebGLRenderer) => {}\n  };\n}\n\nconst Cls = settings.isDevelopment ? RendererStats : RenderStatsWrapper;\n\nexport default Cls;\n","import settings from '../settings';\nimport RendererStats from './render-stats';\n\nconst rendererStats = new RendererStats();\nif (settings.stats) {\n  rendererStats.domElement.style.position = 'absolute';\n  rendererStats.domElement.style.left = '0px';\n  rendererStats.domElement.style.top = '48px';\n  // if (document.body) document.body.appendChild(rendererStats.domElement);\n}\n\nexport { rendererStats };\n\nif (settings.stats) {\n  const stats = require('@jam3/stats')();\n  stats.domElement.style.cssText = 'position:fixed;left:0;top:0;z-index:10000';\n}\n","import { TweenLite } from 'gsap/gsap-core';\nimport { Mesh, RingBufferGeometry, ShaderMaterial } from 'three';\nimport BaseScene from '../base/base-scene';\nimport { TWO_PI, VECTOR_ZERO } from '../../utils/math';\nimport settings from '../../settings';\n\nexport const PRELOADER_SCENE_ID = 'preloader';\n\nexport default class PreloaderScene extends BaseScene {\n  constructor() {\n    super({ id: PRELOADER_SCENE_ID });\n    this.camera.position.set(0, 0, 10);\n    this.camera.lookAt(VECTOR_ZERO);\n  }\n\n  /**\n   * Create and setup any objects for the scene\n   *\n   * @memberof PreloaderScene\n   */\n  async createSceneObjects() {\n    await new Promise((resolve, reject) => {\n      try {\n        // Create a spinner mesh to show loading progression\n        this.spinner = new Mesh(\n          new RingBufferGeometry(0.9, 1, 32, 1, 0, TWO_PI * 0.75),\n          new ShaderMaterial({\n            transparent: true,\n            uniforms: {\n              opacity: { value: 0 }\n            },\n            vertexShader: `\n              varying vec2 vUv;\n              void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n              }\n            `,\n            fragmentShader: `\n              uniform float opacity;\n              varying vec2 vUv;\n              void main() {\n                gl_FragColor = vec4(vUv, 1.0, vUv.y * opacity);\n              }\n          `\n          })\n        );\n        this.spinner.name = 'spinner';\n        this.scene.add(this.spinner);\n        this.animateInit();\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  preloadGpuCullScene = (culled: boolean) => {\n    this.spinner.material.uniforms.opacity.value = culled ? 1 : 0;\n  };\n\n  animateInit = () => {\n    TweenLite.killTweensOf(this.spinner.material.uniforms.opacity);\n    this.spinner.material.uniforms.opacity.value = 0;\n  };\n\n  async animateIn() {\n    await new Promise((resolve, reject) => {\n      if (settings.skipTransitions) {\n        resolve();\n        return;\n      }\n      TweenLite.to(this.spinner.material.uniforms.opacity, 1, {\n        value: 1,\n        onComplete: () => {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async animateOut() {\n    await new Promise((resolve, reject) => {\n      if (settings.skipTransitions) {\n        resolve();\n        return;\n      }\n      TweenLite.to(this.spinner.material.uniforms.opacity, 1, {\n        value: 0,\n        onComplete: () => {\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Update loop\n   *\n   * @memberof PreloaderScene\n   */\n  update = (delta: number) => {\n    this.spinner.rotation.z -= delta * 2;\n  };\n}\n","/**\n * A class to manage the state of the webgl app\n *\n * @export\n * @class AppState\n */\nexport default class AppState {\n  ready: boolean;\n\n  constructor(props: Object = {}) {\n    this.ready = props.ready || false;\n  }\n\n  equals(state: AppState) {\n    return this.ready === state.ready;\n  }\n\n  clone() {\n    return new AppState({\n      ready: this.ready\n    });\n  }\n}\n","import { WebGLRenderTarget, LinearFilter, RGBAFormat, PerspectiveCamera } from 'three';\nimport { GUI } from 'dat.gui';\nimport { saveAs } from 'file-saver';\nimport createCanvas from './canvas';\nimport { rendererSize } from '../rendering/resize';\nimport renderer, { postProcessing } from '../rendering/renderer';\nimport BaseScene from '../scenes/base/base-scene';\n\nconst DEBUG_RENDER = false;\n\n/**\n * This screenshot utility renders out a custom size render and saves it to an image\n * Please note if the post processing passes change it will require updating\n *\n * @export\n * @class Screenshot\n */\nexport default class Screenshot {\n  gui: GUI;\n  renderTargetA: WebGLRenderTarget;\n  renderTargetB: WebGLRenderTarget;\n  imageData: ImageData;\n  canvas: HTMLCanvasElement;\n  canvasFlipped: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  ctxFlipped: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n  pixelBuffer: Uint8Array;\n\n  constructor(gui: GUI, width: number, height: number, pixelRatio: number = 1) {\n    this.gui = gui.addFolder('screenshot');\n    this.gui.open();\n    this.width = width * pixelRatio;\n    this.height = height * pixelRatio;\n\n    this.renderTargetA = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat,\n      stencilBuffer: false\n    });\n    this.renderTargetB = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat,\n      stencilBuffer: false\n    });\n\n    const { canvas, ctx } = createCanvas(this.width, this.height);\n    const { canvas: canvasFlipped, ctx: ctxFlipped } = createCanvas(this.width, this.height);\n\n    this.canvas = canvas;\n    this.canvasFlipped = canvasFlipped;\n    this.ctx = ctx;\n    this.ctxFlipped = ctxFlipped;\n\n    this.pixelBuffer = new Uint8Array(this.renderTargetA.width * this.renderTargetA.height * 4);\n    this.imageData = this.ctxFlipped.createImageData(this.canvas.width, this.canvas.height);\n\n    if (DEBUG_RENDER) {\n      Object.assign(this.canvas.style, {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        zIndex: '100',\n        border: '1px solid white',\n        pointerEvents: 'none',\n        width: `${width}px`,\n        height: `${height}px`\n      });\n      if (document.body) document.body.appendChild(this.canvas);\n    }\n  }\n\n  /**\n   * Save the canvas to an image\n   *\n   * @memberof Screenshot\n   */\n  save = () => {\n    // const quality = 0.75;\n    const filename = 'screenshot.png';\n    const format = 'image/png';\n    this.canvas.toBlob(\n      function(blob) {\n        saveAs(blob, filename);\n      },\n      format\n      // quality\n    );\n  };\n\n  /**\n   * Capture the current scene and save to an image\n   *\n   * @memberof Screenshot\n   */\n  capture = (scene: BaseScene, camera: PerspectiveCamera) => {\n    // Clear current context\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Save aspect for resetting after render\n    const aspect = camera.aspect;\n\n    // Update aspect to the screenshot size ratio\n    camera.aspect = this.width / this.height;\n    camera.updateProjectionMatrix();\n\n    // Save current width / height\n    const finalPassWidth = postProcessing.finalPass.mesh.material.uniforms.resolution.value.x;\n    const finalPassHeight = postProcessing.finalPass.mesh.material.uniforms.resolution.value.y;\n    const left = 0;\n    const bottom = 0;\n    const width = rendererSize.x;\n    const height = rendererSize.y;\n\n    // Update renderer viewport, this will get reset in the main render loop\n    // inside webgl-app.js\n    renderer.setViewport(left, bottom, width, height);\n    renderer.setScissor(left, bottom, width, height);\n\n    // Update the final pass uniforms\n    scene.resize(this.width, this.height);\n    postProcessing.finalPass.resize(this.width, this.height);\n\n    // Render the current scene into renderTargetA\n    renderer.setRenderTarget(this.renderTargetA);\n    renderer.render(scene.scene, camera);\n    renderer.setRenderTarget(null);\n\n    // Apply the post processing fx which is output into renderTargetB\n    postProcessing.finalPass.screenshotRender(scene.scene, camera, this.renderTargetA, this.renderTargetB, 0);\n    // Put the rendered pixels into the pixelBuffer\n    renderer.readRenderTargetPixels(\n      this.renderTargetB,\n      0,\n      0,\n      this.renderTargetB.width,\n      this.renderTargetB.height,\n      this.pixelBuffer\n    );\n    this.imageData.data.set(this.pixelBuffer);\n\n    // The image is rendered upside down, so we flip it\n    this.ctxFlipped.putImageData(this.imageData, 0, 0);\n    this.ctx.save();\n    this.ctx.scale(1, -1);\n    this.ctx.drawImage(this.canvasFlipped, 0, -this.canvas.height, this.canvas.width, this.canvas.height);\n    this.ctx.restore();\n\n    // Reset the camera aspect\n    camera.aspect = aspect;\n    camera.updateProjectionMatrix();\n\n    // Reset the finalpass uniforms\n    postProcessing.finalPass.resize(finalPassWidth, finalPassHeight);\n    scene.resize(finalPassWidth, finalPassHeight);\n\n    // Save out the image\n    this.save();\n  };\n\n  capture2(scene: BaseScene, camera: PerspectiveCamera) {\n    // Save aspect for resetting after render\n    // const aspect = camera.aspect;\n\n    // // Update aspect to the screenshot size ratio\n    // camera.aspect = this.width / this.height;\n    // camera.updateProjectionMatrix();\n\n    // // Save current width / height\n    // const finalPassWidth = postProcessing.finalPass.mesh.material.uniforms.resolution.value.x;\n    // const finalPassHeight = postProcessing.finalPass.mesh.material.uniforms.resolution.value.y;\n    // const left = 0;\n    // const bottom = 0;\n    // const width = rendererSize.x;\n    // const height = rendererSize.y;\n\n    // renderer.setSize(this.width, this.height);\n    // renderer.setViewport(left, bottom, this.width, this.height);\n    // renderer.setScissor(left, bottom, this.width, this.height);\n\n    // // Update the final pass uniforms\n    // scene.resize(this.width, this.height);\n\n    // // Render the current scene into renderTargetA\n    // renderer.render(scene.scene, camera);\n\n    // // Reset the camera aspect\n    // camera.aspect = aspect;\n    // camera.updateProjectionMatrix();\n\n    // // Reset the finalpass uniforms\n    // scene.resize(finalPassWidth, finalPassHeight);\n    // renderer.setSize(this.width, this.height);\n    // renderer.setViewport(left, bottom, width, height);\n    // renderer.setScissor(left, bottom, width, height);\n\n    const filename = 'screenshot.png';\n    const format = 'image/png';\n    renderer.domElement.toBlob(function(blob) {\n      saveAs(blob, filename);\n    }, format);\n  }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Clock, Vector4, PerspectiveCamera, MathUtils } from 'three';\nimport renderer, { postProcessing } from './rendering/renderer';\nimport { setRendererSize, rendererSize } from './rendering/resize';\nimport settings from './settings';\nimport { rendererStats } from './utils/stats';\nimport { setQuery, getQueryFromParams } from './utils/query-params';\nimport { gui } from './utils/gui';\nimport PreloaderScene, { PRELOADER_SCENE_ID } from './scenes/preloader/preloader-scene';\nimport AppState from './app-state';\nimport MainScene, { MAIN_SCENE_ID } from './scenes/main/main-scene';\nimport Screenshot from './utils/screenshot';\n\nclass WebGLApp extends EventEmitter {\n  /**\n   * Creates an instance of WebGLApp.\n   * @param {HTMLElement} parent\n   * @memberof WebGLApp\n   */\n  constructor(parent: HTMLElement) {\n    super();\n    // Append the renderer canvas to the component reference\n    parent.appendChild(renderer.domElement);\n\n    // Clock for elapsed time and delta\n    this.clock = new Clock(true);\n\n    // Current request animation frame id\n    this.rafId = 0;\n\n    // Current frame delta\n    this.delta = 0;\n\n    // Flag to prevent multiple raf's running\n    this.isRendering = false;\n\n    // Initial state\n    this.state = new AppState({ ready: false });\n\n    // Scenes map\n    this.scenes = {\n      [PRELOADER_SCENE_ID]: PreloaderScene,\n      [MAIN_SCENE_ID]: MainScene\n    };\n    // List of ids to switch between\n    const sceneIds = [MAIN_SCENE_ID];\n\n    // The target scene id\n    this.sceneId = MAIN_SCENE_ID;\n    if (sceneIds.includes(getQueryFromParams('sceneId'))) {\n      this.sceneId = getQueryFromParams('sceneId');\n    }\n\n    this.viewport = {\n      debug: new Vector4(\n        0,\n        0,\n        rendererSize.x * settings.viewportPreviewScale,\n        rendererSize.y * settings.viewportPreviewScale\n      ),\n      main: new Vector4(0, 0, rendererSize.x, rendererSize.y)\n    };\n\n    // Add screenshot utility\n    this.screenshot = new Screenshot(gui, 720, 1280, 2);\n    this.screenshot.gui.add(this, 'captureScreenshot').name('capture');\n\n    // Gui settings group\n    const guiSettings = gui.addFolder('settings');\n    guiSettings.open();\n\n    // Toggle between dev and scene camera\n    // guiSettings.add(settings, 'devCamera').onChange((value: string) => {\n    //   setQuery('devCamera', value);\n    //   postProcessing.resize();\n    //   this.currentScene.toogleCameras(value);\n    // });\n\n    // Toggle between dev and scene camera\n    guiSettings.add(settings, 'postProcessing').onChange((value: string) => {\n      setQuery('postProcessing', value);\n    });\n\n    // Toggle scene helpers\n    // guiSettings.add(settings, 'helpers').onChange((value: string) => {\n    //   setQuery('helpers', value);\n    //   this.currentScene.toggleHelpers(value);\n    // });\n\n    // Toggle between scenes\n    // guiSettings\n    //   .add(this, 'sceneId', sceneIds)\n    //   .onChange((value: string) => {\n    //     this.setScene(value);\n    //     setQuery('sceneId', value);\n    //   })\n    //   .listen();\n\n    guiSettings\n      .add(settings, 'renderBufferFullscreen')\n      .name('max resolution')\n      .onChange((value: boolean) => {\n        setQuery('hd', value);\n        const maxRatio = MathUtils.clamp(window.devicePixelRatio, 1, 2);\n        renderer.setPixelRatio(value ? maxRatio : 1);\n        this.resize(window.innerWidth, window.innerHeight);\n      });\n  }\n\n  captureScreenshot = () => {\n    this.screenshot.capture2(this.currentScene, this.currentScene.camera);\n  };\n\n  /**\n   * Setup any\n   *\n   * @memberof WebGLApp\n   */\n  async setup() {\n    await new Promise((resolve, reject) => {\n      try {\n        // Setup the preloader scene right away as we need a scene to render on page load\n        this.setScene(PRELOADER_SCENE_ID)\n          .then(resolve)\n          .catch(reject);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  // Set the new state\n  setState = (state: AppState) => {\n    if (state.equals(this.state)) return;\n    this.prevState = this.state.clone();\n    this.state = state;\n    this.onStateChanged(this.state);\n  };\n\n  onStateChanged = (state: AppState) => {\n    if (this.state.ready && this.state.ready !== this.prevState.ready) {\n      this.setScene(this.sceneId);\n    }\n  };\n\n  /**\n   * Set the current scene to render\n   * The scene should be inheritted from BaseScene\n   *\n   * @param {BaseScene} scene\n   * @memberof WebGLApp\n   */\n  async setScene(sceneId: string) {\n    await new Promise((resolve, reject) => {\n      if (this.currentScene && sceneId === this.currentScene.id) return;\n      // Create new scene instance\n      const scene = new this.scenes[sceneId]();\n      scene\n        .setup()\n        .then(() => {\n          // Cache the previous scene\n          const previousScene = this.currentScene;\n          // Callback when the previous scene has animated out\n          const nextScene = () => {\n            // Set the current scene\n            this.currentScene = scene;\n            this.currentScene.resize(rendererSize.x, rendererSize.y);\n            // Animate the scene in\n            this.currentScene.animateIn().then(resolve, reject);\n            // Update the post processing scene transition pass\n            postProcessing.setScenes(postProcessing.sceneB, scene);\n            postProcessing.transitionPass.transition().then(() => {\n              // After the transition has ended, dispose of any objects\n              if (previousScene) previousScene.dispose();\n            });\n          };\n          // If the previous scene exists, animate out\n          if (previousScene) {\n            previousScene\n              .animateOut()\n              .then(nextScene)\n              .catch(reject);\n          } else {\n            // Otherwise go to the next scene immediately\n            nextScene();\n          }\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * resize handler\n   *\n   * @memberof WebGLApp\n   */\n  resize = (width: number, height: number) => {\n    setRendererSize(renderer, width, height);\n    this.currentScene.resize(rendererSize.x, rendererSize.y);\n    postProcessing.resize();\n    this.viewport.debug.set(\n      0,\n      0,\n      rendererSize.x * settings.viewportPreviewScale,\n      rendererSize.y * settings.viewportPreviewScale\n    );\n    this.viewport.main.set(0, 0, rendererSize.x, rendererSize.y);\n  };\n\n  /**\n   * Render the scene within viewport coordinates\n   *\n   * @memberof WebGLApp\n   */\n  renderScene = (camera: PerspectiveCamera, viewport: Vector4, delta: number, usePostProcessing: boolean) => {\n    renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);\n    renderer.setScissor(viewport.x, viewport.y, viewport.z, viewport.w);\n\n    if (usePostProcessing) {\n      postProcessing.render(delta);\n    } else {\n      this.currentScene.update(this.delta);\n      renderer.setClearColor(this.currentScene.clearColor);\n      renderer.render(this.currentScene.scene, camera);\n    }\n  };\n\n  /**\n   * Toggle the rendering and animation loop\n   *\n   * @memberof WebGLApp\n   */\n  render = (render: boolean) => {\n    if (this.isRendering === render) return;\n    this.isRendering = render;\n    if (render) {\n      this.update();\n    } else {\n      cancelAnimationFrame(this.rafId);\n    }\n  };\n\n  /**\n   * Main render loop and update of animations\n   *\n   * @memberof WebGLApp\n   */\n  update = () => {\n    this.rafId = requestAnimationFrame(this.update);\n    this.delta = this.clock.getDelta();\n\n    if (settings.devCamera) {\n      this.renderScene(this.currentScene.cameras.dev, this.viewport.main, this.delta, false);\n      this.renderScene(this.currentScene.cameras.main, this.viewport.debug, this.delta, settings.postProcessing);\n    } else {\n      this.renderScene(this.currentScene.cameras.main, this.viewport.main, this.delta, settings.postProcessing);\n    }\n\n    if (settings.stats) {\n      rendererStats.update(renderer);\n    }\n  };\n}\n\nexport default WebGLApp;\n","import React from 'react';\nimport { TweenLite } from 'gsap/gsap-core';\nimport './App.css';\nimport WebGLApp from './webgl-app/webgl-app';\nimport AppState from './webgl-app/app-state';\n\ntype Props = {};\n\ntype State = {|\n  ready: boolean,\n  windowSize: { width: number, height: number }\n|};\n\nclass App extends React.PureComponent<Props, State> {\n  state = {\n    ready: false,\n    windowSize: { width: window.innerWidth, height: window.innerHeight }\n  };\n\n  componentDidMount() {\n    if (this.container === null) return;\n    this.webglApp = new WebGLApp(this.container);\n    this.webglApp\n      .setup()\n      .then(() => {\n        this.webglApp.setState(new AppState(this.state));\n        this.webglApp.render(true);\n        TweenLite.delayedCall(1, this.onReady);\n      })\n      .catch((error: String) => {\n        console.log(error);\n      });\n\n    window.addEventListener('resize', this.onResize);\n  }\n\n  componentDidUpdate(prevProps: Object, prevState: Object) {\n    if (this.container === null) return;\n\n    this.webglApp.setState(new AppState(this.state));\n\n    if (\n      this.state.windowSize.width !== prevState.windowSize.width ||\n      this.state.windowSize.height !== prevState.windowSize.height\n    ) {\n      // Resize the app\n      this.webglApp.resize(this.state.windowSize.width, this.state.windowSize.height);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.container === null) return;\n    this.webglApp.render(false);\n    window.removeEventListener('resize', this.onResize);\n  }\n\n  container: HTMLElement | null;\n  webglApp: WebGLApp;\n\n  onReady = () => {\n    this.setState({\n      ready: true\n    });\n  };\n\n  onResize = () => {\n    this.setState({\n      windowSize: { width: window.innerWidth, height: window.innerHeight }\n    });\n  };\n\n  render() {\n    return (\n      <div\n        className=\"App\"\n        ref={(node: HTMLElement | null) => {\n          this.container = node;\n        }}\n      >\n        <div className=\"About\">\n          <p>\n            A simple{' '}\n            <a href=\"https://github.com/ameliemaia/raytracing-in-one-weekend\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Raytracer\n            </a>{' '}\n            based on <br />\n            <a href=\"https://raytracing.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Ray Tracing in One Weekend\n            </a>{' '}\n            <br />\n            by{' '}\n            <a href=\"https://twitter.com/Peter_shirley\" target=\"_blank\" rel=\"noopener noreferrer\">\n              Peter Shirley\n            </a>\n          </p>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nconst root = document.getElementById('root');\nif (root) ReactDOM.render(<App />, root);\n"],"sourceRoot":""}
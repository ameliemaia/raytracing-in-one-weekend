(this["webpackJsonpraytracing-in-one-weekend"]=this["webpackJsonpraytracing-in-one-weekend"]||[]).push([[0],{24:function(e,n){},27:function(e,n,a){e.exports=a(50)},32:function(e,n,a){},33:function(e,n,a){},50:function(e,n,a){"use strict";a.r(n);var t,i=a(9),r=a.n(i),o=a(19),s=a.n(o),l=(a(32),a(1)),d=a(5),c=a(3),u=a(2),f=a(4),h=a(13),m=(a(33),a(7)),A=a.n(m),p=a(8),x=a(6),F=a(11),_=a(10),P=a.n(_),v=a(0),T=a(20),g=a(21),y=2*Math.PI,L=(Math.PI,Math.PI,Math.PI,new v.Hb),N=new v.Hb(1,1,1),S=(new v.Hb(0,1,0),v.N),I=a(35);function E(e){var n=I.parse(window.location.search);return void 0!==n[e]&&n[e]}function b(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=I.parse(window.location.search),i=Object.assign({},t,Object(x.a)({},e,n)),r=I.stringify(i);if(a)window.location.href="".concat(window.location.pathname,"?").concat(r);else{var o="".concat(window.location.protocol,"//").concat(window.location.host).concat(window.location.pathname,"?").concat(r);window.history.pushState({path:o},"",o)}}var w=["high","normal"],X="normal";function O(){return X}var R=Object(g.getGPUTier)();var U=E("graphics");X=w.includes(U)&&"string"===typeof U?U:function(){switch(R.tier){case"GPU_DESKTOP_TIER_3":case"GPU_DESKTOP_TIER_2":case"GPU_MOBILE_TIER_3":return"high";case"GPU_DESKTOP_TIER_1":default:return"normal"}}();var Q=(t={},Object(x.a)(t,"high",{antialias:!1,pixelRatio:"true"===E("hd")?S.clamp(window.devicePixelRatio,1,2):1,maxFrameBufferSize:new v.Gb(1280,720)}),Object(x.a)(t,"normal",{antialias:!1,pixelRatio:1,maxFrameBufferSize:new v.Gb(1280,720)}),t),Y={isDevelopment:!1,baseUrl:"/raytracing-in-one-weekend",stats:!0,devCamera:!1,helpers:!1,datGui:!0,skipTransitions:!1,guiPrecision:.001,viewportPreviewScale:.25};Y.renderBufferFullscreen="true"===E("hd")||!1,Y.postProcessing=!0;var M=Y,C=Q[O()],D=C.maxFrameBufferSize,j=C.pixelRatio,k=Math.sqrt(D.x*D.y),G=k*k,z=new v.Gb;function H(){var e=j;return Ze instanceof v.Lb&&(e=Ze.getPixelRatio()),{width:z.x*e,height:z.y*e}}function B(e,n,a){var t=function(e,n){var a=e,t=n;if(e*n>G){var i=t/a,r=(a=k)*(t=Math.floor(k*i)),o=Math.sqrt(G/r);a=Math.floor(a*o),t=Math.floor(t*o)}return{width:a,height:t}}(n,a),i=t.width,r=t.height;M.renderBufferFullscreen&&(i=n,r=a),z.x=i,z.y=r,e.setSize(z.x,z.y),e.domElement.style.width="".concat(n,"px"),e.domElement.style.height="".concat(a,"px")}a(12);function W(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1024,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},t={minFilter:v.G,magFilter:v.Y,format:v.nb,type:v.Fb,stencilBuffer:!1};return new v.Kb(e,n,Object.assign({},t,a))}var q=a(15);function V(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:N;e.position.set(a.x*n,a.y*n,a.z*n),e.lookAt(L)}function K(e){return new v.eb(65,e,.1,1e3)}function J(e){return new q.a(e,Ze.domElement)}var Z=a(14),$=function(){function e(){Object(l.a)(this,e)}return Object(d.a)(e,[{key:"add",value:function(e,n,a){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"open",value:function(){return this}},{key:"close",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"addFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"removeFolder",value:function(e){return this}},{key:"remove",value:function(){return this}},{key:"step",value:function(){return this}}]),e}(),ee=function(){function e(){Object(l.a)(this,e)}return Object(d.a)(e,[{key:"add",value:function(e,n,a){return this}},{key:"addFolder",value:function(e){return new $}},{key:"removeFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"close",value:function(){return this}},{key:"step",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"setValue",value:function(){return this}},{key:"remove",value:function(){return this}},{key:"open",value:function(){return this}}],[{key:"toggleHide",value:function(){return this}}]),e}(),ne=ee;M.datGui&&((ne=a(12).GUI).prototype.removeFolder=function(e){var n=this.__folders[e];n&&(n.close(),this.__ul.removeChild(n.domElement.parentNode),delete this.__folders[e],this.onResize())});var ae=new ne;Z.a.device.isDesktop||ae.close();var te=function e(n){Object(l.a)(this,e),Object.assign(this,n)},ie=function(e){function n(){return Object(l.a)(this,n),Object(c.a)(this,Object(u.a)(n).apply(this,arguments))}return Object(f.a)(n,e),n}(P.a);ie.json="json",ie.image="image",ie.threeFBX="fbx",ie.threeGLTF="gltf",ie.threeTexture="texture";var re=ie,oe=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(){var e=new Image;e.onload=function(){a.asset.data=e,a.emit("loaded",a.asset)},e.onerror=function(){a.emit("error","Failed to load ".concat(a.asset.src))},e.src=a.asset.src},a.asset=e,a}return Object(f.a)(n,e),n}(re),se=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(){var e=new XMLHttpRequest;e.onreadystatechange=function(){4===e.readyState&&(4===e.readyState&&200===e.status?(a.asset.data=JSON.parse(e.responseText),a.emit("loaded",a.asset)):a.emit("error","Failed to load ".concat(a.asset.src)))},e.open("GET",a.asset.src,!0),e.send()},a.asset=e,a}return Object(f.a)(n,e),n}(re),le=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(){(new v.Ab).load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(f.a)(n,e),n}(re),de=a(26),ce=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(){(new de.a).load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(f.a)(n,e),n}(re),ue=a(22),fe=new(a(23).a);fe.setDecoderPath("".concat(M.baseUrl,"/assets/lib/draco/gltf/")),fe.preload();var he,me=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(){var e=new ue.a;e.setDRACOLoader(fe);e.load(a.asset.src,(function(e){a.asset.data=e,a.emit("loaded",a.asset)}),null,(function(){a.emit("error","Failed to load ".concat(a.asset.src))}))},a.asset=e,a}return Object(f.a)(n,e),n}(re),Ae=(he={},Object(x.a)(he,re.image,oe),Object(x.a)(he,re.json,se),Object(x.a)(he,re.threeTexture,le),Object(x.a)(he,re.threeFBX,ce),Object(x.a)(he,re.threeGLTF,me),he),pe=function(e){function n(){var e,a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object(l.a)(this,n),(e=Object(c.a)(this,Object(u.a)(n).call(this))).load=function(n){e.loaders=[],n.forEach((function(n){void 0!==Ae[n.type]&&e.loaders.push(new Ae[n.type](n))})),e.loaded=0,e.queue=0,e.currentParallel=0,e.total=e.loaders.length,0===e.total?e.emit("loaded",n):e.loadNextInQueue()},e.loadNextInQueue=function(){if(e.queue<e.total&&e.currentParallel<e.parallelLoads){var n=e.loaders[e.queue];e.queue+=1,e.currentParallel+=1,n.once("loaded",e.onLoaded),n.once("error",e.onError),n.load(),e.loadNextInQueue()}},e.onLoaded=function(){if(e.loaded+=1,e.emit("progress",e.loaded/e.total),e.loaded===e.total){var n=[];e.loaders.forEach((function(e){n.push(e.asset)})),e.emit("loaded",n)}else e.currentParallel-=1,e.loadNextInQueue()},e.onError=function(n){e.emit("error",n)},e.id=a.id||"",e.minParallel=a.minParallel||5,e.maxParallel=a.maxParallel||10,e.parallelLoads=Z.a.device.isDesktop?e.maxParallel:e.minParallel,e}return Object(f.a)(n,e),n}(P.a),xe=new(function(e){function n(){var e,a;Object(l.a)(this,n);for(var t=arguments.length,i=new Array(t),r=0;r<t;r++)i[r]=arguments[r];return(a=Object(c.a)(this,(e=Object(u.a)(n)).call.apply(e,[this].concat(i)))).load=function(e,n){var t=new pe({id:e});n.forEach((function(e){void 0===e.args&&(e.args={})})),t.on("progress",(function(e){a.emit("progress",e)})),t.once("loaded",(function(e){a.emit("loaded",e)})),t.once("error",(function(e){a.emit("error",e)})),t.load(n)},a}return Object(f.a)(n,e),n}(P.a)),Fe=a(25),_e=new(function(){function e(){Object(l.a)(this,e),this.assets={}}return Object(d.a)(e,[{key:"add",value:function(e,n){var a;this.assets[e]=this.assets[e]||[],(a=this.assets[e]).push.apply(a,Object(Fe.a)(n))}},{key:"get",value:function(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],t=this.find(this.assets[e],n);return!!(t&&t instanceof te)&&(a?t:t.data)}},{key:"find",value:function(e,n){return e.find((function(e){return e.id===n}))||!1}}]),e}());var Pe=function(e){function n(e){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(u.a)(n).call(this))).preloadGpuCullScene=function(e){},a.toggleHelpers=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];a.helpers.visible=e},a.toogleCameras=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];a.camera=e?a.cameras.dev:a.cameras.main,a.control=e?a.controls.dev:a.controls.main},a.resize=function(e,n){a.cameras.dev.aspect=e/n,a.cameras.dev.updateProjectionMatrix(),a.cameras.main.aspect=e/n,a.cameras.main.updateProjectionMatrix()},a.update=function(e){},a.dispose=function(){!function e(n,a){if(null!==n&&void 0!==n){if(a&&a.remove(n),n.dispose&&"Scene"!==n.type&&n.dispose(),n.geometry&&n.geometry.dispose(),n.material&&n.material.dispose(),n.children)for(var t=0,i=n.children.length;t<i;)e(n.children[0],n),t++;n=null}}(a.scene,null),a.gui&&ae.removeFolder(a.gui.name)},a.id=e.id||S.generateUUID(),a.clearColor=e.clearColor||0,a.lights=e.lights||[],a.assets=e.assets||[],a.scene=new v.qb,a.cameras={dev:K(z.x/z.y),main:K(z.x/z.y)},a.camera=M.devCamera?a.cameras.dev:a.cameras.main,V(a.cameras.dev,5),V(a.cameras.main,5),a.controls={},e.controls&&(a.controls.dev=J(a.cameras.dev),a.controls.main=J(a.cameras.main)),a.control=M.devCamera?a.controls.dev:a.controls.main,e.gui?(a.gui=ae.addFolder("".concat(a.id," scene")),e.guiOpen&&a.gui.open()):a.gui=new ee,a.lights.forEach((function(e){a.scene.add(e.light),e.gui(a.gui)})),a}return Object(f.a)(n,e),Object(d.a)(n,[{key:"loadAssets",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.assets.length>0?(xe.once("loaded",(function(a){a.length>0&&_e.add(n.id,a),e()})),xe.once("error",(function(e){a(e)})),xe.load(n.id,n.assets)):e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneHelpers",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.helpers=new v.v,n.helpers.add(new v.u(10,10),new v.c),n.helpers.visible=M.helpers,n.scene.add(n.helpers),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneObjects",value:function(){var e=Object(p.a)(A.a.mark((function e(){return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setup",value:function(){var e=Object(p.a)(A.a.mark((function e(){return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.loadAssets();case 2:return e.next=4,this.createSceneHelpers();case 4:return e.next=6,this.createSceneObjects();case 6:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(p.a)(A.a.mark((function e(){return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(p.a)(A.a.mark((function e(){return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(a){n(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(P.a),ve=a(47)(Promise,h.a),Te=function(e){function n(e,a,t){var i;Object(l.a)(this,n),(i=Object(c.a)(this,Object(u.a)(n).call(this))).resize=function(e,n){i.mesh.material.uniforms.resolution.value.x=e,i.mesh.material.uniforms.resolution.value.y=n},i.render=function(e,n,a,t,r){e.update(r),n.update(r),Ze.setClearColor(e.clearColor),Ze.setRenderTarget(a),Ze.render(e.scene,e.camera),Ze.setClearColor(n.clearColor),Ze.setRenderTarget(t),Ze.render(n.scene,n.camera),i.mesh.material.uniforms.texture0.value=a.texture,i.mesh.material.uniforms.texture1.value=t.texture,Ze.setRenderTarget(null)},i.gui=e.addFolder("transition pass"),i.gui.close(),i.scene=new v.qb,i.camera=t,i.active=!1;var r=H(),o=r.width,s=r.height,d=new v.rb({uniforms:{texture0:{value:null},texture1:{value:null},transition:{value:0},resolution:{value:new v.Gb(o,s)}},vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform sampler2D texture0;\n  uniform sampler2D texture1;\n  uniform float transition;\n  uniform vec2 resolution;\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(texture0, uv);\n    vec4 texel1 = texture2D(texture1, uv);\n    gl_FragColor = mix(texel0, texel1, transition);\n  }\n"});return i.mesh=new v.R(a,d),i.mesh.matrixAutoUpdate=!1,i.mesh.updateMatrix(),i.scene.add(i.mesh),i.gui.add(i.mesh.material.uniforms.transition,"value",0,1).onChange((function(e){i.active=0!==e&&1!==e})).name("transition").listen(),i}return Object(f.a)(n,e),Object(d.a)(n,[{key:"transition",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!M.skipTransitions){e.next=4;break}this.mesh.material.uniforms.transition.value=1,e.next=9;break;case 4:return this.mesh.material.uniforms.transition.value=0,this.active=!0,h.a.killTweensOf(this.mesh.material.uniforms.transition),e.next=9,ve.to(this.mesh.material.uniforms.transition,1,{value:1}).then((function(){n.active=!1,n.emit("complete")}));case 9:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()}]),n}(P.a),ge={fxaaEnabled:{value:1},fxaaResolution:{value:new v.Gb(1/1024,1/512)}};var ye="\n  uniform vec2 resolution;\n  uniform float time;\n  uniform sampler2D tDiffuse;\n  // FXAA pass\n  ".concat("\n  precision highp float;\n  uniform bool fxaaEnabled;\n  uniform vec2 fxaaResolution;\n  varying vec2 vUv;\n","\n  ").concat("\n  // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n  //----------------------------------------------------------------------------------\n  // File:        es3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n  // SDK Version: v3.00\n  // Email:       gameworks@nvidia.com\n  // Site:        http://developer.nvidia.com/\n  //\n  // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions\n  // are met:\n  //  * Redistributions of source code must retain the above copyright\n  //    notice, this list of conditions and the following disclaimer.\n  //  * Redistributions in binary form must reproduce the above copyright\n  //    notice, this list of conditions and the following disclaimer in the\n  //    documentation and/or other materials provided with the distribution.\n  //  * Neither the name of NVIDIA CORPORATION nor the names of its\n  //    contributors may be used to endorse or promote products derived\n  //    from this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n  // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n  // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  //----------------------------------------------------------------------------------\n\n  #define FXAA_PC 1\n  #define FXAA_GLSL_100 1\n  #define FXAA_QUALITY_PRESET 12\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n      //\n      // The console algorithm for PC is included\n      // for developers targeting really low spec machines.\n      // Likely better to just run FXAA_PC, and use a really low preset.\n      //\n      #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n      #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n      #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n      #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n      #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n      #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n      //\n      // For those using non-linear color,\n      // and either not able to get luma in alpha, or not wanting to,\n      // this enables FXAA to run using green as a proxy for luma.\n      // So with this enabled, no need to pack luma in alpha.\n      //\n      // This will turn off AA on anything which lacks some amount of green.\n      // Pure red and blue or combination of only R and B, will get no AA.\n      //\n      // Might want to lower the settings for both,\n      //    fxaaConsoleEdgeThresholdMin\n      //    fxaaQualityEdgeThresholdMin\n      // In order to insure AA does not get turned off on colors\n      // which contain a minor amount of green.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n      //\n      // Controls algorithm's early exit path.\n      // On PS3 turning this ON adds 2 cycles to the shader.\n      // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n      // Turning this off on console will result in a more blurry image.\n      // So this defaults to on.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n      //\n      // Only valid for PC OpenGL currently.\n      // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n      //\n      // 1 = Use discard on pixels which don't need AA.\n      //     For APIs which enable concurrent TEX+ROP from same surface.\n      // 0 = Return unchanged color on pixels which don't need AA.\n      //\n      #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n      //\n      // Used for GLSL 120 only.\n      //\n      // 1 = GL API supports fast pixel offsets\n      // 0 = do not use fast pixel offsets\n      //\n      #ifdef GL_EXT_gpu_shader4\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifndef FXAA_FAST_PIXEL_OFFSET\n          #define FXAA_FAST_PIXEL_OFFSET 0\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n      //\n      // 1 = API supports gather4 on alpha channel.\n      // 0 = API does not support gather4 on alpha channel.\n      //\n      #if (FXAA_HLSL_5 == 1)\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifndef FXAA_GATHER4_ALPHA\n          #define FXAA_GATHER4_ALPHA 0\n      #endif\n  #endif\n\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITY_PRESET\n      //\n      // Choose the quality preset.\n      // This needs to be compiled into the shader as it effects code.\n      // Best option to include multiple presets is to\n      // in each shader define the preset, then include this file.\n      //\n      // OPTIONS\n      // -----------------------------------------------------------------------\n      // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n      // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n      // 39       - no dither, very expensive\n      //\n      // NOTES\n      // -----------------------------------------------------------------------\n      // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n      // 13 = about same speed as FXAA 3.9 and better than 12\n      // 23 = closest to FXAA 3.9 visually and performance wise\n      //  _ = the lowest digit is directly related to performance\n      // _  = the highest digit is directly related to style\n      //\n      #define FXAA_QUALITY_PRESET 12\n  #endif\n\n\n  /*============================================================================\n\n                              FXAA QUALITY - PRESETS\n\n  ============================================================================*/\n\n  /*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 10)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 3.0\n      #define FXAA_QUALITY_P2 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 11)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 3.0\n      #define FXAA_QUALITY_P3 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 12)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 4.0\n      #define FXAA_QUALITY_P4 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 13)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 4.0\n      #define FXAA_QUALITY_P5 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 14)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 4.0\n      #define FXAA_QUALITY_P6 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 15)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 12.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 20)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 2.0\n      #define FXAA_QUALITY_P2 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 21)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 22)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 23)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 24)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 3.0\n      #define FXAA_QUALITY_P6 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 25)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 26)\n      #define FXAA_QUALITY_PS 9\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 4.0\n      #define FXAA_QUALITY_P8 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 27)\n      #define FXAA_QUALITY_PS 10\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 4.0\n      #define FXAA_QUALITY_P9 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 28)\n      #define FXAA_QUALITY_PS 11\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 4.0\n      #define FXAA_QUALITY_P10 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 29)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 39)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.0\n      #define FXAA_QUALITY_P2 1.0\n      #define FXAA_QUALITY_P3 1.0\n      #define FXAA_QUALITY_P4 1.0\n      #define FXAA_QUALITY_P5 1.5\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n\n\n  /*============================================================================\n\n                                  API PORTING\n\n  ============================================================================*/\n  #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n      #define FxaaBool bool\n      #define FxaaDiscard discard\n      #define FxaaFloat float\n      #define FxaaFloat2 vec2\n      #define FxaaFloat3 vec3\n      #define FxaaFloat4 vec4\n      #define FxaaHalf float\n      #define FxaaHalf2 vec2\n      #define FxaaHalf3 vec3\n      #define FxaaHalf4 vec4\n      #define FxaaInt2 ivec2\n      #define FxaaSat(x) clamp(x, 0.0, 1.0)\n      #define FxaaTex sampler2D\n  #else\n      #define FxaaBool bool\n      #define FxaaDiscard clip(-1)\n      #define FxaaFloat float\n      #define FxaaFloat2 float2\n      #define FxaaFloat3 float3\n      #define FxaaFloat4 float4\n      #define FxaaHalf half\n      #define FxaaHalf2 half2\n      #define FxaaHalf3 half3\n      #define FxaaHalf4 half4\n      #define FxaaSat(x) saturate(x)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_120 == 1)\n      // Requires,\n      //  #version 120\n      // And at least,\n      //  #extension GL_EXT_gpu_shader4 : enable\n      //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n      #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n      #if (FXAA_FAST_PIXEL_OFFSET == 1)\n          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n      #else\n          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n      #endif\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_130 == 1)\n      // Requires #version 130 or better\n      #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_3 == 1)\n      #define FxaaInt2 float2\n      #define FxaaTex sampler2D\n      #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n      #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_4 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_5 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n      #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n      #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n      #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n      #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n  #endif\n\n\n  /*============================================================================\n                      GREEN AS LUMA OPTION SUPPORT FUNCTION\n  ============================================================================*/\n  #if (FXAA_GREEN_AS_LUMA == 0)\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n  #else\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n  #endif\n\n\n\n\n  /*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n  ============================================================================*/\n  #if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n      //\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy} = center of pixel\n      FxaaFloat2 pos,\n      //\n      // Used only for FXAA Console, and not used on the 360 version.\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy_} = upper left of pixel\n      // {_zw} = lower right of pixel\n      FxaaFloat4 fxaaConsolePosPos,\n      //\n      // Input color texture.\n      // {rgb_} = color in linear or perceptual color space\n      // if (FXAA_GREEN_AS_LUMA == 0)\n      //     {__a} = luma in perceptual color space (not linear)\n      FxaaTex tex,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 2nd sampler.\n      // This sampler needs to have an exponent bias of -1.\n      FxaaTex fxaaConsole360TexExpBiasNegOne,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 3nd sampler.\n      // This sampler needs to have an exponent bias of -2.\n      FxaaTex fxaaConsole360TexExpBiasNegTwo,\n      //\n      // Only used on FXAA Quality.\n      // This must be from a constant/uniform.\n      // {x_} = 1.0/screenWidthInPixels\n      // {_y} = 1.0/screenHeightInPixels\n      FxaaFloat2 fxaaQualityRcpFrame,\n      //\n      // Only used on FXAA Console.\n      // This must be from a constant/uniform.\n      // This effects sub-pixel AA quality and inversely sharpness.\n      //   Where N ranges between,\n      //     N = 0.50 (default)\n      //     N = 0.33 (sharper)\n      // {x__} = -N/screenWidthInPixels\n      // {_y_} = -N/screenHeightInPixels\n      // {_z_} =  N/screenWidthInPixels\n      // {__w} =  N/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt,\n      //\n      // Only used on FXAA Console.\n      // Not used on 360, but used on PS3 and PC.\n      // This must be from a constant/uniform.\n      // {x__} = -2.0/screenWidthInPixels\n      // {_y_} = -2.0/screenHeightInPixels\n      // {_z_} =  2.0/screenWidthInPixels\n      // {__w} =  2.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n      //\n      // Only used on FXAA Console.\n      // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n      // This must be from a constant/uniform.\n      // {x__} =  8.0/screenWidthInPixels\n      // {_y_} =  8.0/screenHeightInPixels\n      // {_z_} = -4.0/screenWidthInPixels\n      // {__w} = -4.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_SUBPIX define.\n      // It is here now to allow easier tuning.\n      // Choose the amount of sub-pixel aliasing removal.\n      // This can effect sharpness.\n      //   1.00 - upper limit (softer)\n      //   0.75 - default amount of filtering\n      //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n      //   0.25 - almost off\n      //   0.00 - completely off\n      FxaaFloat fxaaQualitySubpix,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // The minimum amount of local contrast required to apply algorithm.\n      //   0.333 - too little (faster)\n      //   0.250 - low quality\n      //   0.166 - default\n      //   0.125 - high quality\n      //   0.063 - overkill (slower)\n      FxaaFloat fxaaQualityEdgeThreshold,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n      //   0.0625 - high quality (faster)\n      //   0.0312 - visible limit (slower)\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaQualityEdgeThresholdMin,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only three safe values here: 2 and 4 and 8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // For all other platforms can be a non-power of two.\n      //   8.0 is sharper (default!!!)\n      //   4.0 is softer\n      //   2.0 is really soft (good only for vector graphics inputs)\n      FxaaFloat fxaaConsoleEdgeSharpness,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only two safe values here: 1/4 and 1/8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // The console setting has a different mapping than the quality setting.\n      // Other platforms can use other values.\n      //   0.125 leaves less aliasing, but is softer (default!!!)\n      //   0.25 leaves more aliasing, and is sharper\n      FxaaFloat fxaaConsoleEdgeThreshold,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      // The console setting has a different mapping than the quality setting.\n      // This only applies when FXAA_EARLY_EXIT is 1.\n      // This does not apply to PS3,\n      // PS3 was simplified to avoid more shader instructions.\n      //   0.06 - faster but more aliasing in darks\n      //   0.05 - default\n      //   0.04 - slower and less aliasing in darks\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaConsoleEdgeThresholdMin,\n      //\n      // Extra constants for 360 FXAA Console only.\n      // Use zeros or anything else for other platforms.\n      // These must be in physical constant registers and NOT immediates.\n      // Immediates will result in compiler un-optimizing.\n      // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n      FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posM;\n      posM.x = pos.x;\n      posM.y = pos.y;\n      #if (FXAA_GATHER4_ALPHA == 1)\n          #if (FXAA_DISCARD == 0)\n              FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n              #if (FXAA_GREEN_AS_LUMA == 0)\n                  #define lumaM rgbyM.w\n              #else\n                  #define lumaM rgbyM.y\n              #endif\n          #endif\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n          #else\n              FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n          #endif\n          #if (FXAA_DISCARD == 1)\n              #define lumaM luma4A.w\n          #endif\n          #define lumaE luma4A.z\n          #define lumaS luma4A.x\n          #define lumaSE luma4A.y\n          #define lumaNW luma4B.w\n          #define lumaN luma4B.z\n          #define lumaW luma4B.x\n      #else\n          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              #define lumaM rgbyM.w\n          #else\n              #define lumaM rgbyM.y\n          #endif\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n          #endif\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat maxSM = max(lumaS, lumaM);\n      FxaaFloat minSM = min(lumaS, lumaM);\n      FxaaFloat maxESM = max(lumaE, maxSM);\n      FxaaFloat minESM = min(lumaE, minSM);\n      FxaaFloat maxWN = max(lumaN, lumaW);\n      FxaaFloat minWN = min(lumaN, lumaW);\n      FxaaFloat rangeMax = max(maxWN, maxESM);\n      FxaaFloat rangeMin = min(minWN, minESM);\n      FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n      FxaaFloat range = rangeMax - rangeMin;\n      FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n      FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n      if(earlyExit)\n          #if (FXAA_DISCARD == 1)\n              FxaaDiscard;\n          #else\n              return rgbyM;\n          #endif\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_GATHER4_ALPHA == 0)\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n          #endif\n      #else\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNS = lumaN + lumaS;\n      FxaaFloat lumaWE = lumaW + lumaE;\n      FxaaFloat subpixRcpRange = 1.0/range;\n      FxaaFloat subpixNSWE = lumaNS + lumaWE;\n      FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n      FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNESE = lumaNE + lumaSE;\n      FxaaFloat lumaNWNE = lumaNW + lumaNE;\n      FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n      FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNWSW = lumaNW + lumaSW;\n      FxaaFloat lumaSWSE = lumaSW + lumaSE;\n      FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n      FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n      FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n      FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n      FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n      FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n      FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n      FxaaBool horzSpan = edgeHorz >= edgeVert;\n      FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n      if(!horzSpan) lumaN = lumaW;\n      if(!horzSpan) lumaS = lumaE;\n      if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n      FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat gradientN = lumaN - lumaM;\n      FxaaFloat gradientS = lumaS - lumaM;\n      FxaaFloat lumaNN = lumaN + lumaM;\n      FxaaFloat lumaSS = lumaS + lumaM;\n      FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n      FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n      if(pairN) lengthSign = -lengthSign;\n      FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posB;\n      posB.x = posM.x;\n      posB.y = posM.y;\n      FxaaFloat2 offNP;\n      offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n      offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n      if(!horzSpan) posB.x += lengthSign * 0.5;\n      if( horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posN;\n      posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n      posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat2 posP;\n      posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n      posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n      FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n      FxaaFloat subpixE = subpixC * subpixC;\n      FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n      if(!pairN) lumaNN = lumaSS;\n      FxaaFloat gradientScaled = gradient * 1.0/4.0;\n      FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n      FxaaFloat subpixF = subpixD * subpixE;\n      FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n      lumaEndN -= lumaNN * 0.5;\n      lumaEndP -= lumaNN * 0.5;\n      FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n      FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n      FxaaBool doneNP = (!doneN) || (!doneP);\n      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n  /*--------------------------------------------------------------------------*/\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 3)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 4)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 5)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 6)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n  /*--------------------------------------------------------------------------*/\n                          #if (FXAA_QUALITY_PS > 7)\n                          if(doneNP) {\n                              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                              doneN = abs(lumaEndN) >= gradientScaled;\n                              doneP = abs(lumaEndP) >= gradientScaled;\n                              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                              doneNP = (!doneN) || (!doneP);\n                              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_QUALITY_PS > 8)\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 9)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 10)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 11)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 12)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n      #endif\n  /*--------------------------------------------------------------------------*/\n                          }\n                          #endif\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat dstN = posM.x - posN.x;\n      FxaaFloat dstP = posP.x - posM.x;\n      if(!horzSpan) dstN = posM.y - posN.y;\n      if(!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n      FxaaFloat spanLength = (dstP + dstN);\n      FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n      FxaaFloat spanLengthRcp = 1.0/spanLength;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool directionN = dstN < dstP;\n      FxaaFloat dst = min(dstN, dstP);\n      FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n      FxaaFloat subpixG = subpixF * subpixF;\n      FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n      FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n      FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n      if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n      if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n      #if (FXAA_DISCARD == 1)\n          return FxaaTexTop(tex, posM);\n      #else\n          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n      #endif\n  }\n  /*==========================================================================*/\n  #endif\n","\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 outgoingColor = texture2D(tDiffuse, uv);\n    // FXAA pass\n    ").concat("\n  // FXAA pass start\n  if (fxaaEnabled) {\n    outgoingColor = FxaaPixelShader(\n      uv,\n      vec4(0.0),\n      tDiffuse,\n      tDiffuse,\n      tDiffuse,\n      fxaaResolution,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n    );\n    // TODO avoid querying texture twice for same texel\n    outgoingColor.a = texture2D(tDiffuse, uv).a;\n  }\n  // FXAA pass end\n","\n    gl_FragColor.rgb = outgoingColor.rgb;\n    gl_FragColor.a = outgoingColor.a;\n  }\n"),Le=function(){function e(n,a,t){Object(l.a)(this,e),this.gui=n.addFolder("final pass"),this.gui.close(),this.scene=new v.qb,this.camera=t;var i=H(),r=i.width,o=i.height,s=new v.rb({uniforms:v.Eb.merge([{time:{value:0},tDiffuse:{value:null},resolution:{value:new v.Gb(r,o)}},ge]),vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:ye});!function(e,n){var a=e.addFolder("fxaa pass");a.close(),a.add(n.uniforms.fxaaEnabled,"value",0,1,1).name("enabled")}(this.gui,s),this.mesh=new v.R(a,s),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh)}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.mesh.material.uniforms.fxaaResolution.value.x=1/e,this.mesh.material.uniforms.fxaaResolution.value.y=1/n}},{key:"render",value:function(e,n,a){this.mesh.material.uniforms.tDiffuse.value=n.texture,this.mesh.material.uniforms.time.value+=a,Ze.render(this.scene,this.camera)}},{key:"screenshotRender",value:function(e,n,a,t,i){this.mesh.material.uniforms.tDiffuse.value=a.texture,this.mesh.material.uniforms.time.value+=i,Ze.setRenderTarget(t),Ze.render(this.scene,this.camera)}}]),e}(),Ne=function(e){function n(e,a){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(u.a)(n).call(this,{id:e,clearColor:a}))).camera.position.set(0,0,10),t.camera.lookAt(L),t}return Object(f.a)(n,e),n}(Pe),Se=function(){function e(n,a,t){Object(l.a)(this,e),this.scene=new v.qb,this.camera=t;var i=H(),r=i.width,o=i.height,s=new v.rb({uniforms:{tDiffuse:{value:null},resolution:{value:new v.Gb(r,o)}},vertexShader:"\n        void main() {\n          gl_Position = vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n        void main() {\n          vec2 uv = gl_FragCoord.xy / resolution;\n          gl_FragColor = texture2D(tDiffuse, uv);\n        }\n      "});this.mesh=new v.R(a,s),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh)}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n}},{key:"render",value:function(e,n){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];a?Ze.render(this.scene,this.camera):(Ze.setRenderTarget(e),this.mesh.material.uniforms.tDiffuse.value=n.texture,Ze.render(this.scene,this.camera),Ze.setRenderTarget(null))}}]),e}(),Ie=function(){function e(n,a,t){var i=this;Object(l.a)(this,e),this.reset=function(){i.passes=0},this.gui=n.addFolder("denoise pass"),this.gui.open(),this.scene=new v.qb,this.camera=t;var r=H(),o=r.width,s=r.height,d=new v.rb({uniforms:{tDiffusePrev:{value:null},tDiffuse:{value:null},frameCount:{value:0},resolution:{value:new v.Gb(o,s)}},vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform sampler2D tDiffuse;\n  uniform sampler2D tDiffusePrev;\n  uniform float frameCount;\n  uniform vec2 resolution;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(tDiffusePrev, uv);\n    vec4 texel1 = texture2D(tDiffuse, uv);\n    gl_FragColor = mix(texel0, texel1, clamp(1.0 / frameCount, 0.0, 1.0));\n  }\n"});this.mesh=new v.R(a,d),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh),this.active=!1,this.passes=0,this.maxPasses=2e3,this.gui.add(this,"passes").listen(),this.gui.add(this,"maxPasses",0,2e4),this.gui.add(this,"active").onChange(this.reset).listen()}return Object(d.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.reset()}},{key:"render",value:function(e,n,a,t){this.mesh.material.uniforms.frameCount.value=this.passes,Ze.setRenderTarget(n),Ze.render(e.scene,e.camera),Ze.setRenderTarget(t),this.mesh.material.uniforms.tDiffuse.value=n.texture,this.mesh.material.uniforms.tDiffusePrev.value=a.texture,Ze.render(this.scene,this.camera),Ze.setRenderTarget(null),this.passes++}},{key:"pauseRendering",value:function(){return this.active&&this.passes>=this.maxPasses}}]),e}(),Ee=a(24),be=a.n(Ee),we="\n  struct Camera {\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    float aspect;\n    vec3 origin;\n    float lensRadius;\n    vec3 u;\n    vec3 v;\n  };\n\n  struct Ray {\n    vec3 origin;\n    vec3 direction;\n  };\n\n  vec2 randomInUnitDisk() {\n    float x = rand(vUv + seed.xy);\n    float y = rand(vUv + seed.xz);\n    float r = mix(-1.0, 1.0, rand(vUv + seed.yw));\n\t  return r * vec2(sin(x * TWO_PI), cos(y * TWO_PI));\n  }\n\n  Ray getRay(float u, float v, Camera camera) {\n    vec2 rd = camera.lensRadius * randomInUnitDisk();\n    vec3 offset = camera.u * rd.x + camera.v * rd.y;\n    return Ray(camera.origin + offset, normalize(camera.lowerLeftCorner + u * camera.horizontal + v * camera.vertical - camera.origin - offset));\n  }\n\n  vec3 pointAtParameter(float t, Ray ray) {\n    return ray.origin + t * ray.direction;\n  }\n\n\n  Camera createCamera(vec3 origin, vec3 lookat, vec3 up, float aspect, float aperture, float focusDistance) {\n    Camera camera;\n\n    float theta = fov * (PI / 180.0);\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    vec3 w = normalize(origin - lookat);\n    camera.u = normalize(cross(up, w));\n    camera.v = cross(w, camera.u);\n\n    camera.aspect = aspect;\n    camera.lowerLeftCorner = origin - halfWidth * focusDistance * camera.u - halfHeight * focusDistance * camera.v - focusDistance * w;\n    camera.horizontal = 2.0 * halfWidth * focusDistance * camera.u;\n    camera.vertical = 2.0 * halfHeight * focusDistance * camera.v;\n    camera.origin = origin;\n    camera.lensRadius = aperture / 2.0;\n\n    return camera;\n  }\n",Xe="\n  struct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n  };\n",Oe=function(e){return"\n    bool sphereHit(Ray ray, const in float tMin, const in float tMax, const in Sphere sphere, inout HitRecord hitRecord) {\n\n      vec3 oc = ray.origin - sphere.center;\n      float a = dot(ray.direction, ray.direction); // origin\n      float b = dot(oc, ray.direction);\n      float c = dot(oc, oc) - sphere.radius * sphere.radius;\n      float discriminant = b * b - a * c;\n\n      if (discriminant < 0.0) return false;\n\n      float s = sqrt(discriminant);\n\n      float temp = (-b - s) / a;\n      if (temp < tMax && temp > tMin) {\n        hitRecord.t = temp;\n        hitRecord.position = ray.origin + temp * ray.direction;\n        hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n        hitRecord.material = sphere.material;\n        return true;\n      }\n      temp = (-b + s) / a;\n      if (temp < tMax && temp > tMin) {\n        hitRecord.t = temp;\n        hitRecord.position = ray.origin + temp * ray.direction;\n        hitRecord.normal = (hitRecord.position - sphere.center) / sphere.radius;\n        hitRecord.material = sphere.material;\n        return true;\n      }\n      return false;\n    }\n\n    bool hit(Ray ray, float tMin, float tMax, Sphere list[".concat(e,"], inout HitRecord hitRecord) {\n      bool hitAnything = false;\n      float closestSoFar = tMax;\n      // If record doesn't hit, we use the previous\n      HitRecord tempRecord = hitRecord;\n      for(int i = 0; i < ").concat(e,"; i++) {\n        if (sphereHit(ray, tMin, closestSoFar, list[i], tempRecord)) {\n          hitAnything = true;\n          closestSoFar = tempRecord.t;\n          hitRecord = tempRecord;\n        }\n      }\n      return hitAnything;\n    }\n  ")},Re="\n\n  vec3 ref(vec3 direction, vec3 normal) {\n    return direction - 2.0 * dot(direction, normal) * normal;\n  }\n\n  bool refract(const in vec3 direction, const in vec3 normal, const in float niOverNt, out vec3 refracted) {\n    float dt = dot(direction, normal);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if (discriminant > 0.0) {\n      refracted = niOverNt * (direction - normal * dt) - normal * sqrt(discriminant);\n      return true;\n    }\n    return false;\n  }\n\n  float schlick(float cosine, float reflectionIndex) {\n    float r0 = (1.0 - reflectionIndex) / (1.0 + reflectionIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n  }\n\n  bool scatter(inout Ray ray, const in HitRecord hitRecord, out vec3 attenuation, out Ray scatteredRay) {\n    if(hitRecord.material.type == METAL) {\n      attenuation = hitRecord.material.albedo;\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float fuzz = clamp(hitRecord.material.value, 0.0, 1.0);\n      scatteredRay = Ray(hitRecord.position, normalize(reflected + fuzz * randomInSphere(hitRecord.normal.xz)));\n      return (dot(scatteredRay.direction, hitRecord.normal) > 0.0);\n    } else if(hitRecord.material.type == DIELECTRIC) {\n\n      vec3 outwardNormal = vec3(0);\n      vec3 reflected = reflect(ray.direction, hitRecord.normal);\n      float niOverNt = 0.0;\n\n      float reflectionIndex = hitRecord.material.value;\n\n      attenuation = vec3(1.0);\n      vec3 refracted = vec3(0);\n      float reflectProbability = 0.0;\n      float cosine = 0.0;\n\n      if (dot(ray.direction, hitRecord.normal) > 0.0) {\n        outwardNormal = -hitRecord.normal;\n        niOverNt = reflectionIndex;\n        cosine = reflectionIndex * dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      } else {\n        outwardNormal = hitRecord.normal;\n        niOverNt = 1.0 / reflectionIndex;\n        cosine = -dot(ray.direction, hitRecord.normal) / length(ray.direction);\n      }\n\n      if(refract(ray.direction, outwardNormal, niOverNt, refracted)) {\n        scatteredRay = Ray(hitRecord.position, refracted);\n        reflectProbability = schlick(cosine, hitRecord.material.value);\n      } else {\n        scatteredRay = Ray(hitRecord.position, reflected);\n        reflectProbability = 1.0;\n      }\n\n      if (rand(vUv + seed.xy + hitRecord.position.xz) < reflectProbability) {\n        scatteredRay = Ray(hitRecord.position, reflected);\n      } else {\n        scatteredRay = Ray(hitRecord.position, refracted);\n      }\n\n      return true;\n    } else {\n      // lambert\n      attenuation = hitRecord.material.albedo;\n      vec3 target = hitRecord.position + hitRecord.normal + randomInSphere(hitRecord.normal.xz);\n      scatteredRay = Ray(hitRecord.position, normalize(target - hitRecord.position));\n      return true;\n    }\n  }\n",Ue=function(e,n){return"\n    vec3 raytraceWorld(in Ray ray, Sphere world[".concat(e,"]) {\n    HitRecord hitRecord;\n    vec3 color = vec3(1);\n\n    for(int i = 0; i < ").concat(n,"; i++) {\n      Ray scatteredRay;\n      if (hit(ray, 0.001, MAX_FLOAT, world, hitRecord)) {\n          vec3 attenuation;\n          if(scatter(ray, hitRecord, attenuation, scatteredRay)) {\n            color *= attenuation;\n            ray = scatteredRay;\n          } else {\n            return vec3(0);\n          }\n      } else {\n        // Sky color\n        float t = 0.5 * ray.direction.y + 1.0;\n        color *= mix(vec3(1), vec3(0.5, 0.7, 1.0), t);\n        return color;\n      }\n    }\n\n    return vec3(0);\n  }\n  ")},Qe={resolution:{value:new v.Gb},fov:{value:20},seed:{value:new v.Ib(Math.random(),Math.random(),Math.random(),Math.random())},time:{value:0},cameraAspect:{value:1},cameraAperture:{value:.1},cameraFocusDistance:{value:10},cameraAutoFocus:{value:0},cameraPosition:{value:new v.Hb},cameraTarget:{value:new v.Hb}},Ye=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return"\n    uniform vec2 resolution;\n    uniform float time;\n    uniform vec4 seed;\n    uniform float fov;\n    uniform vec3 cameraTarget;\n    uniform float cameraAspect;\n    uniform float cameraAperture;\n    uniform float cameraFocusDistance;\n    uniform float cameraAutoFocus;\n    varying vec2 vUv;\n\n    #define MAX_FLOAT 1e5\n    #define PI 3.141592653589793\n    #define TWO_PI 6.283185307179586\n    #define LAMBERT 0\n    #define METAL 1\n    #define DIELECTRIC 2\n\n    float rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec3 randomInSphere(vec2 seed2){\n      vec2 uv = vec2(rand(vUv + seed.xy + seed2), rand(vUv + seed.xz + seed2));\n      float theta = 2.0 * PI * uv.x;\n      float phi = acos(2.0 * uv.y - 1.0);\n      float radius = 1.0;\n      float x = (radius * sin(phi) * cos(theta));\n      float y = (radius * sin(phi) * sin(theta));\n      float z = (radius * cos(phi));\n      return vec3(x, y, z);\n    }\n\n    struct Material {\n      int type;\n      vec3 albedo;\n      float value;\n    };\n\n    struct HitRecord {\n      float t;\n      vec3 position;\n      vec3 normal;\n      Material material;\n    };\n\n    ".concat(we,"\n    ").concat(Xe,"\n    ").concat(Re,"\n    ").concat(Oe(e),"\n    ").concat(Ue(e,n),"\n\n    vec3 calculateNormals(float t, vec3 center, Ray ray) {\n      vec3 normal = pointAtParameter(t, ray) - center;\n      normal /= length(normal); // make normal unit length\n      return normal;\n    }\n\n    void main(){\n\n      // Fix aspect\n      vec2 uv = vUv;\n      uv.y -= 0.5;\n      uv.y *= 2.0 * resolution.y / resolution.x;\n      uv.y += 0.5;\n\n      ").concat(a,"\n\n      float focusDistance = mix(cameraFocusDistance, length(cameraPosition - cameraTarget), cameraAutoFocus);\n\n      Camera camera = createCamera(cameraPosition,\n                                  cameraTarget,\n                                  vec3(0.0, 1.0, 0.0),\n                                  2.0,\n                                  cameraAperture,\n                                  focusDistance);\n\n      Ray ray = getRay(uv.x, uv.y, camera);\n\n      vec3 outgoingColor = raytraceWorld(ray, world);\n\n      gl_FragColor = vec4(outgoingColor, 1.0);\n      gl_FragColor = LinearTosRGB(gl_FragColor);\n    }\n  ")},Me=function(){function e(n,a,t){var i=this;Object(l.a)(this,e),this.createMaterial=function(){var e=i.getSceneShader();return new v.rb({uniforms:Qe,vertexShader:"\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:Ye(e.size,i.maxBounces,e.scene)})},this.rebuild=function(){switch(i.mesh.material=i.createMaterial(),i.scene){case"final":i.camera.position.set(13,2,3),i.control.target.set(0,0,0),i.setAperture(.1),i.setFocusDistance(10),i.setAutoFocus(!1);break;default:i.camera.position.set(3,3,2),i.control.target.set(0,0,-1),i.setAperture(2),i.setAutoFocus(!0)}i.onChange()},this.onChange=function(){qe.denoisePass.reset()},this.onChange=function(){qe.denoisePass.reset()},this.gui=n.addFolder("raytracer"),this.gui.open(),this.camera=a,this.control=t;var r=["final","simple"];this.scene=r[0],this.maxSpheres=200,this.maxBounces=50,this.gridSize=11,this.cameraAutoFocus=1===Qe.cameraAutoFocus.value,this.mesh=new v.R(new v.fb(2,2),this.createMaterial()),this.gui.add(this,"scene",r).onChange(this.rebuild),this.gui.add(this,"maxBounces",1,100,1).onChange(this.rebuild),this.gui.add(this,"maxSpheres",1,500,1).onChange(this.rebuild),this.gui.add(this,"gridSize",1,11).onChange(this.rebuild);var o=this.gui.addFolder("camera");o.open(),o.add(this.mesh.material.uniforms.fov,"value",1,100).name("fov").onChange(this.onChange),o.add(this.mesh.material.uniforms.cameraAperture,"value",0,10).name("aperture").onChange(this.onChange).listen(),o.add(this.mesh.material.uniforms.cameraFocusDistance,"value",0,100).name("focus dist").onChange(this.onChange).listen(),o.add(this,"cameraAutoFocus",0,1).name("auto focus").onChange((function(){i.mesh.material.uniforms.cameraAutoFocus.value=i.cameraAutoFocus?1:0,i.onChange()})).listen()}return Object(d.a)(e,[{key:"createSimpleScene",value:function(){return{scene:"\n    Sphere world[5];\n    world[0] = Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(LAMBERT, vec3(0.1, 0.2, 0.5), 0.0));\n    world[1] = Sphere(vec3(0.0, -100.5, 0.0), 100.0, Material(LAMBERT, vec3(0.5), 0.0));\n    world[2] = Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(METAL, vec3(0.8, 0.6, 0.2), 0.0));\n    world[3] = Sphere(vec3(-1.0, 0.0, -1.0), 0.5, Material(DIELECTRIC, vec3(0), 1.5));\n    world[4] = Sphere(vec3(-1.0, 0.0, -1.0), -0.45, Material(DIELECTRIC, vec3(0), 1.5));\n  ",size:5}}},{key:"createFinalScene",value:function(){var e=this.maxSpheres+4,n="",a=[];a[0]="Sphere(vec3(0.0, -1000.0, 0.0), 1000.0, Material(LAMBERT, vec3(0.5), 0.0))",a[1]="Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(DIELECTRIC, vec3(0), 1.5))",a[2]="Sphere(vec3(-4.0, 1.0, 0.0), 1.0, Material(LAMBERT, vec3(0.4, 0.2, 0.1), 0.0))",a[3]="Sphere(vec3(4.0, 1.0, 0.0), 1.0, Material(METAL, vec3(0.7, 0.6, 0.5), 0.0))";for(var t=new v.Hb(4,.2,0),i=e-a.length,r=Math.floor(Math.sqrt(i)),o=a.length,s=0;s<i;s++){var l=Math.random(),d=new v.Hb(0,.2,0),c=Math.floor(s/r)/r,u=s%r/r;d.x=v.O.lerp(-this.gridSize,this.gridSize,c)+v.O.randFloat(0,.9),d.z=v.O.lerp(-this.gridSize,this.gridSize,u)+v.O.randFloat(0,.9),d.distanceTo(t)>.9&&(a[o++]=l<.8?"Sphere(vec3(".concat(d.x,",").concat(d.y,",").concat(d.z,"), 0.2, Material(LAMBERT, vec3(").concat(Math.random()*Math.random(),", ").concat(Math.random()*Math.random(),", ").concat(Math.random()*Math.random(),"), 0.0))"):l<.95?"Sphere(vec3(".concat(d.x,",").concat(d.y,",").concat(d.z,"), 0.2, Material(METAL, vec3(").concat(.5*(Math.random()+1),",").concat(.5*(Math.random()+1),", ").concat(.5*(Math.random()+1),"), ").concat(.5*Math.random(),"))"):"Sphere(vec3(".concat(d.x,",").concat(d.y,",").concat(d.z,"), 0.2, Material(DIELECTRIC, vec3(0), 1.5));"))}for(var f=0;f<a.length;f++)n+="world[".concat(f,"] = ").concat(a[f],";\n");return{scene:n="Sphere world[".concat(a.length,"];\n")+n,size:a.length}}},{key:"getSceneShader",value:function(){switch(this.scene){case"final":return this.createFinalScene();default:return this.createSimpleScene()}}},{key:"setAperture",value:function(e){this.mesh.material.uniforms.cameraAperture.value=e}},{key:"setAutoFocus",value:function(e){this.mesh.material.uniforms.cameraAutoFocus.value=e?1:0,this.cameraAutoFocus=e}},{key:"setFocusDistance",value:function(e){this.mesh.material.uniforms.cameraFocusDistance.value=e}},{key:"resize",value:function(e,n,a){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.mesh.material.uniforms.cameraAspect.value=a.aspect}},{key:"update",value:function(e,n,a){this.mesh.material.uniforms.seed.value.set(Math.random(),Math.random(),Math.random(),Math.random()),this.mesh.material.uniforms.time.value+=e,this.mesh.material.uniforms.cameraPosition.value.copy(n.position),this.mesh.material.uniforms.cameraTarget.value.copy(a.target)}}]),e}(),Ce=function(e){function n(){var e;return Object(l.a)(this,n),(e=Object(c.a)(this,Object(u.a)(n).call(this,{id:"main",assets:be.a,gui:!0,guiOpen:!0,controls:!0}))).resize=function(n,a){e.cameras.dev.aspect=n/a,e.cameras.dev.updateProjectionMatrix(),e.cameras.main.aspect=n/a,e.cameras.main.updateProjectionMatrix(),e.raytracer.resize(n,a,e.camera)},e.update=function(n){e.controls.main.update(),e.raytracer.update(n,e.camera,e.control)},e.cameras.main.position.set(13,2,3),e.control.target.set(0,0,0),e.control.update(),e}return Object(f.a)(n,e),Object(d.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.raytracer=new Me(n.gui,n.camera,n.control),n.scene.add(n.raytracer.mesh),n.control.addEventListener("change",(function(){qe.denoisePass.reset()})),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(Pe),De=function(){function e(n){var a=this;Object(l.a)(this,e),this.gui=n;var t=function(){var e=new v.g,n=new v.f(new Float32Array([-1,-1,0,-1,4,0,4,-1,0]),3);return e.setAttribute("position",n),e.setIndex([0,2,1]),e}();this.camera=new v.db(-1,1,1,-1,0,1);var i=H(),r=i.width,o=i.height,s={stencilBuffer:!1,format:v.mb};this.renderTargetTransitionA=W(r,o,s),this.renderTargetTransitionB=W(r,o,s),this.renderTargetDenoise=W(r,o,s),this.renderTargetDenoisePrev=W(r,o,s),this.renderTargetDenoiseCombined=W(r,o,s),this.transitionPass=new Te(this.gui,t,this.camera),this.finalPass=new Le(this.gui,t,this.camera),this.denoisePass=new Ie(this.gui,t,this.camera),this.copyPass=new Se(this.gui,t,this.camera),this.transitionPass.on("complete",(function(){"main"===a.sceneB.id&&(a.denoisePass.active=!0)}));var d=new Ne("post scene a",0),c=new Ne("post scene b",0);d.setup(),c.setup(),this.setScenes(d,c),this.resize()}return Object(d.a)(e,[{key:"setScenes",value:function(e,n){this.sceneA=e,this.sceneB=n}},{key:"resize",value:function(){var e=H(),n=e.width,a=e.height;this.renderTargetTransitionA.setSize(n,a),this.renderTargetTransitionB.setSize(n,a),this.renderTargetDenoise.setSize(n,a),this.renderTargetDenoisePrev.setSize(n,a),this.renderTargetDenoiseCombined.setSize(n,a),this.transitionPass.resize(n,a),this.denoisePass.resize(n,a),this.copyPass.resize(n,a),this.finalPass.resize(n,a)}},{key:"render",value:function(e){this.denoisePass.pauseRendering()||(this.currentScene=0===this.transitionPass.mesh.material.uniforms.transition.value?this.sceneA:this.sceneB,this.lastPass=this.currentScene,this.currentScene.update(e),this.transitionPass.active?(this.transitionPass.render(this.sceneA,this.sceneB,this.renderTargetTransitionA,this.renderTargetTransitionB,e),this.lastPass=this.transitionPass):(Ze.setClearColor(this.currentScene.clearColor),this.currentScene.update(e)),this.denoisePass.active?(this.denoisePass.render(this.lastPass,this.renderTargetDenoise,this.renderTargetDenoisePrev,this.renderTargetDenoiseCombined,this.transitionPass.active),this.copyPass.render(this.renderTargetDenoisePrev,this.renderTargetDenoiseCombined)):(Ze.setRenderTarget(this.renderTargetDenoiseCombined),Ze.render(this.lastPass.scene,this.lastPass.camera),Ze.setRenderTarget(null)),this.finalPass.render(this.lastPass,this.renderTargetDenoiseCombined,e))}}]),e}();function je(e,n){var a=document.createElement("canvas");return a.width=e,a.height=n,{ctx:a.getContext("2d"),canvas:a}}var ke=Q[O()],Ge=ke.pixelRatio,ze={antialias:ke.antialias,powerPreference:"high-performance",stencil:!1,preserveDrawingBuffer:!0};if(T.a.isWebGL2Available()){var He=je(1,1).canvas;ze.context=He.getContext("webgl2")}var Be=new v.Lb(ze);Be.setClearColor(0),Be.outputEncoding=v.Mb,Be.debug.checkShaderErrors=M.isDevelopment;var We=ae.addFolder("rendering");We.open(),Be.setPixelRatio(Ge),Be.setScissorTest(!0),B(Be,window.innerWidth,window.innerHeight);var qe=new De(We),Ve=Be.getContext(),Ke=Ve.getExtension("WEBGL_debug_renderer_info"),Je=Ve.getParameter(Ke.UNMASKED_RENDERER_WEBGL);M.isDevelopment&&console.log("Graphics: ".concat(O(),"\nGPU: ").concat(Je,"\nTier: ").concat(R.tier));var Ze=Be;var $e=new(M.isDevelopment?function(){var e=document.createElement("div");e.style.cssText="width:80px;opacity:0.9;cursor:pointer;z-index:100000;top:48px;position:absolute;";var n=document.createElement("div");n.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:rgb(0, 0, 0);",e.appendChild(n);var a=document.createElement("div");a.style.cssText="color:rgb(255, 255, 255);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",a.innerHTML="WebGLRenderer",n.appendChild(a);for(var t=[],i=0;i<9;i++)t[i]=document.createElement("div"),t[i].style.cssText="color:rgb(255, 255, 255);background-color:rgb(0, 0, 0);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",n.appendChild(t[i]),t[i].innerHTML="-";var r=Date.now();return{domElement:e,update:function(e){console.assert(e instanceof v.Lb),Date.now()-r<1e3/30||(r=Date.now(),t[0].textContent="=== Memory ===",t[1].textContent="Programs: "+e.info.programs.length,t[2].textContent="Geometries: "+e.info.memory.geometries,t[3].textContent="Textures: "+e.info.memory.textures,t[4].textContent="=== Render ===",t[5].textContent="Calls: "+e.info.render.calls,t[6].textContent="Triangles: "+e.info.render.triangles,t[7].textContent="Lines: "+e.info.render.lines,t[8].textContent="Points: "+e.info.render.points)}}}:function(){return{domElement:document.createElement("div"),update:function(e){}}});(M.stats&&($e.domElement.style.position="absolute",$e.domElement.style.left="0px",$e.domElement.style.top="48px"),M.stats)&&(a(48)().domElement.style.cssText="position:fixed;left:0;top:0;z-index:10000");var en=function(e){function n(){var e;return Object(l.a)(this,n),(e=Object(c.a)(this,Object(u.a)(n).call(this,{id:"preloader"}))).preloadGpuCullScene=function(n){e.spinner.material.uniforms.opacity.value=n?1:0},e.animateInit=function(){h.a.killTweensOf(e.spinner.material.uniforms.opacity),e.spinner.material.uniforms.opacity.value=0},e.update=function(n){e.spinner.rotation.z-=2*n},e.camera.position.set(0,0,10),e.camera.lookAt(L),e}return Object(f.a)(n,e),Object(d.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.spinner=new v.R(new v.pb(.9,1,32,1,0,.75*y),new v.rb({transparent:!0,uniforms:{opacity:{value:0}},vertexShader:"\n              varying vec2 vUv;\n              void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n              }\n            ",fragmentShader:"\n              uniform float opacity;\n              varying vec2 vUv;\n              void main() {\n                gl_FragColor = vec4(vUv, 1.0, vUv.y * opacity);\n              }\n          "})),n.spinner.name="spinner",n.scene.add(n.spinner),n.animateInit(),e()}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){M.skipTransitions?e():h.a.to(n.spinner.material.uniforms.opacity,1,{value:1,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){M.skipTransitions?e():h.a.to(n.spinner.material.uniforms.opacity,1,{value:0,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(Pe),nn=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(l.a)(this,e),this.ready=n.ready||!1}return Object(d.a)(e,[{key:"equals",value:function(e){return this.ready===e.ready}},{key:"clone",value:function(){return new e({ready:this.ready})}}]),e}(),an=a(16),tn=function(){function e(n,a,t){var i=this,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;Object(l.a)(this,e),this.save=function(){i.canvas.toBlob((function(e){Object(an.saveAs)(e,"screenshot.png")}),"image/png")},this.capture=function(e,n){i.ctx.clearRect(0,0,i.canvas.width,i.canvas.height);var a=n.aspect;n.aspect=i.width/i.height,n.updateProjectionMatrix();var t=qe.finalPass.mesh.material.uniforms.resolution.value.x,r=qe.finalPass.mesh.material.uniforms.resolution.value.y,o=z.x,s=z.y;Ze.setViewport(0,0,o,s),Ze.setScissor(0,0,o,s),e.resize(i.width,i.height),qe.finalPass.resize(i.width,i.height),Ze.setRenderTarget(i.renderTargetA),Ze.render(e.scene,n),Ze.setRenderTarget(null),qe.finalPass.screenshotRender(e.scene,n,i.renderTargetA,i.renderTargetB,0),Ze.readRenderTargetPixels(i.renderTargetB,0,0,i.renderTargetB.width,i.renderTargetB.height,i.pixelBuffer),i.imageData.data.set(i.pixelBuffer),i.ctxFlipped.putImageData(i.imageData,0,0),i.ctx.save(),i.ctx.scale(1,-1),i.ctx.drawImage(i.canvasFlipped,0,-i.canvas.height,i.canvas.width,i.canvas.height),i.ctx.restore(),n.aspect=a,n.updateProjectionMatrix(),qe.finalPass.resize(t,r),e.resize(t,r),i.save()},this.gui=n.addFolder("screenshot"),this.gui.open(),this.width=a*r,this.height=t*r,this.renderTargetA=new v.Kb(this.width,this.height,{minFilter:v.G,magFilter:v.G,format:v.mb,stencilBuffer:!1}),this.renderTargetB=new v.Kb(this.width,this.height,{minFilter:v.G,magFilter:v.G,format:v.mb,stencilBuffer:!1});var o=je(this.width,this.height),s=o.canvas,d=o.ctx,c=je(this.width,this.height),u=c.canvas,f=c.ctx;this.canvas=s,this.canvasFlipped=u,this.ctx=d,this.ctxFlipped=f,this.pixelBuffer=new Uint8Array(this.renderTargetA.width*this.renderTargetA.height*4),this.imageData=this.ctxFlipped.createImageData(this.canvas.width,this.canvas.height)}return Object(d.a)(e,[{key:"capture2",value:function(e,n){Ze.domElement.toBlob((function(e){Object(an.saveAs)(e,"screenshot.png")}),"image/png")}}]),e}(),rn=function(e){function n(e){var a,t;Object(l.a)(this,n),(t=Object(c.a)(this,Object(u.a)(n).call(this))).captureScreenshot=function(){t.screenshot.capture2(t.currentScene,t.currentScene.camera)},t.setState=function(e){e.equals(t.state)||(t.prevState=t.state.clone(),t.state=e,t.onStateChanged(t.state))},t.onStateChanged=function(e){t.state.ready&&t.state.ready!==t.prevState.ready&&t.setScene(t.sceneId)},t.resize=function(e,n){B(Ze,e,n),t.currentScene.resize(z.x,z.y),qe.resize(),t.viewport.debug.set(0,0,z.x*M.viewportPreviewScale,z.y*M.viewportPreviewScale),t.viewport.main.set(0,0,z.x,z.y)},t.renderScene=function(e,n,a,i){Ze.setViewport(n.x,n.y,n.z,n.w),Ze.setScissor(n.x,n.y,n.z,n.w),i?qe.render(a):(t.currentScene.update(t.delta),Ze.setClearColor(t.currentScene.clearColor),Ze.render(t.currentScene.scene,e))},t.render=function(e){t.isRendering!==e&&(t.isRendering=e,e?t.update():cancelAnimationFrame(t.rafId))},t.update=function(){t.rafId=requestAnimationFrame(t.update),t.delta=t.clock.getDelta(),M.devCamera?(t.renderScene(t.currentScene.cameras.dev,t.viewport.main,t.delta,!1),t.renderScene(t.currentScene.cameras.main,t.viewport.debug,t.delta,M.postProcessing)):t.renderScene(t.currentScene.cameras.main,t.viewport.main,t.delta,M.postProcessing),M.stats&&$e.update(Ze)},e.appendChild(Ze.domElement),t.clock=new v.j(!0),t.rafId=0,t.delta=0,t.isRendering=!1,t.state=new nn({ready:!1}),t.scenes=(a={},Object(x.a)(a,"preloader",en),Object(x.a)(a,"main",Ce),a);var i=["main"];t.sceneId="main",i.includes(E("sceneId"))&&(t.sceneId=E("sceneId")),t.viewport={debug:new v.Ib(0,0,z.x*M.viewportPreviewScale,z.y*M.viewportPreviewScale),main:new v.Ib(0,0,z.x,z.y)},t.screenshot=new tn(ae,720,1280,2),t.screenshot.gui.add(Object(F.a)(t),"captureScreenshot").name("capture");var r=ae.addFolder("settings");return r.open(),r.add(M,"postProcessing").onChange((function(e){b("postProcessing",e)})),r.add(M,"renderBufferFullscreen").name("max resolution").onChange((function(e){b("hd",e);var n=v.O.clamp(window.devicePixelRatio,1,2);Ze.setPixelRatio(e?n:1),t.resize(window.innerWidth,window.innerHeight)})),t}return Object(f.a)(n,e),Object(d.a)(n,[{key:"setup",value:function(){var e=Object(p.a)(A.a.mark((function e(){var n=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.setScene("preloader").then(e).catch(a)}catch(t){a(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setScene",value:function(){var e=Object(p.a)(A.a.mark((function e(n){var a=this;return A.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){if(!a.currentScene||n!==a.currentScene.id){var i=new a.scenes[n];i.setup().then((function(){var n=a.currentScene,r=function(){a.currentScene=i,a.currentScene.resize(z.x,z.y),a.currentScene.animateIn().then(e,t),qe.setScenes(qe.sceneB,i),qe.transitionPass.transition().then((function(){n&&n.dispose()}))};n?n.animateOut().then(r).catch(t):r()})).catch(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}()}]),n}(P.a),on=function(e){function n(){var e,a;Object(l.a)(this,n);for(var t=arguments.length,i=new Array(t),r=0;r<t;r++)i[r]=arguments[r];return(a=Object(c.a)(this,(e=Object(u.a)(n)).call.apply(e,[this].concat(i)))).state={ready:!1,windowSize:{width:window.innerWidth,height:window.innerHeight}},a.onReady=function(){a.setState({ready:!0})},a.onResize=function(){a.setState({windowSize:{width:window.innerWidth,height:window.innerHeight}})},a}return Object(f.a)(n,e),Object(d.a)(n,[{key:"componentDidMount",value:function(){var e=this;null!==this.container&&(this.webglApp=new rn(this.container),this.webglApp.setup().then((function(){e.webglApp.setState(new nn(e.state)),e.webglApp.render(!0),h.a.delayedCall(1,e.onReady)})).catch((function(e){console.log(e)})),window.addEventListener("resize",this.onResize))}},{key:"componentDidUpdate",value:function(e,n){null!==this.container&&(this.webglApp.setState(new nn(this.state)),this.state.windowSize.width===n.windowSize.width&&this.state.windowSize.height===n.windowSize.height||this.webglApp.resize(this.state.windowSize.width,this.state.windowSize.height))}},{key:"componentWillUnmount",value:function(){null!==this.container&&(this.webglApp.render(!1),window.removeEventListener("resize",this.onResize))}},{key:"render",value:function(){var e=this;return r.a.createElement("div",{className:"App",ref:function(n){e.container=n}},r.a.createElement("div",{className:"About"},r.a.createElement("p",null,"A simple"," ",r.a.createElement("a",{href:"https://github.com/ameliemaia/raytracing-in-one-weekend",target:"_blank",rel:"noopener noreferrer"},"Raytracer")," ","based on ",r.a.createElement("br",null),r.a.createElement("a",{href:"https://raytracing.github.io/",target:"_blank",rel:"noopener noreferrer"},"Ray Tracing in One Weekend")," ",r.a.createElement("br",null),"by"," ",r.a.createElement("a",{href:"https://twitter.com/Peter_shirley",target:"_blank",rel:"noopener noreferrer"},"Peter Shirley"))))}}]),n}(r.a.PureComponent),sn=document.getElementById("root");sn&&s.a.render(r.a.createElement(on,null),sn)}},[[27,1,2]]]);
//# sourceMappingURL=main.a13c5b03.chunk.js.map